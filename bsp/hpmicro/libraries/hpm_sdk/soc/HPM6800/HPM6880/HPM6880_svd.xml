<?xml version="1.0" encoding="UTF-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>HPMICRO</vendor>
  <name>HPM6880</name>
  <series>HPM6800</series>
  <version>1.0</version>
  <description>HPM6800 device</description>
  <licenseText>
    /*
 * Copyright (c) 2021-2024 HPMicro
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

  </licenseText>
  <cpu>
    <name>other</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>7</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>

  <!-- Default Properties -->
  <addressUnitBits>8</addressUnitBits> <!-- byte addressable memory -->
  <width>32</width> <!-- bus width is 32 bits -->
  <size>32</size>          <!-- this is the default size (number of bits) of all peripherals and register that do not define "size" themselves -->
  <access>read-write</access>  <!-- default access permission for all subsequent registers -->
  <resetValue>0x0</resetValue>  <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>  <!-- by default all 32Bits of the registers are used -->

  <!-- peripherals -->
  <peripherals>
    <peripheral>
      <name>FGPIO</name>
      <description>FGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xc0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>DI[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO input value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INPUT</name>
                <description>GPIO input bus value, each bit represents a bus bit
0: low level presents on chip pin
1: high level presents on chip pin</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>DO[%s]</name>
          <description>no description available</description>
          <addressOffset>0x100</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO output value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO output set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO output clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO output toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OUTPUT</name>
                <description>GPIO output register value, each bit represents a bus bit
0: chip pin output low level when direction is output
1: chip pin output high level when direction is output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>OE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO direction value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO direction set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO direction clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO direction toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DIRECTION</name>
                <description>GPIO direction, each bit represents a bus bit
0: input
1: output</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>IF[%s]</name>
          <description>no description available</description>
          <addressOffset>0x300</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt flag value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_FLAG</name>
                <description>GPIO interrupt flag, write 1 to clear this flag
0: no irq
1: irq pending</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>IE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt enable value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt enable set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt enable clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt enable toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_EN</name>
                <description>GPIO interrupt enable, each bit represents a bus bit
0: irq is disabled
1: irq is enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>PL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x500</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt polarity value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt polarity set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt polarity clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt polarity toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_POL</name>
                <description>GPIO interrupt polarity, each bit represents a bus bit
0: irq is high level or rising edge
1: irq is low level or falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>TP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt type value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt type set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt type clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt type toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_TYPE</name>
                <description>GPIO interrupt type, each bit represents a bus bit
0: irq is triggered by level
1: irq is triggered by edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>AS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x700</addressOffset>
          <register>
            <name>VALUE</name>
            <description>GPIO interrupt asynchronous value</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>GPIO interrupt asynchronous set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>GPIO interrupt asynchronous clear</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>GPIO interrupt asynchronous toggle</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IRQ_ASYNC</name>
                <description>GPIO interrupt asynchronous, each bit represents a bus bit
0: irq is triggered base on system clock
1: irq is triggered combinational
Note: combinational interrupt is sensitive to environment noise</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>GPIO0</name>
      <description>GPIO0</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf00d0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>PGPIO</name>
      <description>PGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf411c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="FGPIO">
      <name>BGPIO</name>
      <description>BGPIO</description>
      <groupName>GPIO</groupName>
      <baseAddress>0xf4214000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLIC</name>
      <description>PLIC</description>
      <groupName>PLIC</groupName>
      <baseAddress>0xe4000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x202000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>feature</name>
          <description>Feature enable register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>VECTORED</name>
              <description>Vector mode enable
0: Disabled
1: Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPT</name>
              <description>Preemptive priority interrupt enable
0: Disabled
1: Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>127</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PRIORITY1,PRIORITY2,PRIORITY3,PRIORITY4,PRIORITY5,PRIORITY6,PRIORITY7,PRIORITY8,PRIORITY9,PRIORITY10,PRIORITY11,PRIORITY12,PRIORITY13,PRIORITY14,PRIORITY15,PRIORITY16,PRIORITY17,PRIORITY18,PRIORITY19,PRIORITY20,PRIORITY21,PRIORITY22,PRIORITY23,PRIORITY24,PRIORITY25,PRIORITY26,PRIORITY27,PRIORITY28,PRIORITY29,PRIORITY30,PRIORITY31,PRIORITY32,PRIORITY33,PRIORITY34,PRIORITY35,PRIORITY36,PRIORITY37,PRIORITY38,PRIORITY39,PRIORITY40,PRIORITY41,PRIORITY42,PRIORITY43,PRIORITY44,PRIORITY45,PRIORITY46,PRIORITY47,PRIORITY48,PRIORITY49,PRIORITY50,PRIORITY51,PRIORITY52,PRIORITY53,PRIORITY54,PRIORITY55,PRIORITY56,PRIORITY57,PRIORITY58,PRIORITY59,PRIORITY60,PRIORITY61,PRIORITY62,PRIORITY63,PRIORITY64,PRIORITY65,PRIORITY66,PRIORITY67,PRIORITY68,PRIORITY69,PRIORITY70,PRIORITY71,PRIORITY72,PRIORITY73,PRIORITY74,PRIORITY75,PRIORITY76,PRIORITY77,PRIORITY78,PRIORITY79,PRIORITY80,PRIORITY81,PRIORITY82,PRIORITY83,PRIORITY84,PRIORITY85,PRIORITY86,PRIORITY87,PRIORITY88,PRIORITY89,PRIORITY90,PRIORITY91,PRIORITY92,PRIORITY93,PRIORITY94,PRIORITY95,PRIORITY96,PRIORITY97,PRIORITY98,PRIORITY99,PRIORITY100,PRIORITY101,PRIORITY102,PRIORITY103,PRIORITY104,PRIORITY105,PRIORITY106,PRIORITY107,PRIORITY108,PRIORITY109,PRIORITY110,PRIORITY111,PRIORITY112,PRIORITY113,PRIORITY114,PRIORITY115,PRIORITY116,PRIORITY117,PRIORITY118,PRIORITY119,PRIORITY120,PRIORITY121,PRIORITY122,PRIORITY123,PRIORITY124,PRIORITY125,PRIORITY126,PRIORITY127</dimIndex>
          <name>PRIORITY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRIORITY</name>
              <description>Interrupt source priority. The valid range of this field is 0-7.
0: Never interrupt
1-7: Interrupt source priority. The larger the value, the higher the priority.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>PENDING0,PENDING1,PENDING2,PENDING3</dimIndex>
          <name>PENDING[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>The interrupt pending status of inpterrupt sources. Every interrupt source occupies 1 bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TRIGGER0,TRIGGER1,TRIGGER2,TRIGGER3</dimIndex>
          <name>TRIGGER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>The interrupt trigger type of interrupt sources. Every interrupt source occupies 1 bit.
0: Level-triggered interrupt
1: Edge-triggered interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NUMBER</name>
          <description>Number of supported interrupt sources and targets</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_TARGET</name>
              <description>The number of supported targets</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_INTERRUPT</name>
              <description>The number of supported interrupt sources</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INFO</name>
          <description>Version and the maximum priority</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_PRIORITY</name>
              <description>The maximum priority supported</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VERSION</name>
              <description>The version of the PLIC design</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>target0,target1</dimIndex>
          <name>TARGETINT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2000</addressOffset>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>INTEN0,INTEN1,INTEN2,INTEN3</dimIndex>
            <name>INTEN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INTERRUPT</name>
                <description>The interrupt enable bit for interrupt. Every interrupt source occupies 1 bit.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>target0,target1</dimIndex>
          <name>TARGETCONFIG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200000</addressOffset>
          <register>
            <name>THRESHOLD</name>
            <description>Target0 priority threshold</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THRESHOLD</name>
                <description>Interrupt priority threshold.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLAIM</name>
            <description>Target claim and complete</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>INTERRUPT_ID</name>
                <description>On reads, indicating the interrupt source that has being claimed. On writes, indicating the interrupt source that has been handled (completed).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PPS</name>
            <description>Preempted priority stack</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PRIORITY_PREEMPTED</name>
                <description>Each bit indicates if the corresponding priority level has been preempted by a higher-priority interrupt.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MCHTMR</name>
      <description>MCHTMR</description>
      <groupName>MCHTMR</groupName>
      <baseAddress>0xe6000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MTIME</name>
          <description>Machine Time</description>
          <addressOffset>0x0</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000020210</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTIME</name>
              <description>Machine time</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTIMECMP</name>
          <description>Machine Time Compare</description>
          <addressOffset>0x8</addressOffset>
          <size>64</size>
          <resetValue>0x0000000000020210</resetValue>
          <resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MTIMECMP</name>
              <description>Machine time compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>64</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PLICSW</name>
      <description>PLICSW</description>
      <groupName>PLICSW</groupName>
      <baseAddress>0xe6400000</baseAddress>
      <addressBlock>
        <offset>0x1000</offset>
        <size>0x1ff008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PENDING</name>
          <description>Pending status</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000002</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>writing 1 to trigger software interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTEN</name>
          <description>Interrupt enable</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTERRUPT</name>
              <description>enable software interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLAIM</name>
          <description>Claim and complete.</description>
          <addressOffset>0x200004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>INTERRUPT_ID</name>
              <description>On reads, indicating the interrupt source that has being claimed. On writes, indicating the interrupt source that has been handled (completed).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>CRC</description>
      <groupName>CRC</groupName>
      <baseAddress>0xf000c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>CHN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>pre_set</name>
            <description>&amp;index0 pre set for crc setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>PRE_SET</name>
                <description>0: no pre set
1: CRC32
2: CRC32-AUTOSAR
3: CRC16-CCITT
4: CRC16-XMODEM
5: CRC16-MODBUS
1: CRC32
2: CRC32-autosar
3: CRC16-ccitt
4: CRC16-xmodem
5: CRC16-modbus
6: crc16_dnp
7: crc16_x25
8: crc16_usb
9: crc16_maxim
10: crc16_ibm
11: crc8_maxim
12: crc8_rohc
13: crc8_itu
14: crc8
15: crc5_usb</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>clr</name>
            <description>chn&amp;index0 clear crc result and setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>CLR</name>
                <description>write 1 to clr crc setting and result for its channel.
always read 0.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>poly</name>
            <description>chn&amp;index0 poly</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POLY</name>
                <description>poly setting</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>init_data</name>
            <description>chn&amp;index0 init_data</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>INIT_DATA</name>
                <description>initial data of CRC</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>xorout</name>
            <description>chn&amp;index0 xorout</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>XOROUT</name>
                <description>XOR for CRC result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>misc_setting</name>
            <description>chn&amp;index0 misc_setting</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0101013F</resetMask>
            <fields>
              <field>
                <name>BYTE_REV</name>
                <description>0: no wrap input byte order
1: wrap input byte order</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_OUT</name>
                <description>0: no wrap output bit order
1: wrap output bit order</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REV_IN</name>
                <description>0: no wrap input bit order
1: wrap input bit order</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POLY_WIDTH</name>
                <description>crc data length</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>data</name>
            <description>chn&amp;index0 data</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>data for crc</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>result</name>
            <description>chn&amp;index0 result</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESULT</name>
                <description>crc result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART0</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0040000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x3c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IDLE_CFG</name>
          <description>Idle Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000BFF</resetMask>
          <fields>
            <field>
              <name>RXEN</name>
              <description>UART receive enable.
0 - hold RX input to high, avoide wrong data input when config pinmux
1 - bypass RX input from PIN
software should set it after config pinmux</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_COND</name>
              <description>IDLE Detection Condition
0 - Treat as idle if RX pin is logic one
1 - Treat as idle if UART state machine state is idle</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_EN</name>
              <description>UART Idle Detect Enable
0 - Disable
1 - Enable
it should be enabled if enable address match feature</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_IDLE_THR</name>
              <description>Threshold for UART Receive Idle detection (in terms of bits)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cfg</name>
          <description>Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSIZE</name>
              <description>The depth of RXFIFO and TXFIFO
0: 16-byte FIFO
1: 32-byte FIFO
2: 64-byte FIFO
3: 128-byte FIFO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSCR</name>
          <description>Over Sample Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>OSC</name>
              <description>Over-sample control
The value must be an even number; any odd value
writes to this field will be converted to an even value.
OSC=0: reserved
OSC&lt;=8: The over-sample ratio is 8
8 &lt; OSC&lt; 32: The over sample ratio is OSC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCRR</name>
          <description>FIFO Control Register config</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RFIFOT</name>
              <description>Receiver FIFO trigger level</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFOT</name>
              <description>Transmitter FIFO trigger level</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAE</name>
              <description>DMA enable
0: Disable
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFIFORST</name>
              <description>Transmitter FIFO reset
Write 1 to clear all bytes in the TXFIFO and resets its
counter. The Transmitter Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFIFORST</name>
              <description>Receiver FIFO reset
Write 1 to clear all bytes in the RXFIFO and resets its
counter. The Receiver Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO enable
Write 1 to enable both the transmitter and receiver
FIFOs.
The FIFOs are reset when the value of this bit toggles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RBR</name>
          <description>Receiver Buffer Register (when DLAB = 0)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive data read port</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>THR</name>
          <description>Transmitter Holding Register (when DLAB = 0)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit data write port</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL</name>
          <description>Divisor Latch LSB (when DLAB = 1)</description>
          <alternateGroup>UNION_20</alternateGroup>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLL</name>
              <description>Least significant byte of the Divisor Latch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <description>Interrupt Enable Register (when DLAB = 0)</description>
          <alternateGroup>UNION_24</alternateGroup>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>ERXIDLE</name>
              <description>Enable Receive Idle interrupt
0 - Disable Idle interrupt
1 - Enable Idle interrupt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMSI</name>
              <description>Enable modem status interrupt
The interrupt asserts when the status of one of the
following occurs:
The status of modem_rin, modem_dcdn,
modem_dsrn or modem_ctsn (If the auto-cts mode is
disabled) has been changed.
If the auto-cts mode is enabled (MCR bit4 (AFE) = 1),
modem_ctsn would be used to control the transmitter.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELSI</name>
              <description>Enable receiver line status interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETHEI</name>
              <description>Enable transmitter holding register interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERBI</name>
              <description>Enable received data available interrupt and the
character timeout interrupt
0: Disable
1: Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DLM</name>
          <description>Divisor Latch MSB (when DLAB = 1)</description>
          <alternateGroup>UNION_24</alternateGroup>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLM</name>
              <description>Most significant byte of the Divisor Latch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IIR</name>
          <description>Interrupt Identification Register</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x800000CF</resetMask>
          <fields>
            <field>
              <name>RXIDLE_FLAG</name>
              <description>UART IDLE Flag
0 - UART is busy
1 - UART is idle
NOTE: when write one to clear this bit, avoid changging FCR register since it's same address as IIR</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOED</name>
              <description>FIFOs enabled
These two bits are 1 when bit 0 of the FIFO Control
Register (FIFOE) is set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRID</name>
              <description>Interrupt ID, see IIR2 for detail decoding</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FCR</name>
          <description>FIFO Control Register</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RFIFOT</name>
              <description>Receiver FIFO trigger level</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFIFOT</name>
              <description>Transmitter FIFO trigger level</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMAE</name>
              <description>DMA enable
0: Disable
1: Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFIFORST</name>
              <description>Transmitter FIFO reset
Write 1 to clear all bytes in the TXFIFO and resets its
counter. The Transmitter Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RFIFORST</name>
              <description>Receiver FIFO reset
Write 1 to clear all bytes in the RXFIFO and resets its
counter. The Receiver Shift Register is not cleared.
This bit will automatically be cleared.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOE</name>
              <description>FIFO enable
Write 1 to enable both the transmitter and receiver
FIFOs.
The FIFOs are reset when the value of this bit toggles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <description>Line Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DLAB</name>
              <description>Divisor latch access bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BC</name>
              <description>Break control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPS</name>
              <description>Stick parity
1: Parity bit is constant 0 or 1, depending on bit4 (EPS).
0: Disable the sticky bit parity.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPS</name>
              <description>Even parity select
1: Even parity (an even number of logic-1 is in the data
and parity bits)
0: Old parity.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEN</name>
              <description>Parity enable
When this bit is set, a parity bit is generated in
transmitted data before the first STOP bit and the parity
bit would be checked for the received data.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STB</name>
              <description>Number of STOP bits
0: 1 bits
1: The number of STOP bit is based on the WLS setting
When WLS = 0, STOP bit is 1.5 bits
When WLS = 1, 2, 3, STOP bit is 2 bits</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLS</name>
              <description>Word length setting
0: 5 bits
1: 6 bits
2: 7 bits
3: 8 bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MCR</name>
          <description>Modem Control Register (</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000032</resetMask>
          <fields>
            <field>
              <name>AFE</name>
              <description>Auto flow control enable
0: Disable
1: The auto-CTS and auto-RTS setting is based on the
RTS bit setting:
When RTS = 0, auto-CTS only
When RTS = 1, auto-CTS and auto-RTS</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOP</name>
              <description>Enable loopback mode
0: Disable
1: Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS</name>
              <description>Request to send
This bit controls the modem_rtsn output.
0: The modem_rtsn output signal will be driven HIGH
1: The modem_rtsn output signal will be driven LOW</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LSR</name>
          <description>Line Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>ERRF</name>
              <description>Error in RXFIFO
In the FIFO mode, this bit is set when there is at least
one parity error, framing error, or line break
associated with data in the RXFIFO. It is cleared when
this register is read and there is no more error for the
rest of data in the RXFIFO.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEMT</name>
              <description>Transmitter empty
This bit is 1 when the THR (TXFIFO in the FIFO
mode) and the Transmitter Shift Register (TSR) are
both empty. Otherwise, it is zero.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE</name>
              <description>Transmitter Holding Register empty
This bit is 1 when the THR (TXFIFO in the FIFO
mode) is empty. Otherwise, it is zero.
If the THRE interrupt is enabled, an interrupt is
triggered when THRE becomes 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LBREAK</name>
              <description>Line break
This bit is set when the uart_sin input signal was held
LOWfor longer than the time for a full-word
transmission. A full-word transmission is the
transmission of the START, data, parity, and STOP
bits. It is cleared when this register is read.
In the FIFO mode, this bit indicates the line break for
the received data at the top of the RXFIFO.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FE</name>
              <description>Framing error
This bit is set when the received STOP bit is not
HIGH. It is cleared when this register is read.
In the FIFO mode, this bit indicates the framing error
for the received data at the top of the RXFIFO.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PE</name>
              <description>Parity error
This bit is set when the received parity does not match
with the parity selected in the LCR[5:4]. It is cleared
when this register is read.
In the FIFO mode, this bit indicates the parity error
for the received data at the top of the RXFIFO.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OE</name>
              <description>Overrun error
This bit indicates that data in the Receiver Buffer
Register (RBR) is overrun.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DR</name>
              <description>Data ready.
This bit is set when there are incoming received data
in the Receiver Buffer Register (RBR). It is cleared
when all of the received data are read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSR</name>
          <description>Modem Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>CTS</name>
              <description>Clear to send
0: The modem_ctsn input signal is HIGH.
1: The modem_ctsn input signal is LOW.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCTS</name>
              <description>Delta clear to send
This bit is set when the state of the modem_ctsn input
signal has been changed since the last time this
register is read.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR</name>
          <description>GPR Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>A one-byte storage register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART1</name>
      <description>UART1</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0044000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART2</name>
      <description>UART2</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0048000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART3</name>
      <description>UART3</description>
      <groupName>UART</groupName>
      <baseAddress>0xf004c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART4</name>
      <description>UART4</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0050000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART5</name>
      <description>UART5</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0054000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART6</name>
      <description>UART6</description>
      <groupName>UART</groupName>
      <baseAddress>0xf0058000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>UART7</name>
      <description>UART7</description>
      <groupName>UART</groupName>
      <baseAddress>0xf005c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="UART0">
      <name>PUART</name>
      <description>PUART</description>
      <groupName>UART</groupName>
      <baseAddress>0xf4124000</baseAddress>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C0</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf0060000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x30</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>Cfg</name>
          <description>Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FIFOSIZE</name>
              <description>FIFO Size:
0: 2 bytes
1: 4 bytes
2: 8 bytes
3: 16 bytes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntEn</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPL</name>
              <description>Set to enable the Completion Interrupt.
Master: interrupts when a transaction is issued from this master and completed without losing the bus arbitration.
Slave: interrupts when a transaction addressing the controller is completed.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTERECV</name>
              <description>Set to enable the Byte Receive Interrupt.
Interrupts when a byte of data is received
Auto-ACK will be disabled if this interrupt is enabled, that is, the software needs to ACK/NACK the received byte manually.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTETRANS</name>
              <description>Set to enable the Byte Transmit Interrupt.
Interrupts when a byte of data is transmitted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>Set to enable the START Condition Interrupt.
Interrupts when a START condition/repeated START condition is detected.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Set to enable the STOP Condition Interrupt
Interrupts when a STOP condition is detected.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ARBLOSE</name>
              <description>Set to enable the Arbitration Lose Interrupt.
Master: interrupts when the controller loses the bus arbitration
Slave: not available in this mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRHIT</name>
              <description>Set to enable the Address Hit Interrupt.
Master: interrupts when the addressed slave returned an ACK.
Slave: interrupts when the controller is addressed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOHALF</name>
              <description>Set to enable the FIFO Half Interrupt.
Receiver: Interrupts when the FIFO is half-empty, i.e, there is &gt;= 1/2 entries in the FIFO.
Transmitter: Interrupts when the FIFO is half-empty, i.e. there is &lt;= 1/2 entries in the FIFO.
This interrupt depends on the transaction direction; dont enable this interrupt unless the transfer direction is determined, otherwise unintended interrupts may be triggered.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>Set to enable the FIFO Full Interrupt.
Interrupts when the FIFO is full.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFOEMPTY</name>
              <description>Set to enabled the FIFO Empty Interrupt
Interrupts when the FIFO is empty.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Status</name>
          <description>Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINESDA</name>
              <description>Indicates the current status of the SDA line on the bus
1: high
0: low</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LINESCL</name>
              <description>Indicates the current status of the SCL line on the bus
1: high
0: low</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GENCALL</name>
              <description>Indicates that the address of the current transaction is a general call address:
1: General call
0: Not general call</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSBUSY</name>
              <description>Indicates that the bus is busy
The bus is busy when a START condition is on bus and it ends when a STOP condition is seen on bus
1: Busy
0: Not busy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK</name>
              <description>Indicates the type of the last received/transmitted acknowledgement bit:
1: ACK
0: NACK</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMPL</name>
              <description>Transaction Completion
Master: Indicates that a transaction has been issued from this master and completed without losing the bus arbitration
Slave: Indicates that a transaction addressing the controller has been completed. This status bit must be cleared to receive the next transaction; otherwise, the next incoming transaction will be blocked.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BYTERECV</name>
              <description>Indicates that a byte of data has been received.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BYTETRANS</name>
              <description>Indicates that a byte of data has been transmitted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>START</name>
              <description>Indicates that a START Condition or a repeated START condition has been transmitted/received.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Indicates that a STOP Condition has been transmitted/received.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ARBLOSE</name>
              <description>Indicates that the controller has lost the bus arbitration.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ADDRHIT</name>
              <description>Master: indicates that a slave has responded to the transaction.
Slave: indicates that a transaction is targeting the controller (including the General Call).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FIFOHALF</name>
              <description>Transmitter: Indicates that the FIFO is half-empty.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOFULL</name>
              <description>Indicates that the FIFO is full.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFOEMPTY</name>
              <description>Indicates that the FIFO is empty.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Addr</name>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The slave address.
For 7-bit addressing mode, the most significant 3 bits are ignored and only the least-significant 7 bits of Addr are valid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Data</name>
          <description>Data Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Write this register to put one byte of data to the FIFO.
Read this register to get one byte of data from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Ctrl</name>
          <description>Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00905E00</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATACNT_HIGH</name>
              <description>Data counts in bytes.
Master: The number of bytes to transmit/receive. 0 means max length. DataCnt will be decreased by one for each byte transmitted/received.
Slave: the meaning of DataCnt depends on the DMA mode:
If DMA is not enabled, DataCnt is the number of bytes transmitted/received from the bus master. It is reset to 0 when the controller is addressed and then increased by one for each byte of data transmitted/received.
If DMA is enabled, DataCnt is the number of bytes to transmit/receive. It will not be reset to 0 when the slave is addressed and it will be decreased by one for each byte of data transmitted/received.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_LEN</name>
              <description>reset clock cycles. the clock high/low time is defined by Setup.T_SCLHi, 50% duty cycle.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_HOLD_SCKIN</name>
              <description>set to hold input clock to high when reset is active</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ON</name>
              <description>set to send reset signals(just toggle clock bus defined by reset_len).
this register is clered when reset is end, can't be cleared by software</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_START</name>
              <description>Enable this bit to send a START condition at the beginning of transaction.
Master mode only.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_ADDR</name>
              <description>Enable this bit to send the address after START condition.
Master mode only.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_DATA</name>
              <description>Enable this bit to send the data after Address phase.
Master mode only.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_STOP</name>
              <description>Enable this bit to send a STOP condition at the end of a transaction.
Master mode only.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIR</name>
              <description>Transaction direction
Master: Set this bit to determine the direction for the next transaction.
0: Transmitter
1: Receiver
Slave: The direction of the last received transaction.
0: Receiver
1: Transmitter</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATACNT</name>
              <description>Data counts in bytes.
Master: The number of bytes to transmit/receive. 0 means max length. DataCnt will be decreased by one for each byte transmitted/received.
Slave: the meaning of DataCnt depends on the DMA mode:
If DMA is not enabled, DataCnt is the number of bytes transmitted/received from the bus master. It is reset to 0 when the controller is addressed and then increased by one for each byte of data transmitted/received.
If DMA is enabled, DataCnt is the number of bytes to transmit/receive. It will not be reset to 0 when the slave is addressed and it will be decreased by one for each byte of data transmitted/received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cmd</name>
          <description>Command Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>Write this register with the following values to perform the corresponding actions:
0x0: no action
0x1: issue a data transaction (Master only)
0x2: respond with an ACK to the received byte
0x3: respond with a NACK to the received byte
0x4: clear the FIFO
0x5: reset the I2C controller (abort current transaction, set the SDA and SCL line to the open-drain mode, reset the Status Register and the Interrupt Enable Register, and empty the FIFO)
When issuing a data transaction by writing 0x1 to this register, the CMD field stays at 0x1 for the duration of the entire transaction, and it is only cleared to 0x0 after when the transaction has completed or when the controller loses the arbitration.
Note: No transaction will be issued by the controller when all phases (Start, Address, Data and Stop) are disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Setup</name>
          <description>Setup Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x05252100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_SUDAT</name>
              <description>T_SUDAT defines the data setup time before releasing the SCL.
Setup time = (2 * tpclk) + (2 + T_SP + T_SUDAT) * tpclk* (TPM+1)
tpclk = PCLK period
TPM = The multiplier value in Timing Parameter Multiplier Register</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SP</name>
              <description>T_SP defines the pulse width of spikes that must be suppressed by the input filter.
Pulse width = T_SP * tpclk* (TPM+1)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HDDAT</name>
              <description>T_HDDAT defines the data hold time after SCL goes LOW
Hold time = (2 * tpclk) + (2 + T_SP + T_HDDAT) * tpclk* (TPM+1)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SCLRADIO</name>
              <description>The LOW period of the generated SCL clock is defined by the combination of T_SCLRatio and T_SCLHi values. When T_SCLRatio = 0, the LOW period is equal to HIGH period. When T_SCLRatio = 1, the LOW period is roughly two times of HIGH period.
SCL LOW period = (2 * tpclk) + (2 + T_SP + T_SCLHi * ratio) * tpclk * (TPM+1)
1: ratio = 2
0: ratio = 1
This field is only valid when the controller is in the master mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_SCLHI</name>
              <description>The HIGH period of generated SCL clock is defined by T_SCLHi.
SCL HIGH period = (2 * tpclk) + (2 + T_SP + T_SCLHi) * tpclk* (TPM+1)
The T_SCLHi value must be greater than T_SP and T_HDDAT values.
This field is only valid when the controller is in the master mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMAEN</name>
              <description>Enable the direct memory access mode data transfer.
1: Enable
0: Disable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER</name>
              <description>Configure this device as a master or a slave.
1: Master mode
0: Slave mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRESSING</name>
              <description>I2C addressing mode:
1: 10-bit addressing mode
0: 7-bit addressing mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IICEN</name>
              <description>Enable the I2C controller.
1: Enable
0: Disable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TPM</name>
          <description>I2C Timing Paramater Multiplier</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPM</name>
              <description>A multiplication value for I2C timing parameters. All the timing parameters in the Setup Register are multiplied by (TPM+1).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C1</name>
      <description>I2C1</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf0064000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C2</name>
      <description>I2C2</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf0068000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2C0">
      <name>I2C3</name>
      <description>I2C3</description>
      <groupName>I2C</groupName>
      <baseAddress>0xf006c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI0</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0070000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x7c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>wr_trans_cnt</name>
          <description>Transfer count for write data</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRTRANCNT</name>
              <description>Transfer count for write data
WrTranCnt indicates the number of units of data to be transmitted to the SPI bus from the Data Register. The actual transfer count is (WrTranCnt+1).
WrTranCnt only takes effect when TransMode is 0, 1, 3, 4, 5, 6 or 8.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must be equal to RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rd_trans_cnt</name>
          <description>Transfer count for read data</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDTRANCNT</name>
              <description>Transfer count for read data
RdTranCnt indicates the number of units of data to be received from SPI bus and stored to the Data Register. The actual received count is (RdTranCnt+1).
RdTransCnt only takes effect when TransMode is 0, 2, 3, 4, 5, 6 or 9.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must equal RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TransFmt</name>
          <description>Transfer Format Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00020780</resetValue>
          <resetMask>0xFFFF1F9F</resetMask>
          <fields>
            <field>
              <name>ADDRLEN</name>
              <description>Address length in bytes
0x0: 1 byte
0x1: 2 bytes
0x2: 3 bytes
0x3: 4 bytes</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATALEN</name>
              <description>The length of each data unit in bits
The actual bit number of a data unit is (DataLen + 1)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAMERGE</name>
              <description>Enable Data Merge mode, which does automatic data split on write and data coalescing on read.
This bit only takes effect when DataLen = 0x7. Under Data Merge mode, each write to the Data Register will transmit all fourbytes of the write data; each read from the Data Register will retrieve four bytes of received data as a single word data.
When Data Merge mode is disabled, only the least (DataLen+1) significient bits of the Data Register are valid for read/write operations; no automatic data split/coalescing will be performed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSIBIDIR</name>
              <description>Bi-directional MOSI in regular (single) mode
0x0: MOSI is uni-directional signal in regular mode.
0x1: MOSI is bi-directional signal in regular mode. This bi-directional signal replaces the two</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Transfer data with the least significant bit first
0x0: Most significant bit first
0x1: Least significant bit first</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLVMODE</name>
              <description>SPI Master/Slave mode selection
0x0: Master mode
0x1: Slave mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>SPI Clock Polarity
0x0: SCLK is LOW in the idle states
0x1: SCLK is HIGH in the idle states</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>SPI Clock Phase
0x0: Sampling data at odd SCLK edges
0x1: Sampling data at even SCLK edges</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DirectIO</name>
          <description>Direct IO Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00003100</resetValue>
          <resetMask>0x013F3F3F</resetMask>
          <fields>
            <field>
              <name>DIRECTIOEN</name>
              <description>Enable Direct IO
0x0: Disable
0x1: Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_OE</name>
              <description>Output enable for the SPI Flash hold signal</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WP_OE</name>
              <description>Output enable for the SPI Flash write protect signal</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISO_OE</name>
              <description>Output enable fo the SPI MISO signal</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_OE</name>
              <description>Output enable for the SPI MOSI signal</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_OE</name>
              <description>Output enable for the SPI SCLK signal</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CS_OE</name>
              <description>Output enable for SPI CS (chip select) signal</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_O</name>
              <description>Output value for the SPI Flash hold signal</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WP_O</name>
              <description>Output value for the SPI Flash write protect signal</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISO_O</name>
              <description>Output value for the SPI MISO signal</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_O</name>
              <description>Output value for the SPI MOSI signal</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_O</name>
              <description>Output value for the SPI SCLK signal</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CS_O</name>
              <description>Output value for the SPI CS (chip select) signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOLD_I</name>
              <description>Status of the SPI Flash hold signal</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WP_I</name>
              <description>Status of the SPI Flash write protect signal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MISO_I</name>
              <description>Status of the SPI MISO signal</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MOSI_I</name>
              <description>Status of the SPI MOSI signal</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCLK_I</name>
              <description>Status of the SPI SCLK signal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CS_I</name>
              <description>Status of the SPI CS (chip select) signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TransCtrl</name>
          <description>Transfer Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLVDATAONLY</name>
              <description>Data-only mode (slave mode only)
0x0: Disable the data-only mode
0x1: Enable the data-only mode
Note: This mode only works in the uni-directional regular (single) mode so MOSIBiDir, DualQuad and TransMode should be set to 0.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMDEN</name>
              <description>SPI command phase enable (Master mode only)
0x0: Disable the command phase
0x1: Enable the command phase</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDREN</name>
              <description>SPI address phase enable (Master mode only)
0x0: Disable the address phase
0x1: Enable the address phase</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRFMT</name>
              <description>SPI address phase format (Master mode only)
0x0: Address phase is the regular (single) mode
0x1: The format of the address phase is the same as the data phase (DualQuad).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMODE</name>
              <description>Transfer mode
The transfer sequence could be
0x0: Write and read at the same time
0x1: Write only
0x2: Read only
0x3: Write, Read
0x4: Read, Write
0x5: Write, Dummy, Read
0x6: Read, Dummy, Write
0x7: None Data (must enable CmdEn or AddrEn in master mode)
0x8: Dummy, Write
0x9: Dummy, Read
0xa~0xf: Reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUALQUAD</name>
              <description>SPI data phase format
0x0: Regular (Single) mode
0x1: Dual I/O mode
0x2: Quad I/O mode
0x3: Reserved</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOKENEN</name>
              <description>Token transfer enable (Master mode only)
Append a one-byte special token following the address phase for SPI read transfers. The value of the special token should be selected in TokenValue.
0x0: Disable the one-byte special token
0x1: Enable the one-byte special token</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRTRANCNT</name>
              <description>Transfer count for write data
WrTranCnt indicates the number of units of data to be transmitted to the SPI bus from the Data Register. The actual transfer count is (WrTranCnt+1).
WrTranCnt only takes effect when TransMode is 0, 1, 3, 4, 5, 6 or 8.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must be equal to RdTranCnt.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOKENVALUE</name>
              <description>Token value (Master mode only)
The value of the one-byte special token following the address phase for SPI read transfers.
0x0: token value = 0x00
0x1: token value = 0x69</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DUMMYCNT</name>
              <description>Dummy data count. The actual dummy count is (DummyCnt +1).
The number of dummy cycles on the SPI interface will be (DummyCnt+1)* ((DataLen+1)/SPI IO width)
The Data pins are put into the high impedance during the dummy data phase.
DummyCnt is only used for TransMode 5, 6, 8 and 9, which has dummy data phases.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDTRANCNT</name>
              <description>Transfer count for read data
RdTranCnt indicates the number of units of data to be received from SPI bus and stored to the Data Register. The actual received count is (RdTranCnt+1).
RdTransCnt only takes effect when TransMode is 0, 2, 3, 4, 5, 6 or 9.
The size (bit-width) of a data unit is defined by the DataLen field of the Transfer Format Register.
For TransMode 0, WrTranCnt must equal RdTranCnt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Cmd</name>
          <description>Command Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>SPI Command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Addr</name>
          <description>Address Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>SPI Address
(Master mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Data</name>
          <description>Data Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to transmit or the received data
For writes, data is enqueued to the TX FIFO. The least significant byte is always transmitted first. If the TX FIFO is full and the SPIActive bit of the status register is 1, the ready signal hready/pready will be deasserted to insert wait states to the transfer.
For reads, data is read and dequeued from the RX FIFO. The least significant byte is the first received byte. If the RX FIFO is empty and the SPIActive bit of the status register is 1, the ready signal hready/pready will be deasserted to insert wait states to the transfer.
The FIFOs decouple the speed of the SPI transfers and the software generation/consumption of data. When the TX FIFO is empty, SPI transfers will hold until more data is written to the TX FIFO; when the RX FIFO is full, SPI transfers will hold until there is more room in the RX FIFO.
If more data is written to the TX FIFO than the write transfer count (WrTranCnt), the remaining data will stay in the TX FIFO for the next transfer or until the TX FIFO is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Ctrl</name>
          <description>Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFF1F</resetMask>
          <fields>
            <field>
              <name>CS_EN</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXTHRES</name>
              <description>Transmit (TX) FIFO Threshold
The TXFIFOInt interrupt or DMA request would be issued to replenish the TX FIFO when the TX data count is less than or equal to the TX FIFO threshold.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTHRES</name>
              <description>Receive (RX) FIFO Threshold
The RXFIFOInt interrupt or DMA request would be issued for consuming the RX FIFO when the RX data count is more than or equal to the RX FIFO threshold.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDMAEN</name>
              <description>TX DMA enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDMAEN</name>
              <description>RX DMA enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFORST</name>
              <description>Transmit FIFO reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFORST</name>
              <description>Receive FIFO reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPIRST</name>
              <description>SPI reset
Write 1 to reset. It is automatically cleared to 0 after the reset operation completes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Status</name>
          <description>Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x33FFFF01</resetMask>
          <fields>
            <field>
              <name>TXNUM_7_6</name>
              <description>Number of valid entries in the Transmit FIFO</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNUM_7_6</name>
              <description>Number of valid entries in the Receive FIFO</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFULL</name>
              <description>Transmit FIFO Full flag</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXEMPTY</name>
              <description>Transmit FIFO Empty flag</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXNUM_5_0</name>
              <description>Number of valid entries in the Transmit FIFO</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFULL</name>
              <description>Receive FIFO Full flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXEMPTY</name>
              <description>Receive FIFO Empty flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXNUM_5_0</name>
              <description>Number of valid entries in the Receive FIFO</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SPIACTIVE</name>
              <description>SPI register programming is in progress.
In master mode, SPIActive becomes 1 after the SPI command register is written and becomes 0 after the transfer is finished.
In slave mode, SPIActive becomes 1 after the SPI CS signal is asserted and becomes 0 after the SPI CS signal is deasserted.
Note that due to clock synchronization, it may take at most two spi_clock cycles for SPIActive to change when the corresponding condition happens.
Note this bit stays 0 when Direct IO Control or the memory-mapped interface is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntrEn</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SLVCMDEN</name>
              <description>Enable the Slave Command Interrupt.
Control whether interrupts are triggered whenever slave commands are received.
(Slave mode only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENDINTEN</name>
              <description>Enable the End of SPI Transfer interrupt.
Control whether interrupts are triggered when SPI transfers end.
(In slave mode, end of read status transaction doesn trigger this interrupt.)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOINTEN</name>
              <description>Enable the SPI Transmit FIFO Threshold interrupt.
Control whether interrupts are triggered when the valid entries are less than or equal to the TX FIFO threshold.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOINTEN</name>
              <description>Enable the SPI Receive FIFO Threshold interrupt.
Control whether interrupts are triggered when the valid entries are greater than or equal to the RX FIFO threshold.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOURINTEN</name>
              <description>Enable the SPI Transmit FIFO Underrun interrupt.
Control whether interrupts are triggered when the Transmit FIFO run out of data.
(Slave mode only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOORINTEN</name>
              <description>Enable the SPI Receive FIFO Overrun interrupt.
Control whether interrupts are triggered when the Receive FIFO overflows.
(Slave mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IntrSt</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SLVCMDINT</name>
              <description>Slave Command Interrupt.
This bit is set when Slave Command interrupts occur.
(Slave mode only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENDINT</name>
              <description>End of SPI Transfer interrupt.
This bit is set when End of SPI Transfer interrupts occur.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFIFOINT</name>
              <description>TX FIFO Threshold interrupt.
This bit is set when TX FIFO Threshold interrupts occur.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFIFOINT</name>
              <description>RX FIFO Threshold interrupt.
This bit is set when RX FIFO Threshold interrupts occur.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXFIFOURINT</name>
              <description>TX FIFO Underrun interrupt.
This bit is set when TX FIFO Underrun interrupts occur.
(Slave mode only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXFIFOORINT</name>
              <description>RX FIFO Overrun interrupt.
This bit is set when RX FIFO Overrun interrupts occur.
(Slave mode only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Timing</name>
          <description>Interface Timing Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>CS2SCLK</name>
              <description>The minimum time between the edges of SPI CS and the edges of SCLK.
SCLK_period * (CS2SCLK + 1) / 2</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSHT</name>
              <description>The minimum time that SPI CS should stay HIGH.
SCLK_period * (CSHT + 1) / 2</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_DIV</name>
              <description>The clock frequency ratio between the clock source and SPI interface SCLK.
SCLK_period = ((SCLK_DIV + 1) * 2) * (Period of the SPI clock source)
The SCLK_DIV value 0xff is a special value which indicates that the SCLK frequency should be the same as the spi_clock frequency.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvSt</name>
          <description>Slave Status Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>UNDERRUN</name>
              <description>Data underrun occurs in the last transaction</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Data overrun occurs in the last transaction</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READY</name>
              <description>Set this bit to indicate that the ATCSPI200 is ready for data transaction.
When an SPI transaction other than slave status-reading command ends, this bit will be cleared to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USR_STATUS</name>
              <description>User defined status flags</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataCnt</name>
          <description>Slave Data Count Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF03FF</resetMask>
          <fields>
            <field>
              <name>WCNT</name>
              <description>Slave transmitted data count</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCNT</name>
              <description>Slave received data count</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataWCnt</name>
          <description>WCnt</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SlvDataRCnt</name>
          <description>RCnt</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Config</name>
          <description>Configuration Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00004311</resetValue>
          <resetMask>0x000043FF</resetMask>
          <fields>
            <field>
              <name>SLAVE</name>
              <description>Support for SPI Slave mode</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QUADSPI</name>
              <description>Support for Quad I/O SPI</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DUALSPI</name>
              <description>Support for Dual I/O SPI</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXFIFOSIZE</name>
              <description>Depth of TX FIFO
0x0: 2 words
0x1: 4 words
0x2: 8 words
0x3: 16 words
0x4: 32 words
0x5: 64 words
0x6: 128 words</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RXFIFOSIZE</name>
              <description>Depth of RX FIFO
0x0: 2 words
0x1: 4 words
0x2: 8 words
0x3: 16 words
0x4: 32 words
0x5: 64 words
0x6: 128 words</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI1</name>
      <description>SPI1</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0074000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI2</name>
      <description>SPI2</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf0078000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SPI0">
      <name>SPI3</name>
      <description>SPI3</description>
      <groupName>SPI</groupName>
      <baseAddress>0xf007c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>GPTMR0</name>
      <description>GPTMR0</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>ch0,ch1,ch2,ch3</dimIndex>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CR</name>
            <description>Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x8003FFFF</resetMask>
            <fields>
              <field>
                <name>CNTUPT</name>
                <description>1- update counter to new value as CNTUPTVAL
This bit will be auto cleared after 1 cycle</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>OPMODE</name>
                <description>0:  round mode
1:  one-shot mode, timer will stopped at reload point.user need clear CEN and set it to start timer agian.
NOTE: reload irq will be always set at one-shot mode at end</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MONITOR_SEL</name>
                <description>set to monitor input signal high level time(chan_meas_high)
clr to monitor input signal period(chan_meas_prd)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MONITOR_EN</name>
                <description>set to monitor input signal period or high level time.
When this bit is set, if detected period less than val_0 or more than val_1, will set related irq_sts
* only can be used when trig_mode is selected as measure mode(100)
* the time may not correct after reload, so monitor is disabled after reload point, and enabled again after two continul posedge.
if no posedge after reload for more than val_1, will also assert irq_capt</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CNTRST</name>
                <description>1- reset counter</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCFLW</name>
                <description>1- enable this channel to reset counter to reload(RLD) together with its previous channel.
This bit is not valid for channel 0.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCIFEN</name>
                <description>1- SYNCI is valid on its falling edge</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SYNCIREN</name>
                <description>1- SYNCI is valid on its rising edge</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CEN</name>
                <description>1- counter enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPINIT</name>
                <description>Output compare initial poliarity
1- The channel output initial level is high
0- The channel output initial level is low
User should set this bit before set CMPEN to 1.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPEN</name>
                <description>1- Enable the channel output compare function. The output signal can be generated per comparator (CMPx) settings.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMASEL</name>
                <description>select one of DMA request:
00- CMP0 flag
01- CMP1 flag
10- Input signal toggle captured
11- RLD flag, counter reload;</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAEN</name>
                <description>1- enable dma</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SWSYNCIEN</name>
                <description>1- enable software sync. When this bit is set, counter will reset to RLD when swsynct bit is set</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DBGPAUSE</name>
                <description>1- counter will pause if chip is in debug mode</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPMODE</name>
                <description>This bitfield define the input capture mode
100:  width measure mode, timer will calculate the input signal period and duty cycle
011:  capture at both rising edge and falling edge
010:  capture at falling edge
001:  capture at rising edge
000:  No capture</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>CMP0,CMP1</dimIndex>
            <name>CMP[%s]</name>
            <description>no description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFF0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMP</name>
                <description>compare value 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RLD</name>
            <description>Reload register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RLD</name>
                <description>reload value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNTUPTVAL</name>
            <description>Counter update value register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNTUPTVAL</name>
                <description>counter will be set to this value when software write cntupt bit in CR</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPPOS</name>
            <description>Capture rising edge register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPOS</name>
                <description>This register contains the counter value captured at input signal rising edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPNEG</name>
            <description>Capture falling edge register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPNEG</name>
                <description>This register contains the counter value captured at input signal falling edge</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPPRD</name>
            <description>PWM period measure register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPPRD</name>
                <description>This register contains the input signal period when channel is configured to input capture measure mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPDTY</name>
            <description>PWM duty cycle measure register</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MEAS_HIGH</name>
                <description>This register contains the input signal duty cycle when channel is configured to input capture measure mode.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>Counter</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>32 bit counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>SR</name>
          <description>Status register</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3CMP1F</name>
              <description>channel 3 compare value 1 match flag</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3CMP0F</name>
              <description>channel 3 compare value 1 match flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3CAPF</name>
              <description>channel 3 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH3RLDF</name>
              <description>channel 3 counter reload flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CMP1F</name>
              <description>channel 2 compare value 1 match flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CMP0F</name>
              <description>channel 2 compare value 1 match flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2CAPF</name>
              <description>channel 2 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH2RLDF</name>
              <description>channel 2 counter reload flag</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CMP1F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CMP0F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1CAPF</name>
              <description>channel 1 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH1RLDF</name>
              <description>channel 1 counter reload flag</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CMP1F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CMP0F</name>
              <description>channel 1 compare value 1 match flag</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0CAPF</name>
              <description>channel 1 capture flag, the flag will be set at the valid capture edge per CAPMODE setting. If the capture channel is set to measure mode, the flag will be set at rising edge.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CH0RLDF</name>
              <description>channel 1 counter reload flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQEN</name>
          <description>Interrupt request enable register</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH3CMP1EN</name>
              <description>1- generate interrupt request when ch3cmp1f flag is set</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3CMP0EN</name>
              <description>1- generate interrupt request when ch3cmp0f flag is set</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3CAPEN</name>
              <description>1- generate interrupt request when ch3capf flag is set</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3RLDEN</name>
              <description>1- generate interrupt request when ch3rldf flag is set</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CMP1EN</name>
              <description>1- generate interrupt request when ch2cmp1f flag is set</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CMP0EN</name>
              <description>1- generate interrupt request when ch2cmp0f flag is set</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2CAPEN</name>
              <description>1- generate interrupt request when ch2capf flag is set</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2RLDEN</name>
              <description>1- generate interrupt request when ch2rldf flag is set</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CMP1EN</name>
              <description>1- generate interrupt request when ch1cmp1f flag is set</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CMP0EN</name>
              <description>1- generate interrupt request when ch1cmp0f flag is set</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1CAPEN</name>
              <description>1- generate interrupt request when ch1capf flag is set</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1RLDEN</name>
              <description>1- generate interrupt request when ch1rldf flag is set</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CMP1EN</name>
              <description>1- generate interrupt request when ch0cmp1f flag is set</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CMP0EN</name>
              <description>1- generate interrupt request when ch0cmp0f flag is set</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0CAPEN</name>
              <description>1- generate interrupt request when ch0capf flag is set</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0RLDEN</name>
              <description>1- generate interrupt request when ch0rldf flag is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCR</name>
          <description>Global control register</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>SWSYNCT</name>
              <description>set this bitfield to trigger software counter sync event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR1</name>
      <description>GPTMR1</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0084000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR2</name>
      <description>GPTMR2</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0088000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR3</name>
      <description>GPTMR3</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf008c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR4</name>
      <description>GPTMR4</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0090000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR5</name>
      <description>GPTMR5</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0094000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR6</name>
      <description>GPTMR6</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf0098000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>GPTMR7</name>
      <description>GPTMR7</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf009c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>NTMR0</name>
      <description>NTMR0</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf1110000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPTMR0">
      <name>PTMR</name>
      <description>PTMR</description>
      <groupName>GPTMR</groupName>
      <baseAddress>0xf4120000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MBX0A</name>
      <description>MBX0A</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <description>Command Registers</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXRESET</name>
              <description>Reset TX Fifo and word.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BARCTL</name>
              <description>Bus Access Response Control, when bit 15:14=
00: no bus error will be generated,      no wait for fifo write when fifo full and  no wait for word/fifo read when word message invalid or fifo empty; or when write to word/fifo message will be ignored.
 01: bus error will be generated when: 1, access invalid address; 2, write to ready only addr; 3, write to fulled fifo or valid message; 4, read from a emptied fifo/word message.
10: no error will be generated, but bus will wait when 1, write to fulled fifo/reg message; 2, read from a emptied fifo/reg message; write to word message will overwrite the existing reg value enven word message are still valid; read from invalid word message will read out last read out message data.happen.
11: reserved.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEIE</name>
              <description>Bus Error Interrupt Enable, will enable the interrupt for any bus  error as described in the SR bit 13 to bit 8.
1, enable the bus access error interrupt.
0, disable the bus access error interrupt.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFMAIE</name>
              <description>TX FIFO message available interrupt enable.
1, enable the TX FIFO massage available interrupt.
0, disable the TX FIFO message available interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFMEIE</name>
              <description>TX FIFO message empty interrupt enable.
1, enable the TX FIFO massage empty interrupt.
0, disable the TX FIFO message empty interrupt.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMAIE</name>
              <description>RX FIFO message available interrupt enable.
1, enable the RX FIFO massage available interrupt.
0, disable the RX FIFO message available interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMFIE</name>
              <description>RX fifo message full interrupt enable.
1, enable the RX fifo message full interrupt.
0, disable the RX fifo message full interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWMEIE</name>
              <description>TX word message empty interrupt enable.
1, enable the TX word massage empty interrupt.
0, disable the TX word message empty interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWMVIE</name>
              <description>RX word message valid interrupt enable.
1, enable the RX word massage valid interrupt.
0, disable the RX word message valid interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <description>Status Registers</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x000000E2</resetValue>
          <resetMask>0xFFFF3FFF</resetMask>
          <fields>
            <field>
              <name>RFVC</name>
              <description>RX FIFO valid message count</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFEC</name>
              <description>TX FIFO empty message word count</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERRRE</name>
              <description>bus Error for read when rx word message are still invalid, this bit is W1C bit.
1, read from word message when the word message are still invalid will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWTRF</name>
              <description>bus Error for write when tx word message are still valid, this bit is W1C bit.
1, write to word message when the word message are still valid will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRFE</name>
              <description>bus Error for read when rx fifo empty, this bit is W1C bit.
1, read from a empty rx fifo will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EWTFF</name>
              <description>bus Error for write when tx fifo full, this bit is W1C bit.
1, write to a fulled tx fifo will cause this error bit set.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EAIVA</name>
              <description>bus Error for Accessing Invalid Address; this bit is W1C bit.
1, read and write to invalid address in the bus of this block, will set this bit.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EW2RO</name>
              <description>bus Error for Write to Read Only address; this bit is W1C bit.
1, write to read only address happened in the bus of this block.
0, nothis kind of bus error; write this bit to 1 will clear this bit when this kind of error happen.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TFMA</name>
              <description>TX FIFO Message slot available, the 4x32 TX FIFO message buffer to the other core full, will not trigger any interrupt.
1, TXFIFO message buffer has slot available
0, no slot available (fifo full)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFME</name>
              <description>TX FIFO Message Empty, no any data in the message FIFO buffer from other core, will not trigger any interrupt.message from other core.
1, no any message data in TXFIFO from other core.
0, there are some data in the 4x32 TX FIFO from other core yet.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFMA</name>
              <description>RX FIFO Message Available, available data in the 4x32 TX FIFO message buffer to the other core, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, no any data in the 4x32 TXFIFO message buffer.
0, there are some data in the  the 4x32 TXFIFO message buffer already.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFMF</name>
              <description>RX FIFO Message Full, message from other core; will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, the other core had written 4x32 message in the RXFIFO.
0, no 4x32 RX FIFO message from other core yet.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TWME</name>
              <description>TX word message empty, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, means this core had write word message to TXREG.
0, means no valid word message in the TXREG yet.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RWMV</name>
              <description>RX word message valid, will trigger interrupt if the related interrupt enable bit set in the control (CR) registrer.
1, the other core had written word message in the RXREG.
0, no valid word message yet in the RXREG.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXREG</name>
          <description>Transmit word message to other core.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXREG</name>
              <description>Transmit word message to other core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXREG</name>
          <description>Receive word message from other core.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXREG</name>
              <description>Receive word message from other core.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TXFIFO0</dimIndex>
          <name>TXWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TXFIFO</name>
              <description>TXFIFO for sending message to other core, FIFO size, 4x32
can write one of the word address to push data to the FIFO;
can also use 4x32 burst write from 0x010 to push 4 words to the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>RXFIFO0</dimIndex>
          <name>RXWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RXFIFO</name>
              <description>RXFIFO for receiving message from other core, FIFO size, 4x32
can read one of the word address to pop data to the FIFO;
can also use 4x32 burst read from 0x020 to read 4 words from the FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX0B</name>
      <description>MBX0B</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX1A</name>
      <description>MBX1A</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00a8000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MBX0A">
      <name>MBX1B</name>
      <description>MBX1B</description>
      <groupName>MBX</groupName>
      <baseAddress>0xf00ac000</baseAddress>
    </peripheral>
    <peripheral>
      <name>EWDG0</name>
      <description>EWDG0</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf00b0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL0</name>
          <description>wdog ctrl register 0
Note: Parity check is required once writing to this register. The result should be zero by modular two addition of all bits</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x2FE2F03F</resetMask>
          <fields>
            <field>
              <name>CLK_SEL</name>
              <description>clock select
0bus clock
1ext clock</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_VALUE</name>
              <description>clock divider, the clock divider works as 2 ^ div_value for wdt counter</description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_EN</name>
              <description>window mode enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_LOWER</name>
              <description>Once window mode is opened, the lower counter value to refresh wdt
00: 4/8 overtime value
01: 5/8 of overtime value
10: 6/8 of overtime value
11: 7/8 of overtime value</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG_LOCK</name>
              <description>The register is locked and unlock is needed before re-config registers
Once the lock mechanism takes effect, the CTRL0, CTRL1, timeout int register, timeout rst register, needs unlock before re-config them.
The register update needs to be finished in the required period defined by UPD_OT_TIME register</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OT_SELF_CLEAR</name>
              <description>overtime reset can be self released after 32 function cycles</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_OT_REQ</name>
              <description>If refresh event has to be limited into a period after refresh unlocked.
Note: the refresh overtime counter works in bus clock domain, not in wdt function clock domain. The wdt divider doesn't take effect for refresh counter</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_UPPER</name>
              <description>The upper threshold of window value
The window period upper limit is: lower_limit + (overtime_rst_value / 16) * upper_reg_value
If this register value is zero, then no upper level limitation</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_LOCK</name>
              <description>WDT refresh has to be unlocked firstly once refresh lock is enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_UNLOCK_MEC</name>
              <description>Unlock refresh mechanism
00: the required unlock password is the same with refresh_psd_register
01: the required unlock password is a ring shift left value of refresh_psd_register
10: the required unlock password is always 16'h55AA, no matter what refresh_psd_register is
11: the required unlock password is a LSFR result of refresh_psd_register, the characteristic polynomial is X^15 + 1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DBG</name>
              <description>WTD enable or not in debug mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LP</name>
              <description>WDT enable or not in low power mode
2'b00: wdt is halted once in low power mode
2'b01: wdt will work with 1/4 normal clock freq in low power mode
2'b10: wdt will work with 1/2 normal clock freq in low power mode
2'b11: wdt will work with normal clock freq in low power mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL1</name>
          <description>wdog ctrl register 1
Note: Parity check is required once writing to this register. The result should be zero by modular two addition of all bits</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00F200FC</resetMask>
          <fields>
            <field>
              <name>REF_FAIL_RST_EN</name>
              <description>Refresh violation will trigger an reset.
These event will be taken as a refresh violation:
1) Not refresh in the window once window mode is enabled
2) Not unlock refresh firstly if unlock is required
3) Not refresh in the required time after unlock, once refresh unlock overtime is enabled.
4) Not write the required word to refresh wdt.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_FAIL_INT_EN</name>
              <description>Refresh violation will trigger an interrupt</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_REF_FAIL_RST_EN</name>
              <description>Refresh unlock fail will trigger a reset</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_REF_FAIL_INT_EN</name>
              <description>Refresh unlock fail will trigger a interrupt</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OT_RST_EN</name>
              <description>WDT overtime will generate a reset</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTL_VIO_RST_EN</name>
              <description>Ctrl update violation will trigger a reset
The violation event is to try updating the locked register before unlock them</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTL_VIO_INT_EN</name>
              <description>Ctrl update violation will trigger a interrupt</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_CTL_FAIL_RST_EN</name>
              <description>Unlock register update failure will trigger a reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNL_CTL_FAIL_INT_EN</name>
              <description>Unlock register update failure will trigger a interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_FAIL_RST_EN</name>
              <description>Parity error will trigger a reset
A parity check is required once writing to ctrl0 and ctrl1 register. The result should be zero by modular two addition of all bits</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_FAIL_INT_EN</name>
              <description>Parity error will trigger a interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OT_RST_VAL</name>
          <description>wdog timeout reset counter value</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>OT_RST_VAL</name>
              <description>WDT timeout reset value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_REFRESH_REG</name>
          <description>wdog refresh register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_REFRESH_REG</name>
              <description>Write this register by 32'h5A45_524F to refresh wdog
Note: Reading this register can read back wdt real time counter value, while it is only used by debug purpose</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_STATUS</name>
          <description>wdog status register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000006F</resetMask>
          <fields>
            <field>
              <name>PARITY_ERROR</name>
              <description>parity error
Write one to clear the bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OT_RST</name>
              <description>Timeout happens, a reset will happen once enable bit set
This bit can be cleared only by refreshing wdt or reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTL_UNL_FAIL</name>
              <description>Unlock ctrl reg update protection fail
Write one to clear the bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CTL_VIO</name>
              <description>Violate register update protection mechanism
Write one to clear the bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>REF_UNL_FAIL</name>
              <description>Refresh unlock fail
Write one to clear the bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>REF_VIO</name>
              <description>Refresh fail
Write one to clear the bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG_PROT</name>
          <description>ctrl register protection register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>UPD_OT_TIME</name>
              <description>The period in which register update has to be in after unlock
The required period is less than 128 * 2 ^ UPD_OT_TIME * bus_clock_cycle</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPD_PSD</name>
              <description>The password of unlocking register update</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_PROT</name>
          <description>refresh protection register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>REF_UNL_PSD</name>
              <description>The password to unlock refreshing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_EN</name>
          <description>Wdog enable</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>WDOG_EN</name>
              <description>Wdog is enabled, the re-written of this register is impacted by enable lock function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_TIME</name>
          <description>Refresh period value</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>REFRESH_PERIOD</name>
              <description>The refresh period after refresh unlocked
Note: the refresh overtime counter works in bus clock domain, not in wdt function clock domain. The wdt divider doesn't take effect for refresh counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="EWDG0">
      <name>EWDG1</name>
      <description>EWDG1</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf00b4000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="EWDG0">
      <name>PEWDG</name>
      <description>PEWDG</description>
      <groupName>EWDG</groupName>
      <baseAddress>0xf4128000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAMUX</name>
      <description>DMAMUX</description>
      <groupName>DMAMUX</groupName>
      <baseAddress>0xf00c4000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>64</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HDMA_MUX0,HDMA_MUX1,HDMA_MUX2,HDMA_MUX3,HDMA_MUX4,HDMA_MUX5,HDMA_MUX6,HDMA_MUX7,HDMA_MUX8,HDMA_MUX9,HDMA_MUX10,HDMA_MUX11,HDMA_MUX12,HDMA_MUX13,HDMA_MUX14,HDMA_MUX15,HDMA_MUX16,HDMA_MUX17,HDMA_MUX18,HDMA_MUX19,HDMA_MUX20,HDMA_MUX21,HDMA_MUX22,HDMA_MUX23,HDMA_MUX24,HDMA_MUX25,HDMA_MUX26,HDMA_MUX27,HDMA_MUX28,HDMA_MUX29,HDMA_MUX30,HDMA_MUX31,XDMA_MUX0,XDMA_MUX1,XDMA_MUX2,XDMA_MUX3,XDMA_MUX4,XDMA_MUX5,XDMA_MUX6,XDMA_MUX7,XDMA_MUX8,XDMA_MUX9,XDMA_MUX10,XDMA_MUX11,XDMA_MUX12,XDMA_MUX13,XDMA_MUX14,XDMA_MUX15,XDMA_MUX16,XDMA_MUX17,XDMA_MUX18,XDMA_MUX19,XDMA_MUX20,XDMA_MUX21,XDMA_MUX22,XDMA_MUX23,XDMA_MUX24,XDMA_MUX25,XDMA_MUX26,XDMA_MUX27,XDMA_MUX28,XDMA_MUX29,XDMA_MUX30,XDMA_MUX31</dimIndex>
          <name>MUXCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>DMA Mux Channel Enable
Enables the channel for DMA Mux. The DMA has separate channel enables/disables, which should be
used to disable or reconfigure a DMA channel.
0b - DMA Mux channel is disabled
1b - DMA Mux channel is enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOURCE</name>
              <description>DMA Channel Source
Specifies which DMA source, if any, is routed to a particular DMA channel. See the "DMA MUX Mapping"</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HDMA</name>
      <description>HDMA</description>
      <groupName>DMAV2</groupName>
      <baseAddress>0xf00c8000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x43c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>IDMisc</name>
          <description>ID Misc</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF00</resetMask>
          <fields>
            <field>
              <name>DMASTATE</name>
              <description>DMA state machine
localparam ST_IDLE  = 3'b000;
localparam ST_READ  = 3'b001;
localparam ST_READ_ACK = 3'b010;
localparam ST_WRITE = 3'b011;
localparam ST_WRITE_ACK = 3'b100;
localparam ST_LL  = 3'b101;
localparam ST_END  = 3'b110;
localparam ST_END_WAIT     = 3'b111;</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CURCHAN</name>
              <description>current channel in used</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMACfg</name>
          <description>DMAC Configuration Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>CHAINXFR</name>
              <description>Chain transfer
0x0: Chain transfer is not configured
0x1: Chain transfer is configured</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQSYNC</name>
              <description>DMA request synchronization.
The DMA request synchronization should be configured to avoid signal integrity problems when the request signal is not clocked by the system bus clock,
which the DMA control logic operates in. If the request synchronization is not configured, the request signal is sampled directly without synchronization.
0x0: Request synchronization is not configured
0x1: Request synchronization is configured</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAWIDTH</name>
              <description>AXI bus data width
0x0: 32 bits
0x1: 64 bits
0x2: 128 bits
0x3: 256 bits</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDRWIDTH</name>
              <description>AXI bus address width
0x18: 24 bits
0x19: 25 bits
...
0x40: 64 bits
Others: Invalid</description>
              <bitOffset>17</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CORENUM</name>
              <description>DMA core number
0x0: 1 core
0x1: 2 cores</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSNUM</name>
              <description>AXI bus interface number
0x0: 1 AXI bus
0x1: 2 AXI busses</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REQNUM</name>
              <description>Request/acknowledge pair number
0x0: 0 pair
0x1: 1 pair
0x2: 2 pairs
...
0x10: 16 pairs</description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFODEPTH</name>
              <description>FIFO depth
0x4: 4 entries
0x8: 8 entries
0x10: 16 entries
0x20: 32 entries
Others: Invalid</description>
              <bitOffset>4</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHANNELNUM</name>
              <description>Channel number
0x1: 1 channel
0x2: 2 channels
...
0x8: 8 channels
Others: Invalid</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMACtrl</name>
          <description>DMAC Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Software reset control. Write 1 to this bit to reset the DMA core and disable all channels.
Note: The software reset may cause the in-completion of AXI transaction.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ChAbort</name>
          <description>Channel Abort Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHABORT</name>
              <description>Write 1 to bit n to abort channel n. The bits should only be set when the corresponding channels are enabled.
Otherwise, the writes will be ignored for channels that are not enabled. (N: Number of channels)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTHALFSTS</name>
          <description>Harlf Complete Interrupt Status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>half transfer done irq status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTTCSTS</name>
          <description>Trans Complete Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>The terminal count status, one bit per channel. The terminal count status is set when a channel transfer finishes without the abort or error event.
0x0: Channel n has no terminal count status
0x1: Channel n has terminal count status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTABORTSTS</name>
          <description>Abort Interrupt Status Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>The abort status of channel, one bit per channel. The abort status is set when a channel transfer is aborted.
0x0: Channel n has no abort status
0x1: Channel n has abort status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTERRSTS</name>
          <description>Error Interrupt Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>The error status, one bit per channel. The error status is set when a channel transfer encounters the following error events:
- Bus error
- Unaligned address
- Unaligned transfer width
- Reserved configuration
0x0: Channel n has no error status
0x1: Channel n has error status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ChEN</name>
          <description>Channel Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>Alias of the Enable field of all ChnCtrl registers</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>32</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>ch0,ch1,ch2,ch3,ch4,ch5,ch6,ch7,ch8,ch9,ch10,ch11,ch12,ch13,ch14,ch15,ch16,ch17,ch18,ch19,ch20,ch21,ch22,ch23,ch24,ch25,ch26,ch27,ch28,ch29,ch30,ch31</dimIndex>
          <name>CHCTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>Ctrl</name>
            <description>Channel &amp;index0 Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFF01F</resetMask>
            <fields>
              <field>
                <name>INFINITELOOP</name>
                <description>set to loop current config infinitely</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HANDSHAKEOPT</name>
                <description>0: one request to transfer one burst
1: one request to transfer all the data defined in ch_tts</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIORITY</name>
                <description>Channel priority level
0x0: Lower priority
0x1: Higher priority</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BURSTOPT</name>
                <description>set to change burst_size definition</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCBURSTSIZE</name>
                <description>Source burst size. This field indicates the number of transfers before DMA channel re-arbitration.
The burst transfer byte number is (SrcBurstSize * SrcWidth).
0x0: 1 transfer
0x1: 2 transfers
0x2: 4 transfers
0x3: 8 transfers
0x4: 16 transfers
0x5: 32 transfers
0x6: 64 transfers
0x7: 128 transfers
0x8: 256 transfers
0x9:512 transfers
0xa: 1024 transfers
0xb - 0xf: Reserved, setting this field with a reserved value triggers the error exception</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCWIDTH</name>
                <description>Source transfer width
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer
0x3: Double word transfer
0x4: Quad word transfer
0x5: Eight word transfer
0x6 - 0x7: Reserved, setting this field with a reserved value triggers the error exception</description>
                <bitOffset>21</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTWIDTH</name>
                <description>Destination transfer width.
Both the total transfer byte number and the burst transfer byte number should be aligned to the destination transfer width;
otherwise the error event will be triggered.
For example, destination transfer width should be set as byte transfer if total transfer byte is not aligned to half-word.
See field SrcBurstSize above for the definition of burst transfer byte number and section 3.2.8 for the definition of the total transfer byte number.
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer
0x3: Double word transfer
0x4: Quad word transfer
0x5: Eight word transfer
0x6 - 0x7: Reserved, setting this field with a reserved value triggers the error exception</description>
                <bitOffset>18</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCMODE</name>
                <description>Source DMA handshake mode
0x0: Normal mode
0x1: Handshake mode
Normal mode is enabled and started by software set Enable bit;
Handshake mode is enabled by software set Enable bit, started by hardware dma request from DMAMUX block</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTMODE</name>
                <description>Destination DMA handshake mode
0x0: Normal mode
0x1: Handshake mode
the difference bewteen Source/Destination handshake mode is:
the dma block will response hardware request after read in Source handshake mode;
the dma block will response hardware request after write in Destination handshake mode;
NOTE: can't set SrcMode and DstMode at same time, otherwise result unknown.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCADDRCTRL</name>
                <description>Source address control
0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers the error exception</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTADDRCTRL</name>
                <description>Destination address control
0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers the error exception</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTHALFCNTMASK</name>
                <description>Channel half interrupt mask
0x0: Allow the half interrupt to be triggered
0x1: Disable the half interrupt</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTABTMASK</name>
                <description>Channel abort interrupt mask
0x0: Allow the abort interrupt to be triggered
0x1: Disable the abort interrupt</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTERRMASK</name>
                <description>Channel error interrupt mask
0x0: Allow the error interrupt to be triggered
0x1: Disable the error interrupt</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INTTCMASK</name>
                <description>Channel terminal count interrupt mask
0x0: Allow the terminal count interrupt to be triggered
0x1: Disable the terminal count interrupt</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Channel enable bit
0x0: Disable
0x1: Enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TranSize</name>
            <description>Channel &amp;index0Transfer Size Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0FFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRANSIZE</name>
                <description>Total transfer size from source. The total number of transferred bytes is (TranSize * SrcWidth). This register is cleared when the DMA transfer is done.
If a channel is enabled with zero total transfer size, the error event will be triggered and the transfer will be terminated.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SrcAddr</name>
            <description>Channel &amp;index0 Source Address Low Part Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SRCADDRL</name>
                <description>Low part of the source starting address. When the transfer completes, the value of {SrcAddrH,SrcAddrL} is updated to the ending address.
This address must be aligned to the source transfer size; otherwise, an error event will be triggered.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ChanReqCtrl</name>
            <description>Channel &amp;index0 DMA Request Control Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x1F1F0000</resetMask>
            <fields>
              <field>
                <name>SRCREQSEL</name>
                <description>Source DMA request select. Select the request/ack handshake pair that the source device is connected to.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTREQSEL</name>
                <description>Destination DMA request select. Select the request/ack handshake pair that the destination device is connected to.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DstAddr</name>
            <description>Channel &amp;index0 Destination Address Low Part Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSTADDRL</name>
                <description>Low part of the destination starting address. When the transfer completes, the value of {DstAddrH,DstAddrL} is updated to the ending address.
This address must be aligned to the destination transfer size; otherwise the error event will be triggered.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LLPointer</name>
            <description>Channel &amp;index0 Linked List Pointer Low Part Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFF8</resetMask>
            <fields>
              <field>
                <name>LLPOINTERL</name>
                <description>Low part of the pointer to the next descriptor. The pointer must be double word aligned.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>29</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="HDMA">
      <name>XDMA</name>
      <description>XDMA</description>
      <groupName>DMAV2</groupName>
      <baseAddress>0xf3008000</baseAddress>
    </peripheral>
    <peripheral>
      <name>GPIOM</name>
      <description>GPIOM</description>
      <groupName>GPIOM</groupName>
      <baseAddress>0xf00d8000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>gpioa,gpiob,gpioc,gpiod,gpioe,gpiof,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,gpiox,gpioy,gpioz</dimIndex>
          <name>ASSIGN[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>32</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>PIN00,PIN01,PIN02,PIN03,PIN04,PIN05,PIN06,PIN07,PIN08,PIN09,PIN10,PIN11,PIN12,PIN13,PIN14,PIN15,PIN16,PIN17,PIN18,PIN19,PIN20,PIN21,PIN22,PIN23,PIN24,PIN25,PIN26,PIN27,PIN28,PIN29,PIN30,PIN31</dimIndex>
            <name>PIN[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x80000303</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>lock fields in this register, lock can only be cleared by soc reset
0: fields can be changed
1: fields locked to current value, not changeable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HIDE</name>
                <description>pin value visibility to gpios,
bit0: 1, invisible to soc gpio0; 0: visible to soc gpio0
bit1: 1, invisible to cpu0 fast gpio; 0: visible to cpu0 fast gpio</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SELECT</name>
                <description>select which gpio controls chip pin,
0: soc gpio0;
2: cpu0 fastgpio</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC0</name>
      <description>ADC0</description>
      <groupName>ADC16</groupName>
      <baseAddress>0xf00e0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1464</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>12</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>trg0a,trg0b,trg0c,trg1a,trg1b,trg1c,trg2a,trg2b,trg2c,trg3a,trg3b,trg3c</dimIndex>
          <name>CONFIG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF3F3F7F</resetMask>
          <fields>
            <field>
              <name>TRIG_LEN</name>
              <description>length for current trigger, can up to 4 conversions for one trigger, from 0 to 3</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>INTEN3</name>
              <description>interrupt enable for 4th conversion</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN3</name>
              <description>channel number for 4th conversion</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN2</name>
              <description>interrupt enable for 3rd conversion</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN2</name>
              <description>channel number for 3rd conversion</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN1</name>
              <description>interrupt enable for 2nd conversion</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN1</name>
              <description>channel number for 2nd conversion</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QUEUE_EN</name>
              <description>preemption queue enable control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN0</name>
              <description>interrupt enable for 1st conversion</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN0</name>
              <description>channel number for 1st conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_dma_addr</name>
          <description>No description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>TRG_DMA_ADDR</name>
              <description>buffer start address for trigger queue, 192byte total, 16 bytes for each trigger (4 bytes for each conversion)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trg_sw_sta</name>
          <description>No description available</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>TRG_SW_STA</name>
              <description>SW trigger start bit, HW will clear it after all conversions(up to 4) finished. SW should make sure it's 0 before set it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_INDEX</name>
              <description>which trigger for the SW trigger
0 for trig0a, 1 for trig0b
3 for trig1a, 11 for trig3c</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>BUS_RESULT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>set after conversion finished if wait_dis is set, cleared after software read.
The first time read with 0 will trigger one new conversion.
If SW read other channel when one channel conversion is in progress, it will not trigger new conversion at other channel, and will get old result with valid 0, also with read_cflct interrupt status bit set.
the result may not realtime if software read once and wait  long time to read again</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT</name>
              <description>read this register will trigger one adc conversion.
If wait_dis bit is set, SW will get the latest conversion result(not current one) with valid bit is 0, SW need polling valid bit till it's set to get current result
If wait_dis bit is 0, SW can get the current conversion result with holding the bus, valid bit is always set at this mode. this is not recommended if channel sample time is too long</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>buf_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>WAIT_DIS</name>
              <description>set to disable read waiting, get result immediately but maybe not current conversion result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000F1F</resetMask>
          <fields>
            <field>
              <name>CYCLE</name>
              <description>current dma write cycle bit</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQ_LEN</name>
              <description>sequence queue length, 0 for one, 0xF for 16</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESTART_EN</name>
              <description>if set together with cont_en, HW will continue process the whole queue after trigger once.
If cont_en is 0, this bit is not used</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONT_EN</name>
              <description>if set, HW will continue process the queue till end(seq_len) after trigger once</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TRIG</name>
              <description>SW trigger, pulse signal, cleared by HW one cycle later</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SW_TRIG_EN</name>
              <description>set to enable SW trigger</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HW_TRIG_EN</name>
              <description>set to enable external HW trigger, only trigger on posedge</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_dma_addr</name>
          <description>No description available</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>TAR_ADDR</name>
              <description>dma target address, should be 4-byte aligned</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_wr_addr</name>
          <description>No description available</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>SEQ_WR_POINTER</name>
              <description>HW update this field after each dma write, it indicate the next dma write pointer.
dma write address is (tar_addr+seq_wr_pointer)*4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_dma_cfg</name>
          <description>No description available</description>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF3FFF</resetMask>
          <fields>
            <field>
              <name>STOP_POS</name>
              <description>if stop_en is set, SW is responsible to update this field to the next read point, HW should not write data to this point since it's not read out by SW yet</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RST</name>
              <description>set this bit will reset HW dma write pointer to seq_dma_addr, and set HW cycle bit to 1. dma is halted if this bit is set.
SW should clear all cycle bit in buffer to 0 before clear dma_rst</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_EN</name>
              <description>set to stop dma if reach the stop_pos</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_LEN</name>
              <description>dma buffer length, after write to (tar_addr[31:2]+buf_len)*4, the next dma address will be tar_addr[31:2]*4
0 for 4byte;
0xFFF for 16kbyte.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cfg0,cfg1,cfg2,cfg3,cfg4,cfg5,cfg6,cfg7,cfg8,cfg9,cfg10,cfg11,cfg12,cfg13,cfg14,cfg15</dimIndex>
          <name>SEQ_QUE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>SEQ_INT_EN</name>
              <description>interrupt enable for current conversion</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAN_NUM_4_0</name>
              <description>channel number for current conversion</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>seq_high_cfg</name>
          <description>No description available</description>
          <addressOffset>0x850</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>STOP_POS_HIGH</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_LEN_HIGH</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>PRD_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0xc00</addressOffset>
          <register>
            <name>prd_cfg</name>
            <description>No description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00001FFF</resetMask>
            <fields>
              <field>
                <name>PRESCALE</name>
                <description>0: 1xclock, 1: 2x, 2: 4x, 3: 8x,,15: 32768x,,31: 2Gx</description>
                <bitOffset>8</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRD</name>
                <description>conver period, with prescale.
Set to 0 means disable current channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>prd_thshd_cfg</name>
            <description>No description available</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>THSHDH</name>
                <description>threshold high, assert interrupt(if enabled) if result exceed high or low.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THSHDL</name>
                <description>threshold low</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>prd_result</name>
            <description>No description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>CHAN_RESULT</name>
                <description>adc convert result, update after each valid conversion.
it may be updated period according to config, also may be updated due to other queue convert the same channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>chn0,chn1,chn2,chn3,chn4,chn5,chn6,chn7,chn8,chn9,chn10,chn11,chn12,chn13,chn14,chn15</dimIndex>
          <name>SAMPLE_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_CLOCK_NUMBER_SHIFT</name>
              <description>shift for sample clock number</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_CLOCK_NUMBER</name>
              <description>sample clock number, base on clock_period, default one period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>conv_cfg1</name>
          <description>No description available</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>CONVERT_CLOCK_NUMBER</name>
              <description>convert clock numbers, set to 21 (0x15) for 16bit mode, which means convert need 21 adc clock cycles(based on clock after divider);
user can use small value to get faster conversion, but less accuracy, need to config cov_end_cnt at adc16_config1 also.
Ex: use 200MHz bus clock for adc, set sample_clock_number to 4, sample_clock_number_shift to 0, covert_clk_number to 21 for 16bit mode, clock_divder to 3, then each ADC conversion(plus sample) need 25 cycles(50MHz).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_DIVIDER</name>
              <description>clock_period, N half clock cycle per half adc cycle
0 for same adc_clk and bus_clk,
1 for 1:2,
2 for 1:3,
...
15 for 1:16
Note: set to 2 can genenerate 66.7MHz adc_clk at 200MHz bus_clk</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc_cfg0</name>
          <description>No description available</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xA0000001</resetMask>
          <fields>
            <field>
              <name>SEL_SYNC_AHB</name>
              <description>set to 1 will enable sync AHB bus, to get better bus performance.
Adc_clk must to be set to same as bus clock at this mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_AHB_EN</name>
              <description>set to 1 to enable ADC DMA to write data to soc memory bus, for trig queue and seq queue;</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT3_REALTIME</name>
              <description>set to enable trg queue stop other queues</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_sts</name>
          <description>No description available</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE0FFFF</resetMask>
          <fields>
            <field>
              <name>TRIG_CMPT</name>
              <description>interrupt for one trigger conversion complete if enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CFLCT</name>
              <description>read conflict interrupt, set if wait_dis is set, one conversion is in progress, SW read another channel</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_SW_CFLCT</name>
              <description>sequence queue conflict interrupt, set if HW or SW trigger received during conversion</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_DMAABT</name>
              <description>dma abort interrupt, set if seqence dma write pointer reachs sw read pointer if stop_en is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CMPT</name>
              <description>the whole sequence complete interrupt</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>one conversion complete in seq_queue if related seq_int_en is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_FIFO_FULL</name>
              <description>DMA fifo full interrupt, user need to check clock frequency if it's set.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>set if got hresp=1, generally caused by wrong trg_dma_addr or seq_dma_addr</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>set if one chanel watch dog event triggered</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>No description available</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFE0FFFF</resetMask>
          <fields>
            <field>
              <name>TRIG_CMPT</name>
              <description>interrupt for one trigger conversion complete if enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_SW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ_CFLCT</name>
              <description>read conflict interrupt, set if wait_dis is set, one conversion is in progress, SW read another channel</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_SW_CFLCT</name>
              <description>sequence queue conflict interrupt, set if HW or SW trigger received during conversion</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_HW_CFLCT</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_DMAABT</name>
              <description>dma abort interrupt, set if seqence dma write pointer reachs sw read pointer if stop_en is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CMPT</name>
              <description>the whole sequence complete interrupt</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_CVC</name>
              <description>one conversion complete in seq_queue if related seq_int_en is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_FIFO_FULL</name>
              <description>DMA fifo full interrupt, user need to check clock frequency if it's set.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>set if got hresp=1, generally caused by wrong trg_dma_addr or seq_dma_addr</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDOG</name>
              <description>set if one chanel watch dog event triggered</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_ctrl0</name>
          <description>No description available</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001004</resetMask>
          <fields>
            <field>
              <name>ADC_CLK_ON</name>
              <description>set to enable adc clock to analog, Software should set this bit before access to any adc16_* register.
MUST set clock_period to 0 or 1 for adc16 reg access</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STARTCAL</name>
              <description>set to start the offset calibration cycle (Active H). user need to clear it after setting it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ana_status</name>
          <description>No description available</description>
          <addressOffset>0x1210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000080</resetMask>
          <fields>
            <field>
              <name>CALON</name>
              <description>Indicates if the ADC is in calibration mode (Active H).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>34</dim>
          <dimIncrement>0x2</dimIncrement>
          <dimIndex>adc16_para00,adc16_para01,adc16_para02,adc16_para03,adc16_para04,adc16_para05,adc16_para06,adc16_para07,adc16_para08,adc16_para09,adc16_para10,adc16_para11,adc16_para12,adc16_para13,adc16_para14,adc16_para15,adc16_para16,adc16_para17,adc16_para18,adc16_para19,adc16_para20,adc16_para21,adc16_para22,adc16_para23,adc16_para24,adc16_para25,adc16_para26,adc16_para27,adc16_para28,adc16_para29,adc16_para30,adc16_para31,adc16_para32,adc16_para33</dimIndex>
          <name>ADC16_PARAMS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1400</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PARAM_VAL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc16_config0</name>
          <description>No description available</description>
          <addressOffset>0x1444</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01F07FFF</resetMask>
          <fields>
            <field>
              <name>REG_EN</name>
              <description>set to enable regulator</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BANDGAP_EN</name>
              <description>set to enable bandgap. user should set reg_en and bandgap_en before use adc16.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_AVG_CFG</name>
              <description>for average the calibration result.
0- 1 loop;   1- 2 loops;   2- 4 loops;   3- 8 loops;
4- 16 loops;  5-32 loops;   others reserved</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPT_EN</name>
              <description>set to enable preemption feature</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONV_PARAM</name>
              <description>conversion parameter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>adc16_config1</name>
          <description>No description available</description>
          <addressOffset>0x1460</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001F00</resetMask>
          <fields>
            <field>
              <name>COV_END_CNT</name>
              <description>used for faster conversion, user can change it to get higher convert speed(but less accuracy).
should set to (21-convert_clock_number+1).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <description>I2S0</description>
      <groupName>I2S</groupName>
      <baseAddress>0xf0200000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFTRST_RX</name>
              <description>software reset the RX module if asserted to be 1'b1. Self-clear.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFTRST_TX</name>
              <description>software reset the TX module if asserted to be 1'b1. Self-clear.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFTRST_CLKGEN</name>
              <description>software reset the CLK GEN module if asserted to be 1'b1.  Self-clear.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDNIE</name>
              <description>TX buffer data needed interrupt enable
0: TXE interrupt masked
1: TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXDAIE</name>
              <description>RX buffer data available interrupt enable
0: RXNE interrupt masked
1: RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is set.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERRIE</name>
              <description>Error interrupt enable
This bit controls the generation of an interrupt when an error condition  (UD, OV) occurs.
0: Error interrupt is masked
1: Error interrupt is enabled</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DMA_EN</name>
              <description>Asserted to use DMA, else to use interrupt</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_EN</name>
              <description>Asserted to use DMA, else to use interrupt</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXFIFOCLR</name>
              <description>Self-clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFIFOCLR</name>
              <description>Self-clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EN</name>
              <description>enable for each TX data pad</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EN</name>
              <description>enable for each RX data pad</description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>I2S_EN</name>
              <description>enable for the module</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RFIFO_FILLINGS</name>
          <description>Rx FIFO  Filling Level</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX3</name>
              <description>RX3 fifo fillings</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX2</name>
              <description>RX2 fifo fillings</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX1</name>
              <description>RX1 fifo fillings</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX0</name>
              <description>RX0 fifo fillings</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TFIFO_FILLINGS</name>
          <description>Tx FIFO  Filling Level</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX3</name>
              <description>TX3 fifo fillings</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX2</name>
              <description>TX2 fifo fillings</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX1</name>
              <description>TX1 fifo fillings</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX0</name>
              <description>TX0 fifo fillings</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_THRESH</name>
          <description>TX/RX FIFO Threshold setting.</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>TX fifo threshold to trigger STA[tx_dn]. When tx fifo filling is smaller than or equal to the threshold, assert the tx_dn flag.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX</name>
              <description>RX fifo threshold to trigger STA[rx_da].  When rx fifo filling is greater than or equal to the threshold, assert the rx_da flag.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Registers</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_UD</name>
              <description>Asserted when tx fifo is underflow. Should be ANDed with CTRL[tx_en] the for correct value. Write 1 to any of these 4 bits will clear the underflow error.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RX_OV</name>
              <description>Asserted when rx fifo is overflow. Write 1 to any of these 4 bits will clear the overflow error.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TX_DN</name>
              <description>Asserted when tx fifo data are needed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DA</name>
              <description>Asserted when rx fifo data are available.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>RXD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>TXD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <description>Configruation Regsiters</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x40000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCLK_GATEOFF</name>
              <description>Gate off the bclk. Asserted to gate-off the BCLK.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_DIV</name>
              <description>Linear prescaler to generate BCLK from MCLK.
BCLK_DIV [8:0] = 0: BCLK=No CLK.
BCLK_DIV [8:0] = 1: BCLK=MCLK/1
BCLK_DIV [8:0] = n: BCLK=MCLK/(n).
Note: These bits should be configured when the I2S is disabled. It is used only when the I2S is in master mode.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_BCLK_OUT</name>
              <description>Invert the BCLK before sending it out to pad. Only valid in BCLK master mode</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_BCLK_IN</name>
              <description>Invert the BCLK pad input before using it internally. Only valid in BCLK slave mode</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_FCLK_OUT</name>
              <description>Invert the FCLK before sending it out to pad. Only valid in FCLK master mode</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_FCLK_IN</name>
              <description>Invert the FCLK pad input before using it internally. Only valid in FCLK slave mode</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_MCLK_OUT</name>
              <description>Invert the MCLK before sending it out to pad. Only valid in MCLK master mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_MCLK_IN</name>
              <description>Invert the MCLK pad input before using it internally. Only valid in MCLK slave mode</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCLK_SEL_OP</name>
              <description>asserted to use external clk source</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FCLK_SEL_OP</name>
              <description>asserted to use external clk source</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCK_SEL_OP</name>
              <description>asserted to use external clk source</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_EDGE</name>
              <description>The start edge of a frame
0: Falling edge indicates a new frame (Just like standard I2S Philips standard)
1: Rising edge indicates a new frame</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_MAX</name>
              <description>CH_MAX[4:0] s the number of channels supported in TDM mode. When not in TDM mode, it must be set as 2.
It must be an even number, so CH_MAX[0] is always 0.
5'h2: 2 channels
5'h4: 4 channels
...
5h10: 16 channels (max)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDM_EN</name>
              <description>TDM mode
0: not TDM mode
1: TDM mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STD</name>
              <description>I2S standard selection
00: I2S Philips standard.
01: MSB justified standard (left justified)
10: LSB justified standard (right justified)
11: PCM standard
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATSIZ</name>
              <description>Data length to be transferred
00: 16-bit data length
01: 24-bit data length
10: 32-bit data length
11: Not allowed
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSIZ</name>
              <description>Channel length (number of bits per audio channel)
0: 16-bit wide
1: 32-bit wide
The bit write operation has a meaning only if DATSIZ = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.
Note: For correct operation, this bit should be configured when the I2S is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CFGR</name>
          <description>Misc configuration Registers</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00042000</resetValue>
          <resetMask>0xFFFFEC01</resetMask>
          <fields>
            <field>
              <name>MCLK_GATEOFF</name>
              <description>Gate off the mclk. This mclk is the output of a glitch prone mux, so every time to switch the mclk, the gate off clock should be asserted at first. After the clock is switched, de-assert this bit to ungate off the mclk.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKOE</name>
              <description>Master clock output to pad enable
0: Master clock output is disabled
1: Master clock output is enabled
Note: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>RXDSLOT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3</dimIndex>
          <name>TXDSLOT[%s]</name>
          <description>no description available</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S1</name>
      <description>I2S1</description>
      <groupName>I2S</groupName>
      <baseAddress>0xf0204000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S2</name>
      <description>I2S2</description>
      <groupName>I2S</groupName>
      <baseAddress>0xf0208000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S3</name>
      <description>I2S3</description>
      <groupName>I2S</groupName>
      <baseAddress>0xf020c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DAO</name>
      <description>DAO</description>
      <groupName>DAO</groupName>
      <baseAddress>0xf0210000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000200FF</resetMask>
          <fields>
            <field>
              <name>HPF_EN</name>
              <description>Whether HPF is enabled. This HPF is used to filter out the DC part.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MONO</name>
              <description>Asserted to let the left and right channel output the same value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>Asserted to enable the right channel</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>Asserted to enable the left channel</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REMAP</name>
              <description>1: Use remap pwm version. The remap version is a version that one pwm output is tied to zero when the input pcm signal is positive or negative
0: Don't use remap pwm version</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INVERT</name>
              <description>all the outputs are inverted before sending to pad</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FALSE_LEVEL</name>
              <description>the pad output in False run mode, or when the module is disabled
0: all low
1: all high
2: P-high, N-low
3. output is not enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FALSE_RUN</name>
              <description>the module continues to consume data, but all the pads are constant, thus no audio out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>Self-clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RUN</name>
              <description>Enable this module to run.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CFGR</name>
          <description>Configuration Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>FRAME_EDGE</name>
              <description>The start edge of a frame
0: Falling edge indicates a new frame (Just like standard I2S Philips standard)
1: Rising edge indicates a new frame</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_MAX</name>
              <description>CH_MAX[3:0] is the number if channels supported in TDM mode. When not in TDM mode, it must be set as 2.
It must be an even number, so CH_MAX[0] is always 0.
4'h2: 2 channels
4'h4: 4 channels
etc</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDM_EN</name>
              <description>TDM mode
0: not TDM mode
1: TDM mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STD</name>
              <description>I2S standard selection
00: I2S Philips standard.
01: MSB justified standard (left justified)
10: LSB justified standard (right justified)
11: PCM standard
For more details on I2S standards.
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATSIZ</name>
              <description>Data length to be transferred
00: 16-bit data length
01: 24-bit data length
10: 32-bit data length
11: Not allowed
Note: For correct operation, these bits should be configured when the I2S is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHSIZ</name>
              <description>Channel length (number of bits per audio channel)
0: 16-bit wide
1: 32-bit wide
The bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.
Note: For correct operation, this bit should be configured when the I2S is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXSLT</name>
          <description>RX Slot Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Slot enable for the channels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_MA</name>
          <description>HPF A Coef Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>Composite value of  coef A of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_B</name>
          <description>HPF B Coef Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>coef B of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM</name>
      <description>PDM</description>
      <groupName>PDM</groupName>
      <baseAddress>0xf0214000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x809FF7FF</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset the module. Self-clear.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOF_FEDGE</name>
              <description>asserted if the falling edge of the ref fclk from DAO is the start of a new frame. This is used to to align DAO feedback signal.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USE_COEF_RAM</name>
              <description>Asserted to use Coef RAM instead of Coef ROM</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FILT_CRX_ERR_IE</name>
              <description>data accessed out of boundary error interruput enable. The error happens when the module cannot calculate the enough number of data in time.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OFIFO_OVFL_ERR_IE</name>
              <description>output fifo overflow error interrupt enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_OVLD_ERR_IE</name>
              <description>CIC overload error interrupt enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_SAT_ERR_IE</name>
              <description>Error interrupt enable
This bit controls the generation of an interrupt when an error condition  (CIC saturation) occurs.
0: Error interrupt is masked
1: Error interrupt is enabled</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEC_AFT_CIC</name>
              <description>decimation rate after CIC. Now it is forced to be 3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPT_DLY</name>
              <description>Capture cycle delay&gt;=0, should be less than PDM_CLK_HFDIV</description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_HFDIV</name>
              <description>The clock divider will work at least 4.
0: div-by-2,
1: div-by-4
. . .
n: div-by-2*(n+1)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_DIV_BYPASS</name>
              <description>asserted to bypass the pdm clock divider</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_OE</name>
              <description>pdm_clk_output_en</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPF_EN</name>
              <description>pdm high pass filter enable. This order-1 HPF only applies to the PDM mic data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CH_CTRL</name>
          <description>Channel Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF03FF</resetMask>
          <fields>
            <field>
              <name>CH_POL</name>
              <description>Asserted to select PDM_CLK high level captured, otherwise to select PDM_CLK low level captured.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_EN</name>
              <description>Asserted to enable the channel.
Ch8 &amp; 9 are refs.
Ch0-7 are pdm mics.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ST</name>
          <description>Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>FILT_CRX_ERR</name>
              <description>data accessed out of boundary error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OFIFO_OVFL_ERR</name>
              <description>output fifo overflow error. The reason may be sampling frequency mismatch, either fast or slow.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CIC_OVLD_ERR</name>
              <description>CIC overload error. write 1 clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CIC_SAT_ERR</name>
              <description>CIC saturation. Write 1 clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CH_CFG</name>
          <description>Channel Configuration Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>CH9_TYPE</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH8_TYPE</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH7_TYPE</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH6_TYPE</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH5_TYPE</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4_TYPE</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3_TYPE</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2_TYPE</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_TYPE</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_TYPE</name>
              <description>Type of Channel 0
2'b00: dec-by-3 wiith filter type0 (CIC Compenstation+norm filter)
2'b01: dec-by-3 with filter type 1 (No CIC compenstation, only norm filter)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CFG</name>
          <description>CIC configuration register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>POST_SCALE</name>
              <description>the shift value after CIC results.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SGD</name>
              <description>Sigma_delta_order[1:0]
2'b00: 7
2'b01: 6
2'b10: 5
Others: unused</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_DEC_RATIO</name>
              <description>CIC decimation factor</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_INBUF</name>
          <description>In Buf Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_PTR</name>
              <description>The buf size-1 for each channel</description>
              <bitOffset>22</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PITCH</name>
              <description>The spacing between starting address of adjacent channels</description>
              <bitOffset>11</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START_ADDR</name>
              <description>The starting address of channel 0 in filter data buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_FILT0</name>
          <description>Filter 0 Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COEF_LEN_M0</name>
              <description>Coef length of filter type 2'b00 in coef memory</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_START_ADDR</name>
              <description>Starting address of Coef of filter type 2'b00 in coef memory</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_FILT1</name>
          <description>Filter 1 Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>COEF_LEN_M1</name>
              <description>Coef length of filter type 2'b01 in coef memory</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_START_ADDR</name>
              <description>Starting address of Coef of filter type 2'b01 in coef memory</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RUN</name>
          <description>Run Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>PDM_EN</name>
              <description>Asserted to enable the module</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMAddr</name>
          <description>Memory Access Address</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>0--0x0FFFFFFF: COEF_RAM
0x10000000--0x1FFFFFFF: DATA_RAM</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MEMData</name>
          <description>Memory Access Data</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>The data write-to/read-from buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_MA</name>
          <description>HPF A Coef Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>Composite value of  coef A of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPF_B</name>
          <description>HPF B Coef Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COEF</name>
              <description>coef B of the Order-1 HPF</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMIX</name>
      <description>SMIX</description>
      <groupName>SMIX</groupName>
      <baseAddress>0xf0218000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xac0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMAC_ID</name>
          <description>DMAC_ID Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0007FFFF</resetMask>
          <fields>
            <field>
              <name>REV</name>
              <description>Revision</description>
              <bitOffset>0</bitOffset>
              <bitWidth>19</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_TC_ST</name>
          <description>Transfer Complete Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>The terminal count status is set when a channel transfer finishes without abort or error events</description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_ABRT_ST</name>
          <description>Transfer Abort Status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>The abort status is set when a channel transfer is aborted</description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_ERR_ST</name>
          <description>Transfer Error Status</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>The error status is set when a channel transfer encounters the following error events:
. Bus error
. Unaligned address
. Unaligned transfer width
. Reserved configuration</description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRST</name>
              <description>Software Reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_ABRT_CMD</name>
          <description>Abort Command Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write 1 to force the corresponding channel into abort status</description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CHEN</name>
          <description>Channel Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write 1 to enable the corresponding channel</description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>26</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25</dimIndex>
          <name>DMA_CH[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <register>
            <name>CTL</name>
            <description>Channel N Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFEFFFEF</resetMask>
            <fields>
              <field>
                <name>SRCREQSEL</name>
                <description>Source DMA request select. Select the request/ack handshake pair that the source device is connected to.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTREQSEL</name>
                <description>Destination DMA request select. Select the request/ack handshake pair that the destination device is connected to.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIORITY</name>
                <description>0x0: Lower priority
0x1: Higher priority</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCBURSTSIZE</name>
                <description>0x0: 1 beat per transfer
0x1: 2 beats per transfer
0x2: 4 beats per transfer
0x3: 8 beats per transfer
0x4: 16 beats per transfer
0x5: 32 beats per transfer
0x6: 64 beats per transfer
0x7: 128 beats per transfer</description>
                <bitOffset>15</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCWIDTH</name>
                <description>Source Transfer Beat Size:
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer</description>
                <bitOffset>13</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTWIDTH</name>
                <description>Destination Transfer Beat Size:
0x0: Byte transfer
0x1: Half-word transfer
0x2: Word transfer</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCMODE</name>
                <description>DMA Source handshake mode
0x0: Normal mode
0x1: Handshake mode</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTMODE</name>
                <description>DMA Destination handshake mode
0x0: Normal mode
0x1: Handshake mode</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SRCADDRCTRL</name>
                <description>0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers an error exception</description>
                <bitOffset>7</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTADDRCTRL</name>
                <description>0x0: Increment address
0x1: Decrement address
0x2: Fixed address
0x3: Reserved, setting the field with this value triggers an error exception</description>
                <bitOffset>5</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ABRT_INT_EN</name>
                <description>Abort interrupt enable</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Err interrupt enable</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TC_INT_EN</name>
                <description>TC interrupt enable</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>channel enable bit</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BURST_COUNT</name>
            <description>Channel N Source Total Beats Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NUM</name>
                <description>the total number of source beats</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SrcAddr</name>
            <description>Channel N Source Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>source address</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DstAddr</name>
            <description>Channel N Destination Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>destination address</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LLP</name>
            <description>Channel N Linked List Pointer Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>the address pointer for the linked list descriptor</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CALSAT_ST</name>
          <description>SMIX Cal Saturation Status Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>DST CAL_SAT_ERR. W1C</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SRC</name>
              <description>SRC CAL_SAT_ERR. W1C</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FDOT_DONE_ST</name>
          <description>SMIX Fade-Out Done Status Register</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>DST fadeout done. W1C</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SRC</name>
              <description>SRC fadeout done. W1C</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA_ST</name>
          <description>SMIX Data Status Register</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DST_DA</name>
              <description>DST data available</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DST_UNDL</name>
              <description>DST data underflow</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SRC_DN</name>
              <description>SRC data needed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>DST_CH[%s]</name>
          <description>no description available</description>
          <addressOffset>0x840</addressOffset>
          <register>
            <name>CTRL</name>
            <description>SMIX Dstination N Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA_UNFL_IE</name>
                <description>Data Underflow Error IntEn</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THRSH</name>
                <description>FIFO threshold for DMA or Int. &gt;= will generate req.  Must be greater or equal than 8. The read burst of DMA should make the fillings in the buffer be greater than 4.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CALSAT_INT_EN</name>
                <description>Cal Saturation IntEn</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DA_INT_EN</name>
                <description>Data Available IntEn</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ADEACTFADEOUT_EN</name>
                <description>AutoDeactAfterFadeOut_En:
Asserted to enter de-activated mode after fade-out done</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FADEOUT_DONE_IE</name>
                <description>Fade-Out interrupt enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_DEACT</name>
                <description>de-activate the destination channel</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_ACT</name>
                <description>activate the destination channel</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTFADOUT_MEN</name>
                <description>Manual FadeOut_Ctrl for destionation. Auto clear.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTFADOUT_AEN</name>
                <description>Automatically FadeOut_Ctrl for destionation. Only effective after DST_AFADEOUT is assigned a non-zero value</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSTFADIN_EN</name>
                <description>FadeIn_Ctrl for destionation. Auto clear.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_EN</name>
                <description>Dst enabled. When disabled, clear the FIFO pointers.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFTRST</name>
                <description>Soft reset</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MIXER_EN</name>
                <description>mixer function enable.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GAIN</name>
            <description>SMIX Dstination N Gain Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Unsigned Int, with 12 fractional bits. . The top 3 bits are for shift. Same as SHFT_CTR[2:0]</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUFSIZE</name>
            <description>SMIX Dstination N Max Index Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MAX_IDX</name>
                <description>The total length of the dst stream -1. If zero, means there is no  end of the stream.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FADEIN</name>
            <description>SMIX Dstination N Fade-In Configuration Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DELTA</name>
                <description>Fade-in delta for linear fading in from 0 to 1 (about at most 20s for 48kHz sampled sound)
(Using only top 14 bits for mul)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FADEOUT</name>
            <description>SMIX Dstination N Fade-Out Configuration Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DELTA</name>
                <description>Fade out in 2^DELTA samples. Now DELTA can be at most 14</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ST</name>
            <description>SMIX Dstination N Status Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FIFO_FILLINGS</name>
                <description>destination channel output FIFO fillings</description>
                <bitOffset>6</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FDOUT_DONE</name>
                <description>Fade-Out Done. W1C</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>CALSAT</name>
                <description>Saturate Error Found. W1C</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DA</name>
                <description>Data Available</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MODE</name>
                <description>The modes are:
Mode 0: Disabled: after reset. Program the registers, and DSTn_CTRL [DST_EN] to enter Mode 1.
Mode 1: Enabled and not-activated. wait for DSTn_CTRL [DSTFADIN_EN] or DSTn_CTRL [DST_ACT], jump to Mode 3 or Mode 4 based on whether Fade-in enabled.
Mode 3: Enabled and activated and fade-in in progress: Can not be fade out. Will send data to DMA. Jump to Mode 4 after fadin op done.
Mode 4: Enabled and activated and done fade-in, no fade-out yet: Can be fade out. Will send data to DMA.
Mode 5: Enabled and activated and fade-out in progress: After faded out OP. Will send data to DMA. Will transfer to mode 6 or mode 7 depending on the DSTn_CTRL [ADeactFadeOut_En] cfg
Mode 6: Enabled and activated and faded-out: faded out is done. Will send data to DMA. Will transfer to mode 7 if manual deactivated.
Mode 7: Enabled and De-activated: If configured to enter this mode, after auto or manuallly fade-out, or after manual de-activated. Won't send data to DMA. Won't gen data avail signals. Intf register can be programmed. Will change to Mode 3 or Mode 4  after manual ACT or Fade-in CMD. Will transfer to Mode 0 if DSTn_CTRL [DST_EN] is assigned 0. To support a new stream or, to continue the old stream after a pause.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>Data</name>
            <description>SMIX Dstination N Data Out Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Output data buffer</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOURCE_EN</name>
            <description>SMIX Dstination N Source Enable Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>After enabled, Data needed req will be asserted. DMA can feed in data. The channel will join in the sum operation of mixer operation.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOURCE_ACT</name>
            <description>SMIX Dstination N Source Activation Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Manually Activate the channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOURCE_DEACT</name>
            <description>SMIX Dstination N Source De-Activation Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Manually DeActivate the channel</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOURCE_FADEIN_CTRL</name>
            <description>SMIX Dstination N Source Fade-in Control Register</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>AOP</name>
                <description>Asserted to start fade-in operation. When the amplification factors are stable, auto clear.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DEACT_ST</name>
            <description>SMIX Dstination N Source Deactivation Status Register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DST_DEACT</name>
                <description>Asserted when in de-active mode</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_DEACT_ST</name>
                <description>Asserted when in de-active mode</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOURCE_MFADEOUT_CTRL</name>
            <description>SMIX Dstination N Source Manual Fade-out Control Register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OP</name>
                <description>Asserted to start fade-out operation. When the amplification factors are stable, auto clear.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>14</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13</dimIndex>
          <name>SOURCE_CH[%s]</name>
          <description>no description available</description>
          <addressOffset>0x900</addressOffset>
          <register>
            <name>CTRL</name>
            <description>SMIX Source N Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFC7</resetMask>
            <fields>
              <field>
                <name>FIFO_RESET</name>
                <description>Asserted to reset FIFO pointer. Cleared to exit reset state.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>THRSH</name>
                <description>FIFO threshold for DMA or Int. &lt;= will generate req. Must be greater or equal than 8. This threshold is also used to trgger the internal FIR operation. To avoid the reading and writing to the same address in the memory block, the threshold should greater than 4.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CALSAT_INT_EN</name>
                <description>Cal Saturation IntEn</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DN_INT_EN</name>
                <description>Data Needed IntEn</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SHFT_CTRL</name>
                <description>Shift operation after FIR
0: no shift (when no upsampling or up-sampling-by-2 or up-sampling-by-3)
1: left-shift-by-1 (when up-sampling-by-4 or up-sampling-by-6)
2: left-shift-by-1 (when up-sampling-by-8 or up-sampling-by-12)
7: /2  (when rate /2)
Other n: shift-left-by-n, but not suggested to be used.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTODEACTAFTERFADEOUT_EN</name>
                <description>Asserted to enter de-activated mode after fade-out done</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FADEOUT_DONE_IE</name>
                <description>Fade-Out interrupt enable</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RATECONV</name>
                <description>0: no rate conversion
1: up-conversion x2
2: up-conversion x3
3: up-conversion x4
4: up-conversion x6
5: up-conversion x8
6: up-conversion x12
7: down-conversion /2</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GAIN</name>
            <description>SMIX Source N Gain Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Unsigned Int, with 12 fractional bits. The top 3 bits are for shift. Same as SHFT_CTR[2:0].</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FADEIN</name>
            <description>SMIX Source N Fade-in Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DELTA</name>
                <description>Fade -in confg.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FADEOUT</name>
            <description>SMIX Source N Fade-out Control Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DELTA</name>
                <description>Fade out in 2^DELTA samples. Now DELTA can be at most 14</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BufSize</name>
            <description>SMIX Source N Buffer Size Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MAXIDX</name>
                <description>unit as 16-bits per sample. Zero means no length limit. = Act Len-1.
The actual length is the up_rate*(input_data_length-4).
If the filter processing is down-sampling, the value of up_rate above is 1.
If the filter processing is up-sampling, the value of up_rate above is the up-sampling rate.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ST</name>
            <description>SMIX Source N Status Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0007FFFF</resetMask>
            <fields>
              <field>
                <name>FIFO_FILLINGS</name>
                <description>The fillings of input FIFO.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FDOUT_DONE</name>
                <description>Fade-Out Done. W1C</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>CALSAT</name>
                <description>Calculation saturation status. W1C</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>DN</name>
                <description>Data needed flag</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>FIRPHASE</name>
                <description>the poly phase counter</description>
                <bitOffset>3</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MODE</name>
                <description>The modes are:
Mode 0: Disabled: after reset. Program the registers, and DSTx_SRC_EN[n] to enter Mode 1.
Mode 1: Enabled but not activated: After Enabled. Data needed signal can send out, can receive DMA data. Will enter Mode 2 after manual ACT or Fade-in CMD
Mode 2: Enabled and activated and buffer feed-in in progress: Can not be fade out. Will consume data from DMA. If not enter due to Fade-in CMD, will enter Mode 4, else enter Mode 3. This mode is used to make the channel in MIX only after initial data are ready, thus will not stall mix operation due to the lackness of data of this channel omly.
Mode 3: Enabled and activated and fade-in in progress: Can not be fade out. Will consume data from DMA.
Mode 4: Enabled and activated and done fade-in, no fade-out yet: Can be fade out. Will consume data from DMA.
Mode 5: Enabled and activated and fade-out in progress: After faded out done. Will consume data from DMA. Will transfer to mode 6 or mode 7 depending on the SRCn_CTRL[AutoDeactAfterFadeOut_En] cfg
Mode 6: Enabled and activated and faded-out: faded out is done. Will consume data from DMA. Will transfer to mode 7 if manual deactivated.
Mode 7: Enabled and De-activated: If configured to enter this mode, after auto or manuallly fade-out, or after manual de-activated. Won't consume data from DMA. Won't gen data needed signals. Intf register can be programmed. Will change to Mode 2 after manual ACT or Fade-in CMD. Will transfer to Mode 0 if DSTx_SRC_EN[n] is assigned 0. To support a new stream or, to continue the old stream after a pause.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>Data</name>
            <description>SMIX Source N Data Input Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VAL</name>
                <description>Data input register</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>MCAN0</name>
      <description>MCAN0</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0280000</baseAddress>
      <addressBlock>
        <offset>0x4</offset>
        <size>0x29fc</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ENDN</name>
          <description>endian register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x87654321</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EVT</name>
              <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBTP</name>
          <description>data bit timing and prescaler, writeable when CCCR.CCE and CCCR.INT are set</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000A33</resetValue>
          <resetMask>0x009F1FFF</resetMask>
          <fields>
            <field>
              <name>TDC</name>
              <description>transmitter delay compensation enable
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBRP</name>
              <description>Data Bit Rate Prescaler
The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 31.
When TDC = 1, the range is limited to 0,1. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTSEG1</name>
              <description>Data time segment before sample point
Valid values are 0 to 31. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTSEG2</name>
              <description>Data time segment after sample point
Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSJW</name>
              <description>Data (Re)Synchronization Jump Width
Valid values are 0 to 15. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST</name>
          <description>test register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F3FF0</resetMask>
          <fields>
            <field>
              <name>SVAL</name>
              <description>Started Valid
0= Value of TXBNS not valid
1= Value of TXBNS valid</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBNS</name>
              <description>Tx Buffer Number Started
Tx Buffer number of message whose transmission was started last. Valid when SVAL is set. Valid values are 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PVAL</name>
              <description>Prepared Valid
0= Value of TXBNP not valid
1= Value of TXBNP valid</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TXBNP</name>
              <description>Tx Buffer Number Prepared
Tx Buffer number of message that is ready for transmission. Valid when PVAL is set.Valid values are 0 to 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receive Pin
Monitors the actual value of pin m_can_rx
0= The CAN bus is dominant (m_can_rx = 0)
1= The CAN bus is recessive (m_can_rx = 1)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Control of Transmit Pin
00 Reset value, m_can_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_can_tx
10 Dominant (0) level at pin m_can_tx
11 Recessive (1) at pin m_can_tx</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LBCK</name>
              <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RWD</name>
          <description>ram watchdog</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>WDV</name>
              <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDC</name>
              <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of 00 the counter is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCCR</name>
          <description>CC control register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>NISO</name>
              <description>Non ISO Operation
If this bit is set, the M_CAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0
Note: When the generic parameter iso_only_g is set to 1 in hardware synthesis, this bit becomes reserved and is read as 0. The M_CAN always operates with the CAN FD frame format according to ISO 11898-1:2015.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXP</name>
              <description>Transmit Pause
If this bit is set, the M_CAN pauses for two CAN bit times before starting the next transmission after
itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFBI</name>
              <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PXHD</name>
              <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled
Note: When protocol exception handling is disabled, the M_CAN will transmit an error frame when it detects a protocol exception condition.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WMM</name>
              <description>Wide Message Marker
Enables the use of 16-bit Wide Message Markers. When 16-bit Wide Message Markers are used (WMM = 1), 16-bit internal timestamping is disabled for the Tx Event FIFO.
0= 8-bit Message Marker used
1= 16-bit Message Marker used, replacing 16-bit timestamps in Tx Event FIFO</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTSU</name>
              <description>Use Timestamping Unit
When UTSU is set, 16-bit Wide Message Markers are also enabled regardless of the value of WMM.
0= Internal time stamping
1= External time stamping by TSU
Note: When generic parameter connected_tsu_g = 0, there is no TSU connected to the M_CAN.
In this case bit UTSU is fixed to zero by synthesis.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRSE</name>
              <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled
Note: When CAN FD operation is disabled FDOE = 0, BRSE is not evaluated.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FDOE</name>
              <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST</name>
              <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAR</name>
              <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MON</name>
              <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to 1. The bit can be reset by the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR</name>
              <description>Clock Stop Request
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after all pending transfer requests have been completed and the CAN bus reached idle.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSA</name>
              <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_CAN may be set in power down by stopping m_can_hclk and m_can_cclk</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ASM</name>
              <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to 1. The bit can be reset by the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CCE</name>
              <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = 1)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Initialization
0= Normal Operation
1= Initialization is started</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NBTP</name>
          <description>nominal bit timing and prescaler register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x06000A03</resetValue>
          <resetMask>0xFFFFFF7F</resetMask>
          <fields>
            <field>
              <name>NSJW</name>
              <description>Nominal (Re)Synchronization Jump Width
Valid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NBRP</name>
              <description>Nominal Bit Rate Prescaler
The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTSEG1</name>
              <description>Nominal Time segment before sample point
Valid values are 1 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NTSEG2</name>
              <description>Nominal Time segment after sample point
Valid values are 1 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCC</name>
          <description>timestamp counter configuration</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F0003</resetMask>
          <fields>
            <field>
              <name>TCP</name>
              <description>Timestamp Counter Prescaler
Configures the timestamp and timeout counters time unit in multiples of CAN bit times [116]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSS</name>
              <description>timestamp Select
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as 00</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCV</name>
          <description>timestamp counter value</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TSC</name>
              <description>Timestamp Counter
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).When TSCC.TSS = 01, the Timestamp Counter is incremented in multiples of CAN bit times [116] depending on the configuration of TSCC.TCP.
A wrap around sets interrupt flag IR.TSW. Write access resets the counter to zero. When TSCC.TSS = 10, TSC reflects the external Timestamp Counter value. A write access has no impact.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOCC</name>
          <description>timeout counter configuration</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0xFFFF0000</resetValue>
          <resetMask>0xFFFF0007</resetMask>
          <fields>
            <field>
              <name>TOP</name>
              <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOS</name>
              <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC.TOP and continues down-counting.
When the Timeout Counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RP</name>
              <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOCV</name>
          <description>timeout counter value</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [116] depending on the configuration of TSCC.TCP.
When decremented to zero, interrupt flag IR.TOO is set and the Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.
Note: Byte access: when TOCC.TOS = 00writing one of the register bytes 3/2/1/0 will preset the Timeout Counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECR</name>
          <description>error counter register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>CEL</name>
              <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the 8-bit Transmit Error Counter TEC or the 7-bit Receive Error Counter REC to be incremented.
The counter is also incremented when the Bus_Off limit is reached. It is not incremented when only RP is set without changing REC. The increment of CEL follows after the increment of REC or TEC.
The counter is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.
Note: Byte access: Reading byte 2 will reset CEL to zero, reading bytes 3/1/0 has no impact.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RP</name>
              <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REC</name>
              <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TEC</name>
              <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255
Note: When CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSR</name>
          <description>protocol status register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000707</resetValue>
          <resetMask>0x007F7FFF</resetMask>
          <fields>
            <field>
              <name>TDCV</name>
              <description>Transmitter Delay Compensation Value
Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO.
The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PXE</name>
              <description>Protocol Exception Event
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred
Note: Byte access: Reading byte 0 will reset PXE, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RFDF</name>
              <description>Received a CAN FD Message
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received
Note: Byte access: Reading byte 0 will reset RFDF, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RBRS</name>
              <description>BRS flag of last received CAN FD Message
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set
Note: Byte access: Reading byte 0 will reset RBRS, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESI</name>
              <description>ESI flag of last received CAN FD Message
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set
Note: Byte access: Reading byte 0 will reset RESI, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DLEC</name>
              <description>Data Phase Last Error Code
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set.Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with
its BRS flag set has been transferred (reception or transmission) without error.
Note: Byte access: Reading byte 0 will set DLEC to 111, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BO</name>
              <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EW</name>
              <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EP</name>
              <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACT</name>
              <description>Activity
Monitors the modules CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter
Note: ACT is set to 00 by a Protocol Exception Event.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEC</name>
              <description>Last Error Code
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to 0when a message has been transferred (reception or transmission) without error.
0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_CAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value 1), but the monitored bus
value was dominant.
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (data or identifier bit logical value0), but the monitored bus value was recessive.
 During Bus_Off recovery this status is set each time a sequence of 11 recessive bits has been monitored. This enables the CPU to monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to 7. When the LEC shows the value 7, no CAN bus event was detected since the last CPU read access to the Protocol Status Register.
Note: When a frame in CAN FD format has reached the data phase with BRS flag set, the next CAN event (error or valid frame) will be shown in DLEC instead of LEC. An error in a fixed stuff bit of a CAN FD CRC sequence will be shown as a Form Error, not Stuff Error.
Note: The Bus_Off recovery sequence (see ISO 11898-1:2015) cannot be shortened by setting or resetting CCCR.INIT. If the device goes Bus_Off, it will set CCCR.INIT of its own accord,stopping all bus activities.
 Once CCCR.INIT has been cleared by the CPU, the device will then wait for 129 occurrences of Bus Idle (129 * 11 consecutive recessive bits) before resuming normal operation.
At the end of the Bus_Off recovery sequence, the Error Management Counters will be reset. During the waiting time after the resetting of CCCR.INIT, each time a sequence of 11 recessive bits has been monitored, a Bit0Error code is written to PSR.LEC,
enabling the CPU to readily check up whether the CAN bus is stuck at dominant or continuously disturbed and to monitor the Bus_Off recovery sequence. ECR.REC is used to count these sequences.
Note: Byte access: Reading byte 0 will set LEC to 111, reading bytes 3/2/1 has no impact.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TDCR</name>
          <description>transmitter delay compensation</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>TDCO</name>
              <description>Transmitter Delay Compensation SSP Offset
Offset value defining the distance between the measured delay from m_can_tx to m_can_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDCF</name>
              <description>Transmitter Delay Compensation Filter Window Length
Defines the minimum value for the SSP position, dominant edges on m_can_rx that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than TDCO. Valid values are 0 to 127 mtq.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IR</name>
          <description>interrupt register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARA</name>
              <description>Access to Reserved Address
0= No access to reserved address occurred
1= Access to reserved address occurred</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PED</name>
              <description>Protocol Error in Data Phase (Data Bit Time is used)
0= No protocol error in data phase
1= Protocol error in data phase detected (PSR.DLEC  0,7)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEA</name>
              <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)
0= No protocol error in arbitration phase
1= Protocol error in arbitration phase detected (PSR.LEC  0,7)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDI</name>
              <description>Watchdog Interrupt
0= No Message RAM Watchdog event occurred
1= Message RAM Watchdog event due to missing READY</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BO</name>
              <description>Bus_Off Status
0= Bus_Off status unchanged
1= Bus_Off status changed</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EW</name>
              <description>Warning Status
0= Error_Warning status unchanged
1= Error_Warning status changed</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EP</name>
              <description>Error Passive
0= Error_Passive status unchanged
1= Error_Passive status changed</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELO</name>
              <description>Error Logging Overflow
0= CAN Error Logging Counter did not overflow
1= Overflow of CAN Error Logging Counter occurred</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEU</name>
              <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. Controlled by input signal m_can_aeim_berr[1] generated by an optional external parity / ECC logic attached to the Message RAM.
An uncorrected Message RAM bit error sets CCCR.INIT to 1. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected (e.g. parity logic)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEC</name>
              <description>Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_can_aeim_berr[0] generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRX</name>
              <description>Message stored to Dedicated Rx Buffer
The flag is set whenever a received message has been stored into a dedicated Rx Buffer.
0= No Rx Buffer updated
1= At least one received message stored into an Rx Buffer</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOO</name>
              <description>Timeout Occurred
0= No timeout
1= Timeout reached</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAF</name>
              <description>Message RAM Access Failure
The flag is set, when the Rx Handler
.has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message
storage is aborted and the Rx Handler starts processing of the following message.
.was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_CAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSW</name>
              <description>Timestamp Wraparound
0= No timestamp counter wrap-around
1= Timestamp counter wrapped around</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFL</name>
              <description>Tx Event FIFO Element Lost
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFF</name>
              <description>Tx Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFW</name>
              <description>Tx Event FIFO Watermark Reached
0= Tx Event FIFO fill level below watermark
1= Tx Event FIFO fill level reached watermark</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFN</name>
              <description>Tx Event FIFO New Entry
0= Tx Event FIFO unchanged
1= Tx Handler wrote Tx Event FIFO element</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Tx FIFO Empty
0= Tx FIFO non-empty
1= Tx FIFO empty</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCF</name>
              <description>Transmission Cancellation Finished
0= No transmission cancellation finished
1= Transmission cancellation finished</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TC</name>
              <description>Transmission Completed
0= No transmission completed
1= Transmission completed</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPM</name>
              <description>High Priority Message
0= No high priority message received
1= High priority message received</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1L</name>
              <description>Rx FIFO 1 Message Lost
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1F</name>
              <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1W</name>
              <description>Rx FIFO 1 Watermark Reached
0= Rx FIFO 1 fill level below watermark
1= Rx FIFO 1 fill level reached watermark</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1N</name>
              <description>Rx FIFO 1 New Message
0= No new message written to Rx FIFO 1
1= New message written to Rx FIFO 1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0L</name>
              <description>Rx FIFO 0 Message Lost
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0F</name>
              <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0W</name>
              <description>Rx FIFO 0 Watermark Reached
0= Rx FIFO 0 fill level below watermark
1= Rx FIFO 0 fill level reached watermark</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0N</name>
              <description>Rx FIFO 0 New Message
0= No new message written to Rx FIFO 0
1= New message written to Rx FIFO 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IE</name>
          <description>interrupt enable</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARAE</name>
              <description>Access to Reserved Address Enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEDE</name>
              <description>Protocol Error in Data Phase Enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEAE</name>
              <description>Protocol Error in Arbitration Phase Enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDIE</name>
              <description>Watchdog Interrupt Enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOE</name>
              <description>Bus_Off Status Interrupt Enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWE</name>
              <description>Warning Status Interrupt Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Error Passive Interrupt Enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELOE</name>
              <description>Error Logging Overflow Interrupt Enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEUE</name>
              <description>Bit Error Uncorrected Interrupt Enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BECE</name>
              <description>Bit Error Corrected Interrupt Enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRXE</name>
              <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOOE</name>
              <description>Timeout Occurred Interrupt Enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAFE</name>
              <description>Message RAM Access Failure Interrupt Enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSWE</name>
              <description>Timestamp Wraparound Interrupt Enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFLE</name>
              <description>Tx Event FIFO Event Lost Interrupt Enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFFE</name>
              <description>Tx Event FIFO Full Interrupt Enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFWE</name>
              <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFNE</name>
              <description>Tx Event FIFO New Entry Interrupt Enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEE</name>
              <description>Tx FIFO Empty Interrupt Enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCFE</name>
              <description>Transmission Cancellation Finished Interrupt Enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCE</name>
              <description>Transmission Completed Interrupt Enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPME</name>
              <description>High Priority Message Interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1LE</name>
              <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1FE</name>
              <description>Rx FIFO 1 Full Interrupt Enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1WE</name>
              <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1NE</name>
              <description>Rx FIFO 1 New Message Interrupt Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0LE</name>
              <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0FE</name>
              <description>Rx FIFO 0 Full Interrupt Enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0WE</name>
              <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0NE</name>
              <description>Rx FIFO 0 New Message Interrupt Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ILS</name>
          <description>interrupt line select</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARAL</name>
              <description>Access to Reserved Address Line</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEDL</name>
              <description>Protocol Error in Data Phase Line</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PEAL</name>
              <description>Protocol Error in Arbitration Phase Line</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDIL</name>
              <description>Watchdog Interrupt Line</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOL</name>
              <description>Bus_Off Status Interrupt Line</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EWL</name>
              <description>Warning Status Interrupt Line</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPL</name>
              <description>Error Passive Interrupt Line</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ELOL</name>
              <description>Error Logging Overflow Interrupt Line</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEUL</name>
              <description>Bit Error Uncorrected Interrupt Line</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BECL</name>
              <description>Bit Error Corrected Interrupt Line</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRXL</name>
              <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOOL</name>
              <description>Timeout Occurred Interrupt Line</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAFL</name>
              <description>Message RAM Access Failure Interrupt Line</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSWL</name>
              <description>Timestamp Wraparound Interrupt Line</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFLL</name>
              <description>Tx Event FIFO Event Lost Interrupt Line</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFFL</name>
              <description>Tx Event FIFO Full Interrupt Line</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFWL</name>
              <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEFNL</name>
              <description>Tx Event FIFO New Entry Interrupt Line</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFEL</name>
              <description>Tx FIFO Empty Interrupt Line</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCFL</name>
              <description>Transmission Cancellation Finished Interrupt Line</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCL</name>
              <description>Transmission Completed Interrupt Line</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPML</name>
              <description>High Priority Message Interrupt Line</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1LL</name>
              <description>Rx FIFO 1 Message Lost Interrupt Line</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1FL</name>
              <description>Rx FIFO 1 Full Interrupt Line</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1WL</name>
              <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF1NL</name>
              <description>Rx FIFO 1 New Message Interrupt Line</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0LL</name>
              <description>Rx FIFO 0 Message Lost Interrupt Line</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0FL</name>
              <description>Rx FIFO 0 Full Interrupt Line</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0WL</name>
              <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF0NL</name>
              <description>Rx FIFO 0 New Message Interrupt Line</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ILE</name>
          <description>interrupt line enable</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>EINT1</name>
              <description>Enable Interrupt Line 1
0= Interrupt line m_can_int1 disabled
1= Interrupt line m_can_int1 enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EINT0</name>
              <description>Enable Interrupt Line 0
0= Interrupt line m_can_int0 disabled
1= Interrupt line m_can_int0 enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GFC</name>
          <description>global filter configuration</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>ANFS</name>
              <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ANFE</name>
              <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRFS</name>
              <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRFE</name>
              <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIDFC</name>
          <description>standard ID filter configuration</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFC</resetMask>
          <fields>
            <field>
              <name>LSS</name>
              <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
&gt;128= Values greater than 128 are interpreted as 128</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLSSA</name>
              <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XIDFC</name>
          <description>extended ID filter configuration</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007FFFFC</resetMask>
          <fields>
            <field>
              <name>LSE</name>
              <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
&gt;64= Values greater than 64 are interpreted as 64</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FLESA</name>
              <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XIDAM</name>
          <description>extended id and mask</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x1FFFFFFF</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>EIDM</name>
              <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message ID of a received frame.
 Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to one the mask is not active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>29</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HPMS</name>
          <description>high priority message status</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FLST</name>
              <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FIDX</name>
              <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MSI</name>
              <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIDX</name>
              <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NDAT1</name>
          <description>new data1</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ND1</name>
              <description>New Data[31:0]
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective Rx Buffer has been updated from a received frame.
The flags remain set until the Host clears them.A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NDAT2</name>
          <description>new data2</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ND2</name>
              <description>New Data[63:32]
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective Rx Buffer has been updated from a received frame.
The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0C</name>
          <description>rx fifo 0 configuration</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFC</resetMask>
          <fields>
            <field>
              <name>F0OM</name>
              <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0WM</name>
              <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
&gt;64= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0S</name>
              <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
&gt;64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0SA</name>
              <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0S</name>
          <description>rx fifo 0 status</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x033F3F7F</resetMask>
          <fields>
            <field>
              <name>RF0L</name>
              <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero
Note: Overwriting the oldest message when RXF0C.F0OM = 1 will not set this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0F</name>
              <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0PI</name>
              <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0GI</name>
              <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F0FL</name>
              <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF0A</name>
          <description>rx fifo0 acknowledge</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>F0AI</name>
              <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI.
This will set the Rx FIFO 0 Get Index RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXBC</name>
          <description>rx buffer configuration</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFC</resetMask>
          <fields>
            <field>
              <name>RBSA</name>
              <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).Also used to reference debug messages A,B,C.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1C</name>
          <description>rx fifo1 configuration</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFC</resetMask>
          <fields>
            <field>
              <name>F1OM</name>
              <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1WM</name>
              <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
&gt;64= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1S</name>
              <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
&gt;64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1SA</name>
              <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1S</name>
          <description>rx fifo1 status</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC33F3F7F</resetMask>
          <fields>
            <field>
              <name>DMS</name>
              <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RF1L</name>
              <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero
Note: Overwriting the oldest message when RXF1C.F1OM = 1 will not set this flag.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1F</name>
              <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1PI</name>
              <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1GI</name>
              <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>F1FL</name>
              <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXF1A</name>
          <description>rx fifo 1 acknowledge</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>F1AI</name>
              <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI.
This will set the Rx FIFO 1 Get Index RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RXESC</name>
          <description>rx buffer/fifo element size configuration</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000777</resetMask>
          <fields>
            <field>
              <name>RBDS</name>
              <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F1DS</name>
              <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>F0DS</name>
              <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field
Note: In case the data field size of an accepted CAN frame exceeds the data field size configured for the matching Rx Buffer or Rx FIFO,
only the number of bytes as configured by RXESC are stored to the Rx Buffer resp. Rx FIFO element. The rest of the frames data field is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBC</name>
          <description>tx buffer configuration</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7F3FFFFC</resetMask>
          <fields>
            <field>
              <name>TFQM</name>
              <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFQS</name>
              <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
&gt;32= Values greater than 32 are interpreted as 32</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NDTB</name>
              <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
&gt;32= Values greater than 32 are interpreted as 32</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TBSA</name>
              <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).
Note: Be aware that the sum of TFQS and NDTB may be not greater than 32. There is no check for erroneous configurations. The Tx Buffers section in the Message RAM starts with the dedicated Tx Buffers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFQS</name>
          <description>tx fifo/queue status</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F1F3F</resetMask>
          <fields>
            <field>
              <name>TFQF</name>
              <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFQPI</name>
              <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFGI</name>
              <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
(TXBC.TFQM = 1).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TFFL</name>
              <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when Tx Queue operation is configured (TXBC.TFQM = 1)
Note: In case of mixed configurations where dedicated Tx Buffers are combined with a Tx FIFO or a Tx Queue, the Put and Get Indices indicate the number of the Tx Buffer starting with
the first dedicated Tx Buffers.
Example: For a configuration of 12 dedicated Tx Buffers and a Tx FIFO of 20 Buffers a Put Index of 15 points to the fourth buffer of the Tx FIFO.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXESC</name>
          <description>tx buffer element size configuration</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>TBDS</name>
              <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field
Note: In case the data length code DLC of a Tx Buffer element is configured to a value higher than the Tx Buffer data field size TXESC.TBDS, the bytes not defined by the Tx Buffer are transmitted as 0xCC (padding bytes).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBRP</name>
          <description>tx buffer request pending</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRP</name>
              <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set, a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested,
this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signalled via TXBCF
? after successful transmission together with the corresponding TXBTO bit
? when the transmission has not yet been started at the point of cancellation
? when the transmission has been aborted due to lost arbitration
? when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending
Note: TXBRP bits which are set while a Tx scan is in progress are not considered during this particular Tx scan. In case a cancellation is requested for such a Tx Buffer, this Add Request is cancelled immediately, the corresponding TXBRP bit is reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBAR</name>
          <description>tx buffer add request</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AR</name>
              <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a 1 will set the corresponding Add Request bit; writing a 0 has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed.
0= No transmission request added
1= Transmission requested added
Note: If an add request is applied for a Tx Buffer with pending transmission request (corresponding TXBRP bit already set), this add request is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCR</name>
          <description>tx buffer cancellation request</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CR</name>
              <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a 1 will set the corresponding Cancellation Request bit; writing a 0 has no impact.
This enables the Host to set cancellation requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBTO</name>
          <description>tx buffer transmission occurred</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TO</name>
              <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCF</name>
          <description>tx buffer cancellation finished</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CF</name>
              <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR.
In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBTIE</name>
          <description>tx buffer transmission interrupt enable</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIE</name>
              <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXBCIE</name>
          <description>tx buffer cancellation finished interrupt enable</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFIE</name>
              <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFC</name>
          <description>tx event fifo configuration</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3FFFFC</resetMask>
          <fields>
            <field>
              <name>EFWM</name>
              <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
&gt;32= Watermark interrupt disabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFS</name>
              <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
&gt;32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS - 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFSA</name>
              <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFS</name>
          <description>tx event fifo status</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x031F1F3F</resetMask>
          <fields>
            <field>
              <name>TEFL</name>
              <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFF</name>
              <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFPI</name>
              <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFGI</name>
              <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EFFL</name>
              <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXEFA</name>
          <description>tx event fifo acknowledge</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>EFAI</name>
              <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>TS_SEL0,TS_SEL1,TS_SEL2,TS_SEL3,TS_SEL4,TS_SEL5,TS_SEL6,TS_SEL7,TS_SEL8,TS_SEL9,TS_SEL10,TS_SEL11,TS_SEL12,TS_SEL13,TS_SEL14,TS_SEL15</dimIndex>
          <name>TS_SEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TS</name>
              <description>Timestamp Word TS
default can save 16 timestamps with 32bit;
if ts64_en is set, then work at 64bit mode, can save 8 timestamps with 01/23/45.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CREL</name>
          <description>core release register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REL</name>
              <description>Core Release
One digit, BCD-coded</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STEP</name>
              <description>Step of Core Release
One digit, BCD-coded.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SUBSTEP</name>
              <description>Sub-step of Core Release
One digit, BCD-coded</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>YEAR</name>
              <description>Timestamp Year
One digit, BCD-coded. This field is set by generic parameter on
synthesis.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MON</name>
              <description>Timestamp Month
Two digits, BCD-coded. This field is set by generic parameter
on synthesis.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAY</name>
              <description>Timestamp Day
Two digits, BCD-coded. This field is set by generic parameter
on synthesis.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSCFG</name>
          <description>timestamp configuration</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF0F</resetMask>
          <fields>
            <field>
              <name>TBPRE</name>
              <description>Timebase Prescaler
0x00 to 0xFF
The value by which the oscillator frequency is divided for
generating the timebase counter clock. Valid values for the
Timebase Prescaler are 0 to 255. The actual interpretation by
the hardware of this value is such that one more than the value
programmed here is used. Affects only the TSU internal
timebase. When the internal timebase is excluded by synthesis,
TBPRE[7:0] is fixed to 0x00, the Timestamp Prescaler is not
used.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN64</name>
              <description>set to use 64bit timestamp.
when enabled, tsu can save up to 8 different timestamps, TS(k) and TS(k+1) are used for one 64bit timestamp, k is 0~7.
TSP can be used to select different one</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCP</name>
              <description>Select Capturing Position
0: Capture Timestamp at EOF
1: Capture Timestamp at SOF</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TBCS</name>
              <description>Timebase Counter Select
When the internal timebase is excluded by synthesis, TBCS is
fixed to 1.
0: Timestamp value captured from internal timebase counter,
 ATB.TB[31:0] is the internal timbase counter
1: Timestamp value captured from input tsu_tbin[31:0],ATB.TB[31:0] is tsu_tbin[31:0]</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSUE</name>
              <description>Timestamp Unit Enable
0: TSU disabled
1: TSU enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSS1</name>
          <description>timestamp status1</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSL</name>
              <description>Timestamp Lost
Each Timestamp register (TS0-TS15) is assigned one bit. The bits are set when the timestamp stored in the related Timestamp register was overwritten before it was read.
Reading a Timestamp register resets the related bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSN</name>
              <description>Timestamp New
Each Timestamp register (TS0-TS15) is assigned one bit. The bits are set when a timestamp was stored in the related
Timestamp register. Reading a Timestamp register resets the related bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TSS2</name>
          <description>timestamp status2</description>
          <addressOffset>0x24c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>TSP</name>
              <description>Timestamp Pointer
The Timestamp Pointer is incremented by one each time a timestamp is captured. From its maximum value (3, 7, or 15
depending on number_ts_g), it is incremented to 0.
Value also signalled on output m_can_tsp[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ATB</name>
          <description>actual timebase</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TB</name>
              <description>timebase for timestamp generation 31-0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ATBH</name>
          <description>actual timebase high</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TBH</name>
              <description>timebase for timestamp generation 63-32</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GLB_CTL</name>
          <description>global control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE0000003</resetMask>
          <fields>
            <field>
              <name>M_CAN_STBY</name>
              <description>m_can standby control</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBY_CLR_EN</name>
              <description>m_can standby clear control
0:controlled by software by standby bit[bit31]
1:auto clear standby by hardware when rx data is  0</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STBY_POL</name>
              <description>standby polarity selection</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN_SEL</name>
              <description>external timestamp select. each CAN block has 4 timestamp input, this register is used to select one of them as timestame if TSCFG.TBCS is set to 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GLB_STATUS</name>
          <description>global status</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000C</resetMask>
          <fields>
            <field>
              <name>M_CAN_INT1</name>
              <description>m_can interrupt status1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>M_CAN_INT0</name>
              <description>m_can interrupt status0</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>640</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639</dimIndex>
          <name>MESSAGE_BUFF[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>m_can message buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN1</name>
      <description>MCAN1</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0284000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN2</name>
      <description>MCAN2</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0288000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN3</name>
      <description>MCAN3</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf028c000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN4</name>
      <description>MCAN4</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0290000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN5</name>
      <description>MCAN5</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0294000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN6</name>
      <description>MCAN6</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf0298000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="MCAN0">
      <name>MCAN7</name>
      <description>MCAN7</description>
      <groupName>MCAN</groupName>
      <baseAddress>0xf029c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PTPC</name>
      <description>PTPC</description>
      <groupName>PTPC</groupName>
      <baseAddress>0xf02fc000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3004</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x1000</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>PTPC[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>Ctrl0</name>
            <description>Control Register 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000003FF</resetMask>
            <fields>
              <field>
                <name>SUBSEC_DIGITAL_ROLLOVER</name>
                <description>Format for ns counter rollover,
1-digital, overflow time 1000000000/0x3B9ACA00
0-binary, overflow time  0x7FFFFFFF</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_KEEP</name>
                <description>set  will keep capture snap till software read capt_snapl.
If this bit is set, software should read capt_snaph first to avoid wrong result.
If this bit is cleared, capture result will be updated at each capture event</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_POS_EN</name>
                <description>set will use posege of input capture signal to latch timestamp value</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CAPT_SNAP_NEG_EN</name>
                <description>No description available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>COMP_EN</name>
                <description>set to enable compare, will be cleared by HW when compare event triggered</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UPDATE_TIMER</name>
                <description>update timer with +/- ts_updt, pulse, clear after set</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>INIT_TIMER</name>
                <description>initial timer with ts_updt, pulse, clear after set</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
              </field>
              <field>
                <name>FINE_COARSE_SEL</name>
                <description>0: coarse update, ns counter add ss_incr[7:0] each clk
1: fine update, ns counter add ss_incr[7:0] each time addend counter overflow</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_ENABLE</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ctrl1</name>
            <description>Control Register 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>SS_INCR</name>
                <description>constant value used to add ns counter;
such as for 50MHz timer clock, set it to 8'd20</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timeh</name>
            <description>timestamp high</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP_HIGH</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>timel</name>
            <description>timestamp low</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMESTAMP_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ts_updth</name>
            <description>timestamp update high</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SEC_UPDATE</name>
                <description>together with ts_updtl, used to initial or update timestamp</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ts_updtl</name>
            <description>timestamp update low</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADD_SUB</name>
                <description>1 for sub; 0 for add, used only at update</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NS_UPDATE</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>31</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>addend</name>
            <description>No description available</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDEND</name>
                <description>used in fine update mode only</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tarh</name>
            <description>No description available</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TARGET_TIME_HIGH</name>
                <description>used for generate compare signal if enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>tarl</name>
            <description>No description available</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TARGET_TIME_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>pps_ctrl</name>
            <description>No description available</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>PPS_CTRL</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>capt_snaph</name>
            <description>No description available</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPT_SNAP_HIGH</name>
                <description>take snapshot for input capture signal, at pos or neg or both;
the result can be kept or updated at each event according to cfg0.bit8</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>capt_snapl</name>
            <description>No description available</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPT_SNAP_LOW</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>time_sel</name>
          <description>No description available</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>CAN3_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN2_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN1_TIME_SEL</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAN0_TIME_SEL</name>
              <description>set to use ptpc1 for canx
clr to use ptpc0 for canx</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_sts</name>
          <description>No description available</description>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00070007</resetMask>
          <fields>
            <field>
              <name>COMP_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PPS_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>COMP_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PPS_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_en</name>
          <description>No description available</description>
          <addressOffset>0x2008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00070007</resetMask>
          <fields>
            <field>
              <name>COMP_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_INT_STS1</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPTURE_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPS_INT_STS0</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ptpc_can_ts_sel</name>
          <description>No description available</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>TSU_TBIN3_SEL</name>
              <description>No description available</description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN2_SEL</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN1_SEL</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSU_TBIN0_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCDC</name>
      <description>LCDC</description>
      <groupName>LCDC</groupName>
      <baseAddress>0xf1000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x404</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF3E01F</resetMask>
          <fields>
            <field>
              <name>SW_RST</name>
              <description>Software reset, high active. When write 1 ,all internal logical will be reset.
0b - No action
1b - All LCDC internal registers are forced into their reset state. Interface registers are not affected.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISP_ON</name>
              <description>Display panel On/Off mode.
0b - Display Off.
1b - Display On.
Display can be set off at any time, but it can only be set on after VS_BLANK status is asserted.
So a good procedure to stop and turn on the display is:
1) clr VS_BLANK status
2) assert software reset
3) de-assert software reset
4) set display off
5) check VS_BLANK status until it is asserted,
6)reset the module, change settings
7) set display on</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_PATTERN</name>
              <description>LCDIF line output order.
000b - RGB.
001b - RBG.
010b - GBR.
011b - GRB.
100b - BRG.
101b - BGR.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISP_MODE</name>
              <description>LCDIF operating mode.
00b - Normal mode. Panel content controlled by layer configuration.
01b - Test Mode1.(BGND Color Display)
10b - Test Mode2.(Column Color Bar)
11b - Test Mode3.(Row Color Bar)</description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BGDCL4CLR</name>
              <description>background color for clear mode when the alpha channel is 0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ARQOS</name>
              <description>ARQOS for bus fabric arbitration</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHADOW_OP</name>
              <description>Shadow Option
1: Use physical VSYNC (ST[VS_BLANK]) as shadow time.
0: Use layer internal logic VSYNC as shadow time. In general, this type of shadow control will have longer memory read time, so less underflow risk.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>B_LE_MODE</name>
              <description>Endianness mode for Blue Color Pads
1: Little endian. Pad 0 --&gt; Color LSB 0
0: Big Endian. Pad 0--&gt; Color MSB 7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>G_LE_MODE</name>
              <description>Endianness mode for Green Color Pads
1: Little endian. Pad 0 --&gt; Color LSB 0
0: Big Endian. Pad 0--&gt; Color MSB 7</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>R_LE_MODE</name>
              <description>Endianness mode for Red Color Pads
1: Little endian. Pad 0 --&gt; Color LSB 0
0: Big Endian. Pad 0--&gt; Color MSB 7</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM_SYNC_EN</name>
              <description>Enable the VSYNC synchronization of CAM and LCDC</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_PXDATA</name>
              <description>Indicates if value at the output (pixel data output) needs to be negated.
0b - Output is to remain same as the data inside memory
1b - Output to be negated from the data inside memory</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_PXCLK</name>
              <description>Polarity change of Pixel Clock.
0b - LCDC outputs data on the rising edge, and Display samples data on the falling edge
1b - LCDC outputs data on the falling edge, Display samples data on the rising edge</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_HREF</name>
              <description>Polarity of HREF
0b - HREF signal active HIGH, indicating active pixel data
1b - HREF signal active LOW</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_VSYNC</name>
              <description>Polarity of VSYNC
0b - VSYNC signal active HIGH
1b - VSYNC signal active LOW</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_HSYNC</name>
              <description>Polarity of HSYNC
0b - HSYNC signal active HIGH
1b - HSYNC signal active LOW</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BGND_CL</name>
          <description>Background Color Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>R</name>
              <description>Red component of the default color displayed in the sectors where no layer is active.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>G</name>
              <description>Green component of the default color displayed in the sectors where no layer is active.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>B</name>
              <description>Blue component of the default color displayed in the sectors where no layer is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DISP_WN_SIZE</name>
          <description>Display Window Size Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>Y</name>
              <description>Sets the display size vertical resolution in pixels.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>X</name>
              <description>Sets the display size horizontal resolution in pixels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSYNC_PARA</name>
          <description>HSYNC Config Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FP</name>
              <description>HSYNC front-porch pulse width (in pixel clock cycles). If zero, indicates no front-porch for HSYNC</description>
              <bitOffset>22</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BP</name>
              <description>HSYNC back-porch pulse width (in pixel clock cycles). If zero, indicates no back-porch for HSYNC</description>
              <bitOffset>11</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PW</name>
              <description>HSYNC active pulse width (in pixel clock cycles). Pulse width has a minimum value of 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VSYNC_PARA</name>
          <description>VSYNC Config Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FP</name>
              <description>VSYNC front-porch pulse width (in horizontal line cycles). If zero, means no front-porch for VSYNC</description>
              <bitOffset>22</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BP</name>
              <description>VSYNC back-porch pulse width (in horizontal line cycles). If zero, means no back-porch for VSYNC</description>
              <bitOffset>11</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PW</name>
              <description>VSYNC active pulse width (in horizontal line cycles). Pulse width has a minimum value of 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_ST</name>
          <description>DMA Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>DMA_ERR</name>
              <description>plane n axi error. W1C.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA1_DONE</name>
              <description>Plane n frame 1 dma done. W1C.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA0_DONE</name>
              <description>Plane n frame 0 dma done. W1C.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ST</name>
          <description>Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>P1_HANDSHAKE_ABORT</name>
              <description>Plane 1 handshake abort error. W1C</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>P0_HANDSHAKE_ABORT</name>
              <description>Plane 0 handshake abort error. W1C</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAM_HCNT_FAIL</name>
              <description>During cam_vsync mode, sync fail due to hcnt out of acceptable ranges. W1C</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CAM_VSYNC_FAIL</name>
              <description>During cam_vsync mode, sync fail due to out of vsync parameters. W1C</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SHADOW_DONE</name>
              <description>Shadow done status. This is an OR-ed signals of all shadow_done signals of all planes, and it can only be cleared by writing 1 for all asserted bits in SHADOW_DONE_ST register.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>URGENT_UNDERRUN</name>
              <description>Asserted when the output buffer urgent underrun condition encountered</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VS_BLANK</name>
              <description>Asserted when in vertical blanking period. At the start of VSYNC</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UNDERRUN</name>
              <description>Asserted when the output buffer underrun condition encountered</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>VSYNC</name>
              <description>Asserted when in  vertical blanking period. At the end of VSYNC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMA_ERR</name>
              <description>Interrupt enable for DMA error</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_DONE</name>
              <description>Interrupt enable for DMA done</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HANDSHAKE_ABORT</name>
              <description>Handshake abort error int enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM_HCNT_FAIL</name>
              <description>hcnt out of acceptable ranges interrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM_VSYNC_FAIL</name>
              <description>cam_vsync fail interrupt enable</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHADOW_DONE</name>
              <description>Shadow done interrupt enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URGENT_UNDERRUN</name>
              <description>Asserted when the output buffer urgent underrun condition encountered</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VS_BLANK</name>
              <description>Interrupt enable for start of sof</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERRUN</name>
              <description>Interrupt enable for underrun</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC</name>
              <description>Interrupt enable for end of sof</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFIFO</name>
          <description>TX FIFO Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>THRSH</name>
              <description>Threshold to start the lcd raster (0--0x7F)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_BP_V_RANGE</name>
          <description>BP_V range for CAMSYNC mode</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX</name>
              <description>Maximal BP_V values</description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEST</name>
              <description>Best BP_V values</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIN</name>
              <description>Minimal BP_V values</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_PW_V_RANGE</name>
          <description>PW_V range for CAMSYNC mode</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX</name>
              <description>Maximal PW_V values</description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEST</name>
              <description>Best PW_V values</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIN</name>
              <description>Minimal PW_V values</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_FP_V_RANGE</name>
          <description>FP_V range for CAMSYNC mode</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX</name>
              <description>Maximal FP_V values</description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BEST</name>
              <description>Best FP_V values</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIN</name>
              <description>Minimal FP_V values</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_SYNC_HCNT_MIN</name>
          <description>min HCNT value for CAMSYNC mode</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>minimal acceptable HCNT Value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_SYNC_HCNT_BEST</name>
          <description>best HCNT value for CAMSYNC mode</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>HYST</name>
              <description>hysteresys of acceptable HCNT Value</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VAL</name>
              <description>best acceptable HCNT Value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_SYNC_HCNT_MAX</name>
          <description>max HCNT value for CAMSYNC mode</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>maximal acceptable HCNT Value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAM_SYNC_HCNT_ST</name>
          <description>current HCNT value for CAMSYNC mode</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>current HCNT value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SHADOW_DONE_ST</name>
          <description>Shadow done status</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>current shadow_done value for plane 7,...,0 respectively</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SHADOW_DONE_INT_EN</name>
          <description>Shadow done interrupt enable</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>shadow_done interrupt enable for plane 7,...,0 respectively</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>LAYER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <register>
            <name>LAYCTRL</name>
            <description>Layer Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFD</resetMask>
            <fields>
              <field>
                <name>RESAMPLE_VRATIO</name>
                <description>Resample the input data stream in the verticle direction
0: don't resample
positive n: upsample-by-n+1 (2 to 8)
negtive n: downsample-by-n+1 (2 to 8)</description>
                <bitOffset>28</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESAMPLE_HRATIO</name>
                <description>Resample the input data stream in the horizontal direction
0: don't resample
positive n: upsample-by-n+1 (2 to 8)
negtive n: downsample-by-n+1 (2 to 8)</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>NORMLZ_OUT</name>
                <description>Normalize the pixel out for the not-overlapped pixels</description>
                <bitOffset>23</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HANDSHAKE_ABORT_INT_EN</name>
                <description>1: Enable the handshake abort error interrupt.
0: don't Enable the handshake abort error interrupt.
Abort is generated when the LCDC is going to switch bank to a new bank, and the new bank data is not ready yet.
Abort is only useful when communicating with the offline calculator (such as PDMA as the active pixel generator mode).
PDMA as the active generator mode, means it is the first pixel generator with data sources from offline memory, and not from on-the-fly streaming data (such as camera captured data).
While with on-the-fly streaming data, error condition is indicated by display buffer underflow.</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HANDSHAKE_BUFSIZE</name>
                <description>1: handshake buffer is 16 rows hight per ping or pang buf.
0: handshake buffer is 8 rows hight per ping or pang buf.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_HANDSHAKE</name>
                <description>Enable handshake with input pixel controller. When this is set, the LCDC will not process an entire framebuffer,
but will instead process rows of NxN blocks in a double-buffer handshake with the input pixel controlller. This enables
the use of the onboard SRAM for a partial frame buffer. Only valid for Plane 0 &amp; 1.
1: handshake enabled
0: handshake disabled</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PACK_DIR</name>
                <description>The byte sequence of the 4 bytes in a 32-bit word.
1: {A0, A1, A2, A3} byte re-ordered.
0: {A3, A2, A1, A0} the normal case with no byte re-order</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SHADOW_LOAD_EN</name>
                <description>Shadow Load Enable
The SHADOW_LOAD_EN bit is written to 1 by software after all DMA control registers are written. If set to 1, shadowed control registers are updated to the active control registers on internal logical VSYNC of next frame. If set to 0, shadowed control registers are not loaded into the active control registers. The previous active control register settings will be used to process the next frame. Hardware will automatically clear this bit, when the shadow registers are loaded to the active control regsisters.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>YUV_FORMAT</name>
                <description>The YUV422 input format selection.
00b - The YVYU422 8bit sequence is U1,Y1,V1,Y2
01b - The YVYU422 8bit sequence is V1,Y1,U1,Y2
10b - The YVYU422 8bit sequence is Y1,U1,Y2,V1
11b - The YVYU422 8bit sequence is Y1,V1,Y2,U1
If not YUV422 mode,
FORMAT[0]: asserted to exchange sequence inside the bytes. Org [15:8]--&gt;New[8:15], Org [7:0]--&gt;New[0:7]. (First exchange)
FORMAT[1]: asserted to exchange the sequence of the odd and even 8 bits. Org Even [7:0]--&gt;New[15:8], Org Odd [15:8]--&gt;New[7:0]. (Second exchange)</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PIXFORMAT</name>
                <description>Layer encoding format (bit per pixel)
0000b - 1 bpp (pixel width must be multiples of 32), pixel sequence is from LSB to MSB in 32b word.
0001b - 2 bpp (pixel width must be multiples of 16), pixel sequence is from LSB to MSB in 32b word.
0010b - 4 bpp (pixel width must be multiples of 8), pixel sequence is from LSB to MSB in 32b word.
0011b - 8 bpp  (pixel width must be multiples of 4), pixel sequence is from LSB to MSB in 32b word.
0100b - 16 bpp (RGB565), the low byte contains the full R component.
0111b - YCbCr422 (Only layer 0/1 can support this format), byte sequence determined by LAYCTRL[YUV_FORMAT]
1001b - 32 bpp (ARGB8888), byte sequence as B,G,R,A
1011b - Y8  (pixel width must be multiples of 4), byte sequence as Y1,Y2,Y3,Y4</description>
                <bitOffset>10</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCALPHA_OP</name>
                <description>The usage of the LOCALPHA[7:0]: (The system alpha value is not the data valid mask, the non-zero alpha value per pixel indicates a valid pixel. If no such per pixel alpha value, it means all the pixels are valid)
0: the LOCALPHA[7:0] is invalid, use the alpha value from the data stream
1: the LOCALPHA[7:0] is used to override the alpha value in the data stream (useful when the data stream has no alpha info)
2: the LOCALPHA[7:0] is used to scale the alpha value from the data stream
Others: Reserved</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INALPHA_OP</name>
                <description>The usage of the INALPHA[7:0]: (The system alpha value is not the data valid mask, the non-zero alpha value per pixel indicates a valid pixel. If no such per pixel alpha value, it means all the pixels are valid)
0: the INALPHA[7:0] is invalid, use the alpha value from previous pipeline
1: the INALPHA[7:0] is used to override the alpha value from previous pipeline.  (useful when the corresponding data stream has no alpha info)
2: the INALPHA[7:0] is used to scale the alpha value from previous pipeline
Others: Reserved</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>AB_MODE</name>
                <description>Alpha Blending Mode
0: SKBlendMode_Clear;
3: SKBlendMode_SrcOver
14: SRC org
15: DST org
Others: Reserved.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>EN</name>
                <description>Asserted when the layer is enabled. If this layer is not enabled, it means a bypassing plane.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ALPHAS</name>
            <description>Layer Alpha Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOCD</name>
                <description>The system alpha value for the data stream of current layer stream (SRC)</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IND</name>
                <description>The system alpha value for the input stream from previous stage (DST)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LAYSIZE</name>
            <description>Layer Size Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>HEIGHT</name>
                <description>Height of the layer in pixels</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of the layer in pixels (Note: not actual width-1)
The layer width must be in multiples of the number of pixels that can be stored in 32 bits, and therefore differs depending on color encoding. For example, if 2 bits per pixel format is used, then the layer width must be configured in multiples of 16.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LAYPOS</name>
            <description>Layer Position Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>Y</name>
                <description>The vertical position of top row of the layer, where 0 is the top row of the panel, positive values are below the top row of the panel.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>X</name>
                <description>The horizontal position of left-hand column of the layer, where 0 is the left-hand column of the panel, positive values are to the right the left-hand column of the panel.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>START0</name>
            <description>Layer Buffer Pointer Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR0</name>
                <description>Input buffer Start address 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LINECFG</name>
            <description>Layer Bus Config Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xE0FFFFFF</resetMask>
            <fields>
              <field>
                <name>MPT_SIZE</name>
                <description>Maximal Per Transfer Data Size:
0: 64 bytes
1: 128 bytes
2: 256 bytes
3: 512 bytes
4: 1024 bytes</description>
                <bitOffset>29</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MAX_OT</name>
                <description>the number of outstanding axi read transactions.
If zero, it means max 8.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PITCH</name>
                <description>Number of bytes between 2 vertically adjacent pixels in system memory. Byte granularity is supported, but SW should align to 64B boundary.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BG_CL</name>
            <description>Layer Background Color Register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARGB</name>
                <description>ARGB8888. It is only useful in the last active stage in the pipeline.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CSC_COEF0</name>
            <description>Layer Color Space Conversion Config Register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>YCBCR_MODE</name>
                <description>This bit changes the behavior when performing U/V converting.
0b - Converting YUV to RGB data
1b - Converting YCbCr to RGB data</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable the CSC unit in the LCDC plane data path.
0b - The CSC is bypassed and the input pixels are RGB data already
1b - The CSC is enabled and the pixels will be converted to RGB data
This bit will be shadowed.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>C0</name>
                <description>Two's compliment Y multiplier coefficient C0. YUV=0x100 (1.000) YCbCr=0x12A (1.164)</description>
                <bitOffset>18</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UV_OFFSET</name>
                <description>Two's compliment phase offset implicit for CbCr data UV_OFFSET. Generally used for YCbCr to RGB conversion.
YCbCr=0x180, YUV=0x000 (typically -128 or 0x180 to indicate normalized -0.5 to 0.5 range).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_OFFSET</name>
                <description>Two's compliment amplitude offset implicit in the Y data Y_OFFSET. For YUV, this is typically 0 and for YCbCr, this is
typically -16 (0x1F0).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>9</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CSC_COEF1</name>
            <description>Layer Color Space Conversion Config Register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>C1</name>
                <description>Two's compliment Red V/Cr multiplier coefficient C1. YUV=0x123 (1.140) YCbCr=0x198 (1.596).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>C4</name>
                <description>Two's compliment Blue U/Cb multiplier coefficient C4. YUV=0x208 (2.032) YCbCr=0x204 (2.017).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CSC_COEF2</name>
            <description>Layer Color Space Conversion Config Register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>C2</name>
                <description>Two's compliment Green V/Cr multiplier coefficient C2. YUV=0x76B (-0.581) YCbCr=0x730 (-0.813).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>C3</name>
                <description>Two's compliment Green U/Cb multiplier coefficient C3. YUV=0x79C (-0.394) YCbCr=0x79C (-0.392).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CLUT_LOAD</name>
          <description>Clut Load Control Register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>STR_HIGH</name>
              <description>1'b1: Store 8+ CLUT tables through APB
1'b0: Store 0-7 CLUT tables through APB</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_NUM</name>
              <description>Selected CLUT Number
The SEL_CLUT_NUM is used to select which plane's CLUT need to be updated. The hardware can only backup one CLUT setting and load, so the SEL_CLUT_NUM can't be changed when CLUT_LOAD[UPDATE_EN] is 1.
. 3'h0 - PLANE 0
. 3'h1 - PLANE 1
. ------
. 3'h7 - PLANE 7
CLUT 8 can be modified via APB even when display is on.
Currently CLUT for plane 0..7 cannot be modified via APB when display is on.  Can only be updated via CLUT_LOAD[UPDATE_EN] bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE_EN</name>
              <description>CLUT Update Enable
The bit is written to 1 when software want to update the Color Look Up Tables during display.
If set to 1, software update selected CLUT due to SEL_CLUT_NUM setting, the table will be copied from CLUT8 during vertical blanking period after SHADOW_LOAD_EN is set to 1.
If set to 0, software can update CLUT8 directly according to the CLUT memory map.
Hardware will automatically clear this bit when selected CLUT is updated according to SEL_CLUT_NUM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="LCDC">
      <name>LCDC1</name>
      <description>LCDC1</description>
      <groupName>LCDC</groupName>
      <baseAddress>0xf1004000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CAM0</name>
      <description>CAM0</description>
      <groupName>CAM</groupName>
      <baseAddress>0xf1008000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4b0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF9AAFFF</resetMask>
          <fields>
            <field>
              <name>INV_DEN</name>
              <description>invert den pad input before it is used</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COLOR_EXT</name>
              <description>If asserted, will change the output color to ARGB8888 mode. Used by input color as RGB565, RGB888, YUV888, etc.
The byte sequence is B,G,R,A. Depends on correct CR2[ClrBitFormat] configuration.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_PIXCLK</name>
              <description>invert pixclk pad input before it is used</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_HSYNC</name>
              <description>invert hsync pad input before it is used</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_VSYNC</name>
              <description>invert vsync pad input before it is used</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWAP16_EN</name>
              <description>SWAP 16-Bit Enable. This bit enables the swapping of 16-bit data. Data is packed from 8-bit or 10-bit to 32-bit first (according to the setting of PACK_DIR) and then swapped as 16-bit words before being put into the RX FIFO. The action of the bit only affects the RX FIFO.
NOTE: Example of swapping enabled:
Data input to FIFO = 0x11223344
Data in RX FIFO = 0x 33441122
NOTE: Example of swapping disabled:
Data input to FIFO = 0x11223344
Data in RX FIFO = 0x11223344
0 Disable swapping
1 Enable swapping</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PACK_DIR</name>
              <description>Data Packing Direction. This bit Controls how 8-bit/10-bit image data is packed into 32-bit RX FIFO.
0 Pack from LSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x44332211 in RX FIFO.
1 Pack from MSB first. For image data, 0x11, 0x22, 0x33, 0x44, it will appear as 0x11223344 in RX FIFO.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESTART_BUSPTR</name>
              <description>force to restart the bus pointer at the every end of the sof period, and at the same time, clr the fifo pointer</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNC_RXFIFO_CLR</name>
              <description>ASynchronous Rx FIFO Clear.
When asserted, this bit clears RXFIFO immediately.
It will be auto-cleared.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYNC_RXFIFO_CLR</name>
              <description>Synchronous Rx FIFO Clear.
When asserted, this bit clears RXFIFO on every SOF.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOF_INT_POL</name>
              <description>SOF Interrupt Polarity. This bit controls the condition that generates an SOF interrupt.
0 SOF interrupt is generated on SOF falling edge
1 SOF interrupt is generated on SOF rising edge</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_DATA</name>
              <description>Invert Data Input. This bit enables or disables internal inverters on the data lines.
0 CAM_D data lines are directly applied to internal circuitry
1 CAM_D data lines are inverted before applied to internal circuitry</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STORAGE_MODE</name>
              <description>00: Normal Mode (one plane mode)
01: Two Plane Mode (Y, UV plane)
10: Y-only Mode, byte sequence as Y0,Y1,Y2,Y3
11: Binary Mode, bit sequence is from LSB to MSB when CR20[BIG_END]=0</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COLOR_FORMATS</name>
              <description>input color formats:
0010b:24bit:RGB888
0011b:24bit:RGB666
0100b:16bit:RGB565
0101b:16bit:RGB444
0110b:16bit:RGB555
0111b: 16bit: YCbCr422 (Y0 Cb Y1 Cr, each 8-bit)
YUV
YCrCb
Note: YUV420 is not supported.
1000b: 24bit: YUV444</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSOR_BIT_WIDTH</name>
              <description>the bit width of the sensor
0: 8 bits
1: 10 bits
3:24bits
Others: Undefined</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF5F</resetMask>
          <fields>
            <field>
              <name>ERR_CL_BWID_CFG_INT_EN</name>
              <description>The unsupported color (color_formats[3:0]) and bitwidth (sensor_bit_width[2:0]) configuation interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIST_DONE_INT_EN</name>
              <description>Enable hist done int</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HRESP_ERR_EN</name>
              <description>Hresponse Error Enable. This bit enables the hresponse error interrupt.
0 Disable hresponse error interrupt
1 Enable hresponse error interrupt</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOF_INT_EN</name>
              <description>End-of-Frame Interrupt Enable. This bit enables and disables the EOF interrupt.
0 EOF interrupt is disabled.
1 EOF interrupt is generated when RX count value is reached.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RF_OR_INTEN</name>
              <description>RxFIFO Overrun Interrupt Enable. This bit enables the RX FIFO overrun interrupt.
0 RxFIFO overrun interrupt is disabled
1 RxFIFO overrun interrupt is enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FB2_DMA_DONE_INTEN</name>
              <description>Frame Buffer2 DMA Transfer Done Interrupt Enable. This bit enables the interrupt of Frame Buffer2 DMA
transfer done.
0 Frame Buffer2 DMA Transfer Done interrupt disable
1 Frame Buffer2 DMA Transfer Done interrupt enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FB1_DMA_DONE_INTEN</name>
              <description>Frame Buffer1 DMA Transfer Done Interrupt Enable. This bit enables the interrupt of Frame Buffer1 DMA
transfer done.
0 Frame Buffer1 DMA Transfer Done interrupt disable
1 Frame Buffer1 DMA Transfer Done interrupt enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOF_INT_EN</name>
              <description>Start Of Frame (SOF) Interrupt Enable. This bit enables the SOF interrupt.
0 SOF interrupt disable
1 SOF interrupt enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <description>Control 2 Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF8FEF</resetMask>
          <fields>
            <field>
              <name>FRMCNT_15_0</name>
              <description>Frame Counter. This is a 16-bit Frame Counter
(Wraps around automatically after reaching the maximum)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRMCNT_RST</name>
              <description>Frame Count Reset. Resets the Frame Counter.
0 Do not reset
1 Reset frame counter immediately</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFF_LEVEL</name>
              <description>RxFIFO Full Level. When the number of data in RxFIFO reaches this level, a RxFIFO full interrupt is generated, or an RXFIFO DMA request is sent.
000 4 Double words
001 8 Double words
010 16 Double words
011 24 Double words
100 32 Double words
101 48 Double words
110 64 Double words
111 96 Double words</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_REQ_EN_RFF</name>
              <description>DMA Request Enable for RxFIFO. This bit enables the dma request from RxFIFO to the embedded DMA controller.
0 Disable the dma request
1 Enable the dma request. The UV Rx FIFO is only enabled to filling data in 2 plane mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRBITFORMAT</name>
              <description>Input Byte &amp; bit sequence same as OV5640, except for Raw mode. Used only for internal ARGB conversion.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFA7FC</resetMask>
          <fields>
            <field>
              <name>ERR_CL_BWID_CFG</name>
              <description>The unsupported color (color_formats[3:0]) and bitwidth (sensor_bit_width[2:0]) configuation found</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HIST_DONE</name>
              <description>hist cal done</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RF_OR_INT</name>
              <description>RxFIFO Overrun Interrupt Status. Indicates the overflow status of the RxFIFO register. (Cleared by writing
1)
0 RXFIFO has not overflowed.
1 RXFIFO has overflowed.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_TSF_DONE_FB2</name>
              <description>DMA Transfer Done in Frame Buffer2. Indicates that the DMA transfer from RxFIFO to Frame Buffer2 is completed. It can trigger an interrupt if the corresponding enable bit is set in CAM_CR1. This bit can be cleared by by writing 1 or reflashing the RxFIFO dma controller in CAM_CR3. (Cleared by writing 1)
0 DMA transfer is not completed.
1 DMA transfer is completed.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DMA_TSF_DONE_FB1</name>
              <description>DMA Transfer Done in Frame Buffer1. Indicates that the DMA transfer from RxFIFO to Frame Buffer1 is completed. It can trigger an interrupt if the corresponding enable bit is set in CAM_CR1. This bit can be cleared by by writing 1 or reflashing the RxFIFO dma controller in CAM_CR3. (Cleared by writing 1)
0 DMA transfer is not completed.
1 DMA transfer is completed.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>EOF_INT</name>
              <description>End of Frame (EOF) Interrupt Status. Indicates when EOF is detected. (Cleared by writing 1)
0 EOF is not detected.
1 EOF is detected.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SOF_INT</name>
              <description>Start of Frame Interrupt Status. Indicates when SOF is detected. (Cleared by writing 1)
0 SOF is not detected.
1 SOF is detected.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HRESP_ERR_INT</name>
              <description>Hresponse Error Interrupt Status. Indicates that a hresponse error has been detected. (Cleared by writing
1)
0 No hresponse error.
1 Hresponse error is detected.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMASA_FB1</name>
          <description>Pixel DMA Frame Buffer 1 Address</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>DMA Start Address in Frame Buffer1. Indicates the start address to write data. The embedded DMA controller will read data from RxFIFO and write it from this address through AHB bus. The address should be double words aligned.
In Two-Plane Mode, Y buffer1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMASA_FB2</name>
          <description>Pixel DMA Frame Buffer 2 Address</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>DMA Start Address in Frame Buffer2. Indicates the start address to write data. The embedded DMA controller will read data from RxFIFO and write it from this address through AHB bus. The address should be double words aligned.
In Two-Plane Mode, Y buffer2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUF_PARA</name>
          <description>Buffer Parameters Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINEBSP_STRIDE</name>
              <description>Line Blank Space Stride. Indicates the space between the end of line image storage and the start of a new line storage in the frame buffer.
The width of the line storage in frame buffer(in double words) minus the width of the image(in double words) is the stride. The stride should be double words aligned. The embedded DMA controller will skip the stride before starting to write the next row of the image.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDEAL_WN_SIZE</name>
          <description>Ideal Image Size Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HEIGHT</name>
              <description>Image Height. Indicates how many active pixels in a column of the image from the sensor.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIDTH</name>
              <description>Image Width. Indicates how many active pixels in a line of the image from the sensor.
The number of bytes to be transferred is re-calculated automatically in hardware based on cr1[color_ext] and cr1[store_mode]. Default value is 2*pixel number.
As the input data from the sensor is 8-bit/pixel format, the IMAGE_WIDTH should be a multiple of 8 pixels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR18</name>
          <description>Control CR18 Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFE7BF</resetMask>
          <fields>
            <field>
              <name>CAM_ENABLE</name>
              <description>CAM global enable signal. Only when this bit is 1, CAM can start to receive the data and store to memory.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AWQOS</name>
              <description>AWQOS for bus fabric arbitration</description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMASA_UV1</name>
          <description>Pixel UV DMA Frame Buffer 1 Address</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>Two Plane UV Buffer Start Address 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMASA_UV2</name>
          <description>Pixel UV DMA Frame Buffer 2 Address</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PTR</name>
              <description>Two Plane UV Buffer Start Address 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR20</name>
          <description>Control CR20 Register</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BINARY_EN</name>
              <description>binary picture output enable</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HISTOGRAM_EN</name>
              <description>histogarm enable</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIG_END</name>
              <description>Asserted when binary output is in big-endian type, which mean the right most data is at the LSBs. Take function only inside the 32-bit word.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>THRESHOLD</name>
              <description>Threshold to generate binary color. Bin 1 is output if the pixel is greater than the threshold.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSC_COEF0</name>
          <description>Color Space Conversion Config Register 0</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>YCBCR_MODE</name>
              <description>This bit changes the behavior when performing U/V converting.
0b - Converting YUV to RGB data
1b - Converting YCbCr to RGB data</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable the CSC unit
0b - The CSC is bypassed and the input pixels are RGB data already
1b - The CSC is enabled and the pixels will be converted to RGB data</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C0</name>
              <description>Two's compliment Y multiplier coefficient. YUV=0x100 (1.000) YCbCr=0x12A (1.164)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_OFFSET</name>
              <description>Two's compliment phase offset implicit for CbCr data. Generally used for YCbCr to RGB conversion.
YCbCr=0x180, YUV=0x000 (typically -128 or 0x180 to indicate normalized -0.5 to 0.5 range).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_OFFSET</name>
              <description>Two's compliment amplitude offset implicit in the Y data. For YUV, this is typically 0 and for YCbCr, this is
typically -16 (0x1F0).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSC_COEF1</name>
          <description>Color Space Conversion Config Register 1</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C1</name>
              <description>Two's compliment Red V/Cr multiplier coefficient. YUV=0x123 (1.140) YCbCr=0x198 (1.596).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C4</name>
              <description>Two's compliment Blue U/Cb multiplier coefficient. YUV=0x208 (2.032) YCbCr=0x204 (2.017).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSC_COEF2</name>
          <description>Color Space Conversion Config Register 2</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C2</name>
              <description>Two's compliment Green V/Cr multiplier coefficient. YUV=0x76B (-0.581) YCbCr=0x730 (-0.813).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C3</name>
              <description>Two's compliment Green U/Cb multiplier coefficient. YUV=0x79C (-0.394) YCbCr=0x79C (-0.392).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLRKEY_LOW</name>
          <description>Low Color Key Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIMIT</name>
              <description>Low range of color key applied to PS buffer. To disable PS colorkeying, set the low colorkey to 0xFFFFFF and the high colorkey to 0x000000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLRKEY_HIGH</name>
          <description>High Color Key Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIMIT</name>
              <description>Low range of color key applied to PS buffer. To disable PS colorkeying, set the low colorkey to 0xFFFFFF and the high colorkey to 0x000000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DATA0,DATA1,DATA2,DATA3,DATA4,DATA5,DATA6,DATA7,DATA8,DATA9,DATA10,DATA11,DATA12,DATA13,DATA14,DATA15,DATA16,DATA17,DATA18,DATA19,DATA20,DATA21,DATA22,DATA23,DATA24,DATA25,DATA26,DATA27,DATA28,DATA29,DATA30,DATA31,DATA32,DATA33,DATA34,DATA35,DATA36,DATA37,DATA38,DATA39,DATA40,DATA41,DATA42,DATA43,DATA44,DATA45,DATA46,DATA47,DATA48,DATA49,DATA50,DATA51,DATA52,DATA53,DATA54,DATA55,DATA56,DATA57,DATA58,DATA59,DATA60,DATA61,DATA62,DATA63,DATA64,DATA65,DATA66,DATA67,DATA68,DATA69,DATA70,DATA71,DATA72,DATA73,DATA74,DATA75,DATA76,DATA77,DATA78,DATA79,DATA80,DATA81,DATA82,DATA83,DATA84,DATA85,DATA86,DATA87,DATA88,DATA89,DATA90,DATA91,DATA92,DATA93,DATA94,DATA95,DATA96,DATA97,DATA98,DATA99,DATA100,DATA101,DATA102,DATA103,DATA104,DATA105,DATA106,DATA107,DATA108,DATA109,DATA110,DATA111,DATA112,DATA113,DATA114,DATA115,DATA116,DATA117,DATA118,DATA119,DATA120,DATA121,DATA122,DATA123,DATA124,DATA125,DATA126,DATA127,DATA128,DATA129,DATA130,DATA131,DATA132,DATA133,DATA134,DATA135,DATA136,DATA137,DATA138,DATA139,DATA140,DATA141,DATA142,DATA143,DATA144,DATA145,DATA146,DATA147,DATA148,DATA149,DATA150,DATA151,DATA152,DATA153,DATA154,DATA155,DATA156,DATA157,DATA158,DATA159,DATA160,DATA161,DATA162,DATA163,DATA164,DATA165,DATA166,DATA167,DATA168,DATA169,DATA170,DATA171,DATA172,DATA173,DATA174,DATA175,DATA176,DATA177,DATA178,DATA179,DATA180,DATA181,DATA182,DATA183,DATA184,DATA185,DATA186,DATA187,DATA188,DATA189,DATA190,DATA191,DATA192,DATA193,DATA194,DATA195,DATA196,DATA197,DATA198,DATA199,DATA200,DATA201,DATA202,DATA203,DATA204,DATA205,DATA206,DATA207,DATA208,DATA209,DATA210,DATA211,DATA212,DATA213,DATA214,DATA215,DATA216,DATA217,DATA218,DATA219,DATA220,DATA221,DATA222,DATA223,DATA224,DATA225,DATA226,DATA227,DATA228,DATA229,DATA230,DATA231,DATA232,DATA233,DATA234,DATA235,DATA236,DATA237,DATA238,DATA239,DATA240,DATA241,DATA242,DATA243,DATA244,DATA245,DATA246,DATA247,DATA248,DATA249,DATA250,DATA251,DATA252,DATA253,DATA254,DATA255</dimIndex>
          <name>HISTOGRAM_FIFO[%s]</name>
          <description>no description available</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIST_Y</name>
              <description>the appearance of bin x (x=(address-DATA0)/4)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROI_WIDTH</name>
          <description>Roi Width Config Register</description>
          <addressOffset>0x490</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ROI_WIDTH_END</name>
              <description>end address of width for roi</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ROI_WIDTH_START</name>
              <description>start address of width for roi</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROI_HEIGHT</name>
          <description>Roi Width Config Register</description>
          <addressOffset>0x494</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ROI_HEIGHT_END</name>
              <description>end address of height for roi</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ROI_HEIGHT_START</name>
              <description>start address of height for roi</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRO_CTRL</name>
          <description>Pro Config Register</description>
          <addressOffset>0x498</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF40FF</resetMask>
          <fields>
            <field>
              <name>ERR_INJECT</name>
              <description>0 generate alarm in normal mode
1 force to generate fatal alarm</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ROI_UPDATE</name>
              <description>roi configration update</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE_UPDATE</name>
              <description>scale configration update</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE_HEIGHT_SELECT</name>
              <description>000 keep all pixel for height
001 keep 1 for every 2 pixel for height
010 keep 1 for every 3 pixel for height
011 keep 1 for every 4 pixel for height
100 keep 1 for every 5 pixel for height
101 keep 1 for every 6 pixel for height
110 keep 1 for every 7 pixel for height
111 keep 1 for every 8 pixel for height</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCALE_WIDTH_SELECT</name>
              <description>000 keep all pixel for width
001 keep 1 for every 2 pixel for width
010 keep 1 for every 3 pixel for width
011 keep 1 for every 4 pixel for width
100 keep 1 for every 5 pixel for width
101 keep 1 for every 6 pixel for width
110 keep 1 for every 7 pixel for width
111 keep 1 for every 8 pixel for width</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SIZE</name>
          <description>actual size</description>
          <addressOffset>0x49c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACT_HEIGHT</name>
              <description>actual height after scale and/or roi</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_WIDTH</name>
              <description>actual width after scale and/or roi</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VSYNC_VALID_CNT</name>
          <description>vsync valid counter</description>
          <addressOffset>0x4a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VSYNC_VALID_CNT</name>
              <description>vsync valid counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSYNC_VALID_CNT</name>
          <description>hsync valid counter</description>
          <addressOffset>0x4a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSYNC_VALID_CNT</name>
              <description>hsync valid counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VALID_MARGIN</name>
          <description>valid margin</description>
          <addressOffset>0x4a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSYNC_VALID_MARGIN</name>
              <description>hsync valid margin</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC_VALID_MARGIN</name>
              <description>vsync valid margin</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_SET</name>
          <description>alarm set</description>
          <addressOffset>0x4ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SIG_NORMAL</name>
              <description>define signal duty cycles(base clock)
0x0: disable signal
0x1:  high 1, low 15
0x2:  high 2, low 14
...
0xF:   high 15, low 1</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FATAL_NORMAL</name>
              <description>define signal duty cycles(base clock)
0x0: disable signal
0x1:  high 1, low 15
0x2:  high 2, low 14
...
0xF:   high 15, low 1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_DIV</name>
              <description>frequency division</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="CAM0">
      <name>CAM1</name>
      <description>CAM1</description>
      <groupName>CAM</groupName>
      <baseAddress>0xf100c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PDMA</name>
      <description>PDMA</description>
      <groupName>PDMA</groupName>
      <baseAddress>0xf1010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xc0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARQOS</name>
              <description>QoS for AXI read bus</description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AWQOS</name>
              <description>QoS for AXI write bus</description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PACK_DIR</name>
              <description>Decide the byte sequence of the 32-bit output word {A3, A2, A1, A0}. The bit sequence ina byte is not changed.
2'b00: no change {A3, A2, A1, A0}
2'b01: {A2, A3, A0, A1}
2'b10: {A1, A0, A3, A2}
2'b11: {A0, A1, A2, A3}</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXIERR_IRQ_EN</name>
              <description>Enable interrupt of AXI bus error</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_DONE_IRQ_EN</name>
              <description>Enable interrupt of PDMA_DONE</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKGATE</name>
              <description>Assert this bit to gate off clock when the module is not working. If reset to zero, the internal clock is always on.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_EN</name>
              <description>Enable normal interrupt</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BS16</name>
              <description>Asserted when the Block Size is 16x16, else 8x8</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>P1_EN</name>
              <description>Plane 1 Enable</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>P0_EN</name>
              <description>Plane 0 Enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_SFTRST</name>
              <description>Software Reset.
Write 1 to clear PDMA internal logic.
Write 0 to exit software reset mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_EN</name>
              <description>1b - Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCKY</name>
              <description>Y block that is processing</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKX</name>
              <description>X block that is processing</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PDMA_DONE</name>
              <description>PDMA one image done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AXI_ERR_ID</name>
              <description>AXI error ID</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_0_WRITE_ERR</name>
              <description>AXI0 write err</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AXI_1_READ_ERR</name>
              <description>AXI1 read err</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AXI_0_READ_ERR</name>
              <description>AXI0 read err</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>Asserted to indicate a IRQ event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OUT_CTRL</name>
          <description>Out Layer Control Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFBF</resetMask>
          <fields>
            <field>
              <name>DSTALPHA</name>
              <description>The destination (P1) system ALPHA value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRCALPHA</name>
              <description>The source (P0) system ALPHA value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSTALPHA_OP</name>
              <description>The usage of the DSTALPHA[7:0]: (The system alpha value is not the data valid mask, the non-zero alpha value per pixel embedded in the stream indicates a valid pixel. If no such per pixel alpha value, it means all the pixels are valid)
0: the DSTALPHA[7:0] is invalid, use the alpha value embedded in the stream
1: the DSTALPHA[7:0] is used to override the alpha value embedded in the stream.  (useful when the corresponding data stream has no alpha info)
2: the DSTALPHA[7:0] is used to scale the alpha value embedded in the stream
3: don't multiply the color data with any alpha values for blender inputs.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRCALPHA_OP</name>
              <description>The usage of the SRCALPHA[7:0]: (The system alpha value is not the data valid mask, the non-zero alpha value per pixel embedded in the stream indicates a valid pixel. If no such per pixel alpha value, it means all the pixels are valid)
0: the SRCALPHA[7:0] is invalid, use the alpha value embedded in the stream
1: the SRCALPHA[7:0] is used to override the alpha value embedded in the stream .  (useful when the corresponding data stream has no alpha info)
2: the SRCALPHA[7:0] is used to scale the alpha value embedded in the stream
3: don't multiply the color data with any alpha values for blender inputs.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ABLEND_MODE</name>
              <description>Alpha Blending Mode
0: SKBlendMode_Clear (If PS1_CTRL[BKGNDCL4CLR] is asserted, use PS1_BKGRND color to fill the range determined by PS1, else fill the range determined by PS1 with zero);
1: SKBlendMode_Src ;
2: SKBlendMode_Dst
3: SKBlendMode_SrcOver
4: SKBlendMode_DstOver
5: SKBlendMode_SrcIn
6: SKBlendMode_DstIn
7: SKBlendMode_SrcOut
8: SKBlendMode_DstOut
9: SKBlendMode_SrcATop
10: SKBlendMode_DstATop
11: SKBlendMode_Xor
12: SKBlendMode_Plus    (The conventional belding mode)
13: SKBlendMode_Modulate
14: SRC org
15: DST org
Others: Reserved.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NORM_OUT</name>
              <description>Asserted to normalize the output color channels with alpha channels</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORMAT</name>
              <description>Output buffer format.
0x0 ARGB8888 - 32-bit pixles, byte sequence as B,G,R,A
0xE RGB565 - 16-bit pixels, byte sequence as B,R
0x12 UYVY1P422 - 16-bit pixels (1-plane , byte sequence as U0,Y0,V0,Y1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OUT_BUF</name>
          <description>Output buffer address</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Current address pointer for the output frame buffer. The address can have any byte alignment. 64B alignment is recommended for optimal performance.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OUT_PITCH</name>
          <description>Outlayer Pitch Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>BYTELEN</name>
              <description>Indicates the number of bytes in memory between two vertically adjacent pixels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OUT_LRC</name>
          <description>Output Lower Right Corner Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>Y</name>
              <description>This field indicates the lower right Y-coordinate (in pixels) of the output frame buffer.
The value is the height of the output image size.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>X</name>
              <description>This field indicates the lower right X-coordinate (in pixels) of the output frame buffer.
Should be the width of the output image size.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>OUT_PS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c</addressOffset>
          <register>
            <name>ULC</name>
            <description>Layer Upper Left Corner Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFF3FFF</resetMask>
            <fields>
              <field>
                <name>Y</name>
                <description>This field indicates the upper left Y-coordinate (in pixels) of the processed surface in the output frame buffer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>X</name>
                <description>This field indicates the upper left X-coordinate (in pixels) of the processed surface in the output frame buffer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LRC</name>
            <description>Layer Lower Right Corner Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFF3FFF</resetMask>
            <fields>
              <field>
                <name>Y</name>
                <description>This field indicates the lower right Y-coordinate (in pixels) of the processed surface in the output frame buffer.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>X</name>
                <description>This field indicates the lower right X-coordinate (in pixels) of the processed surface in the output frame buffer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x30</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>PS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x30</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Layer Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x011FFFFF</resetMask>
            <fields>
              <field>
                <name>PL_ONLY_BLENDOP</name>
                <description>1: For those pixels that are this plane-only, use the colcor values and alpha values directly as blender output for un-normalized outputs configurations.
0: For those pixels that are this plane-only, the operations are determined by other operation configurations.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>INB13_SWAP</name>
                <description>Swap bit[31:24] and bit [15:8] before pack_dir operation.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PACK_DIR</name>
                <description>Decide the byte sequence of the 32-bit word {A3, A2, A1, A0}. The bit sequence ina byte is not changed.
2'b00: no change {A3, A2, A1, A0}
2'b01: {A2, A3, A0, A1}
2'b10: {A1, A0, A3, A2}
2'b11: {A0, A1, A2, A3}</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BKGCL4CLR</name>
                <description>Enable to use background color for clear area</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>YCBCR_MODE</name>
                <description>YCbCr mode or YUV mode</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS</name>
                <description>Asserted to bypass the CSC stage</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VFLIP</name>
                <description>Indicates that the input should be flipped vertically (effect applied before rotation).</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HFLIP</name>
                <description>Indicates that the input should be flipped horizontally (effect applied before rotation).</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ROTATE</name>
                <description>Indicates the clockwise rotation to be applied at the input buffer. The rotation effect is defined as occurring
after the FLIP_X and FLIP_Y permutation.
0x0 ROT_0
0x1 ROT_90
0x2 ROT_180
0x3 ROT_270</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DECY</name>
                <description>Verticle pre decimation filter control.
0x0 DISABLE - Disable pre-decimation filter.
0x1 DECY2  - Decimate PS by 2.
0x2 DECY4 - Decimate PS by 4.
0x3 DECY8 - Decimate PS by 8.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DECX</name>
                <description>Horizontal pre decimation filter control.
0x0 DISABLE - Disable pre-decimation filter.
0x1 DECX2 - Decimate PS by 2.
0x2 DECX4 - Decimate PS by 4.
0x3 DECX8 - Decimate PS by 8.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HW_BYTE_SWAP</name>
                <description>Swap bytes in half-words. For each 16 bit half-word, the two bytes will be swapped.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FORMAT</name>
                <description>PS buffer format. To select between YUV and YCbCr formats, see bit 16 of this register.
0x0 ARGB888 - 32-bit pixels, byte sequence as B,G,R,A
0xE RGB565 - 16-bit pixels, byte sequence as B,R
0x13 YUYV1P422 - 16-bit pixels (1-plane byte sequence Y0,U0,Y1,V0 interleaved bytes)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUF</name>
            <description>Layer data buffer address</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address pointer for the PS RGB or Y (luma) input buffer.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PITCH</name>
            <description>Layer data pitch register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>BYTELEN</name>
                <description>Indicates the number of bytes in memory between two vertically adjacent pixels.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BKGD</name>
            <description>Layer background color register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COLOR</name>
                <description>Background color (in 32bpp format) for any pixels not within the scaled range of the picture, but within the buffer range specified by the PS ULC/LRC. The top 8-bit is the alpha channel.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SCALE</name>
            <description>Layer scale register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x7FFF7FFF</resetMask>
            <fields>
              <field>
                <name>Y</name>
                <description>This is a two bit integer and 12 bit fractional representation (##.####_####_####) of the X scaling factor for the PS source buffer. The maximum value programmed should be 2 since scaling down by a factor greater than 2 is not supported with the bilinear filter. Decimation and the bilinear filter should be used together to achieve scaling by more than a factor of 2.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>X</name>
                <description>This is a two bit integer and 12 bit fractional representation (##.####_####_####) of the Y scaling factor for the PS source buffer. The maximum value programmed should be 2 since scaling down by a factor greater than 2 is not supported with the bilinear filter. Decimation and the bilinear filter should be used together to achieve scaling by more than a factor of 2.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OFFSET</name>
            <description>Layer offset register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0FFF0FFF</resetMask>
            <fields>
              <field>
                <name>Y</name>
                <description>This is a 12 bit fractional representation (0.####_####_####) of the Y scaling offset. This represents a fixed pixel offset which gets added to the scaled address to determine source data for the scaling engine.
It is applied after the decimation filter stage, and before the bilinear filter stage.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>X</name>
                <description>This is a 12 bit fractional representation (0.####_####_####) of the X scaling offset. This represents a fixed pixel offset which gets added to the scaled address to determine source data for the scaling engine.
It is applied after the decimation filter stage, and before the bilinear filter stage.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLRKEY_LOW</name>
            <description>Layer low color key register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>LIMIT</name>
                <description>Low range of color key applied to PS buffer. To disable PS colorkeying, set the low colorkey to 0xFFFFFF and the high colorkey to 0x000000.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLRKEY_HIGH</name>
            <description>Layer high color key register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>LIMIT</name>
                <description>High range of color key applied to PS buffer. To disable PS colorkeying, set the low colorkey to 0xFFFFFF and the high colorkey to 0x000000</description>
                <bitOffset>0</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ORG</name>
            <description>Layer original size register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFF3FFF</resetMask>
            <fields>
              <field>
                <name>HIGHT</name>
                <description>The number of vertical pixels of the original frame (not -1)</description>
                <bitOffset>16</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>The number of horizontal pixels of the original frame (not -1)</description>
                <bitOffset>0</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>YUV2RGB_COEF0</name>
          <description>YUV2RGB coefficients register 0</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>C0</name>
              <description>Two's compliment Y multiplier coefficient C0. YUV=0x100 (1.000) YCbCr=0x12A (1.164)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_OFFSET</name>
              <description>Two's compliment phase offset implicit for CbCr data UV_OFFSET. Generally used for YCbCr to RGB conversion.
YCbCr=0x180, YUV=0x000 (typically -128 or 0x180 to indicate normalized -0.5 to 0.5 range).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_OFFSET</name>
              <description>Two's compliment amplitude offset implicit in the Y data Y_OFFSET. For YUV, this is typically 0 and for YCbCr, this is
typically -16 (0x1F0).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>YUV2RGB_COEF1</name>
          <description>YUV2RGB coefficients register 1</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FF07FF</resetMask>
          <fields>
            <field>
              <name>C1</name>
              <description>Two's compliment Red V/Cr multiplier coefficient C1. YUV=0x123 (1.140) YCbCr=0x198 (1.596).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C4</name>
              <description>Two's compliment Blue U/Cb multiplier coefficient C4. YUV=0x208 (2.032) YCbCr=0x204 (2.017).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>YUV2RGB_COEF2</name>
          <description>YUV2RGB coefficients register 2</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FF07FF</resetMask>
          <fields>
            <field>
              <name>C2</name>
              <description>Two's compliment Green V/Cr multiplier coefficient C2. YUV=0x76B (-0.581) YCbCr=0x730 (-0.813).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C3</name>
              <description>Two's compliment Green U/Cb multiplier coefficient C3. YUV=0x79C (-0.394) YCbCr=0x79C (-0.392).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF0</name>
          <description>RGB2YUV coefficients register 0</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>YCBCR_MODE</name>
              <description>Asserted to use YCrCb mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Asserted to enable this RGB2YUV CSC stage</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C0</name>
              <description>CSC parameters C0</description>
              <bitOffset>18</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_OFFSET</name>
              <description>CSC parameters UV_OFFSET</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_OFFSET</name>
              <description>CSC parameters Y_OFFSET</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF1</name>
          <description>RGB2YUV coefficients register 1</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FF07FF</resetMask>
          <fields>
            <field>
              <name>C1</name>
              <description>CSC parameters C1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C4</name>
              <description>CSC parameters C4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF2</name>
          <description>RGB2YUV coefficients register 2</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FF07FF</resetMask>
          <fields>
            <field>
              <name>C2</name>
              <description>CSC parameters C2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C3</name>
              <description>CSC parameters C3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF3</name>
          <description>RGB2YUV coefficients register 3</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FF07FF</resetMask>
          <fields>
            <field>
              <name>C6</name>
              <description>CSC parameters C6</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C5</name>
              <description>CSC parameters C5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF4</name>
          <description>RGB2YUV coefficients register 4</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07FF07FF</resetMask>
          <fields>
            <field>
              <name>C8</name>
              <description>CSC parameters C8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C7</name>
              <description>CSC parameters C7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>JPEG</name>
      <description>JPEG</description>
      <groupName>JPEG</groupName>
      <baseAddress>0xf1014000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xa0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>InDMA_MISC</name>
          <description>In DMA Misc Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>ARQOS</name>
              <description>QoS for AXI read channel</description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OT</name>
              <description>max_ot when input are RGB pixels.
For 16 bits per pixel, it can be set as 4.
For 32 bits per pixel, it will be set as 2.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INB13_SWAP</name>
              <description>Swap bit[31:24] and bit [15:8] before pack dir operation. Only work for pixel data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PACK_DIR</name>
              <description>Decide the byte sequence of the 32-bit word {A3, A2, A1, A0}. The bit sequence in a byte is not changed. Only work for pixel data.
2'b00: no change {A3, A2, A1, A0}
2'b01: {A2, A3, A0, A1}
2'b10: {A1, A0, A3, A2}
2'b11: {A0, A1, A2, A3}</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INDMA_RENEW</name>
              <description>Renew In DMA. Default is to continue the write address counter when a new DMA request comes. Asserted to reset the write address counter.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_IRQ_EN</name>
              <description>In DMA Next Interrupt Enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DMA_DONE_IRQ_EN</name>
              <description>In DMA Done enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXI_ERR_IRQ_EN</name>
              <description>In DMA axi bus error inetrrupt enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_EN</name>
              <description>interrupt enable for all interrupt sources of In DMA module</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DMA_ID</name>
              <description>0: Pixel (In)
1: ECS (In)
2: Qmem
3: HuffEnc
4: HuffMin
5: HuffBase
6: HuffSymb</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DMA_REQ</name>
              <description>Asserted to request DMA. Automatically clear after DMA is done.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INDMA2D</name>
              <description>Asserted if In_DMA_ID=Pixel.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>InDMABase</name>
          <description>In DMA Buf Address</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Y plane (or Encoded Bit Plane)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>InDMA_Ctrl0</name>
          <description>In DMA Buf Control 0 Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTLEN</name>
              <description>Total length (Low 16 bits) in Bytes -1 for transfer when  In_DMA_ID!=Pixel.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PITCH</name>
              <description>Pitch between the starting point of Rows. Only active when  In_DMA_ID=Pixel..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>InDMA_Ctrl1</name>
          <description>In DMA Buf Control 1 Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ROWLEN</name>
              <description>Total length (High 16 bits) in Bytes -1 for transfer. See reference in InDMA_Ctrl0[TTLEN]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INXT_CMD</name>
          <description>In DMA Next Command Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The address pointing to the next command</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_VALID</name>
              <description>asserted if there is either a DATA DMA phase or NXTCMD phase. Automatically cleared. Will trigger the InDMA transfer if CFG[JPEG_EN] is 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>NXTCMD phase Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OutDMA_MISC</name>
          <description>Out DMA Misc Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFC</resetMask>
          <fields>
            <field>
              <name>AWQOS</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PACK_DIR</name>
              <description>Decide the byte sequence of the 32-bit word {A3, A2, A1, A0}. The bit sequence in a byte is not changed. All outdma data are impacted.
2'b00: no change {A3, A2, A1, A0} (This is used for ecs stream)
2'b01: {A2, A3, A0, A1}
2'b10: {A1, A0, A3, A2}
2'b11: {A0, A1, A2, A3}</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_OUTCNT</name>
              <description>Enable output counter (unit as bytes)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INI_OUTCNT</name>
              <description>Asserted to ini output counter</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADD_ODMA_ENDINGS</name>
              <description>Add 0xFFD9 to the ending of the odma stream when all original image pixels are processed by the encoder module.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_IRQ_EN</name>
              <description>Out DMA Next Interrupt Enable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DMA_DONE_IRQ_EN</name>
              <description>Out DMA Done interrupt Enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXI_ERR_IRQ_EN</name>
              <description>Out DMA axi bus error inetrrupt enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_EN</name>
              <description>interrupt enable for all interrupt sources of Out DMA module</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DMA_ID</name>
              <description>0: Pixel (Out)
1: ECS (Out)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DMA_REQ</name>
              <description>Asserted to enable Out DMA request</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTDMA2D</name>
              <description>Asserted if Out_DMA_ID==Pixel</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OutDMABase</name>
          <description>Out DMA Buf Address</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Y plane (or Encoded Bit Plane)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OutDMA_Ctrl0</name>
          <description>Out DMA Buf Control 0 Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTLEN</name>
              <description>Total length (Low 16 bits) in Bytes -1 for transfer when  Out_DMA_ID!=Pixel.  If Out_DMA_ID=ECS, it can be any value greater than the length of the ECS, for example, the number of encoded bytes.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PITCH</name>
              <description>Pitch between the starting point of Rows when Out_DMA_ID==Pixel</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OutDMA_Ctrl1</name>
          <description>Out DMA Buf Control 1 Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ROWLEN</name>
              <description>Total length (High 16 bits) in Bytes -1 for transfer. See reference in OutDMA_Ctrl0[TTLEN]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ONXT_CMD</name>
          <description>Out DMA Next Command Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The address pointing to the next command</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_VALID</name>
              <description>asserted if there is either a DATA DMA phase or NXTCMD phase. Automatically cleared. Will trigger the OutDMA and NXTCMD phase transfer if CFG[JPEG_EN] is 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>NXTCMD phase Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <description>Configuration Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>JD_UVSWAP</name>
              <description>Normally the default CbCr sequence is that Cb macro block coming before Cr macro blk. If Cr macro block is first, set this bit to 1'b1. This bit only impact the color space conversion from/to RGB.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG_IPATH_SEL</name>
              <description>2'b0:2-plane (Y- and UV- plane) or 1-plane (Y-only) as determined by the original data, byte sequence as Y0,Y1, or U,V
2'b01:ARGB8888, byte sequence as B,G,R,A
2'b10:RGB565, byte sequence as B,R
2'b11: YUV422H, byte sequence as Y0,U0,Y1,V0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CODEC_OVER_IRQ_EN</name>
              <description>The jpg endec process done interrupt enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CODEC_RESTART_ERR_IRQ_EN</name>
              <description>The jpg endec restart error interrupt enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_DEBUG_CLK_SEL</name>
              <description>asserted to use APB clock, so that the memory contents could be read out through APB interface</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKGATE</name>
              <description>Assert this bit to gate off clock when the module is not working. If reset to zero, the internal clock is always on.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG_OPATH_SEL</name>
              <description>2'b0:2-plane (Y- and UV- plane) or 1-plane (Y-only) as determined by the original data, byte sequence as Y0,Y1, or U,V
2'b01:ARGB8888, byte sequence as B,G,R,A
2'b10:RGB565, byte sequence as R,B
2'b11: YUV422H1P, byte sequence as Y0,U0,Y1,V0</description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JDATA_FORMAT</name>
              <description>3'b000: for 420,  hy=2, vy=2, hc=1, vc=1 // 6 sub-blocks per MCU
3'b001: for 422h, hy=2, vy=1, hc=1, vc=1 // 4 sub-blocks per MCU
3'b010: for 422v, hy=1, vy=2, hc=1, vc=1 // 4 sub-blocks per MCU
3'b011: for 444,  hy=1, vy=1, hc=1, vc=1 // 3 sub-blocks per MCU
3'b100: for 400,  hy=2, vy=2, hc=0, vc=0 // 4 sub-blocks  per MCU
Others: Undefined</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JPEG_SFTRST</name>
              <description>Software Reset</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>Asserted if to start a new encoder/decoder conversion.
It will at first stop the inner JPEG module, then reset it, and then re-run it.
It is a different mode from DMA phase mode.
It cannot be configured in the DMA chain descriptor. It should be configured by the core processor.
Auto clear.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>1: decoder, 0:encoder</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JPEG_EN</name>
              <description>1b - Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>Status Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFBFFE</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>When 1 means that the module is busy doing conversion and data transfer.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_ERR_ID</name>
              <description>the axi err id</description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_READ_ERR</name>
              <description>in-dma axi bus error</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_WRITE_ERR</name>
              <description>out-dma axi bus error</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AXI_ERR</name>
              <description>axi bus error</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ONXT_IRQ</name>
              <description>OutDMA next interrupt</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>INXT_IRQ</name>
              <description>InDMA next interrupt</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OUT_DMA_TRANSFER_DONE</name>
              <description>OutDMA process done</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IN_DMA_TRANSFER_DONE</name>
              <description>InDMA process done</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CODEC_OVER</name>
              <description>Coding or decoding process is over. DMA is not included.
The module is completely not busy only when in_dma_transfer_done and out_dma_transfer_done, and codec_over are all asserted.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RESTART_MARKER_ERROR</name>
              <description>codec restart marker error interrupt</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Width</name>
          <description>Image width register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMG</name>
              <description>Image Width (it is the max index of pixel counting from 0, assuming the top left pixel is indexed as [0,0])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>Height</name>
          <description>Image height register</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMG</name>
              <description>Image Height  (it is the max index of pixel counting from 0, assuming the top left pixel is indexed as [0,0])</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BufAddr</name>
          <description>Buf Access Addr</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>ADDR[31:28] denotes the buffer type:
0x2: Qmem
0x3: HuffEnc
0x4: HuffMin
0x5: HuffBase
0x6: HuffSymb
ADDR[27:0] is the address inside the buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BufData</name>
          <description>Buf Access Data</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>The data write-to/read-from buffer.
The n-th address read will be actually the data written for n-1 th address, and the actual stored location is n-1 th address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OutDMACnt</name>
          <description>Out DMA Bytes Counter</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>The out DMA counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSC_COEF0</name>
          <description>YUV2RGB coefficients Register 0</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>YCBCR_MODE</name>
              <description>This bit changes the behavior when performing U/V converting.
0b - Converting YUV to RGB data
1b - Converting YCbCr to RGB data</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable the CSC unit.
0b - The CSC is bypassed
1b - The CSC is enabled</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C0</name>
              <description>Two's compliment Y multiplier coefficient C0. YUV=0x100 (1.000) YCbCr=0x12A (1.164)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_OFFSET</name>
              <description>Two's compliment phase offset implicit for CbCr data UV_OFFSET. Generally used for YCbCr to RGB conversion.
YCbCr=0x180, YUV=0x000 (typically -128 or 0x180 to indicate normalized -0.5 to 0.5 range).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_OFFSET</name>
              <description>Two's compliment amplitude offset implicit in the Y data Y_OFFSET. For YUV, this is typically 0 and for YCbCr, this is
typically -16 (0x1F0).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSC_COEF1</name>
          <description>YUV2RGB coefficients Register 1</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C1</name>
              <description>Two's compliment Red V/Cr multiplier coefficient C1. YUV=0x123 (1.140) YCbCr=0x198 (1.596).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C4</name>
              <description>Two's compliment Blue U/Cb multiplier coefficient C4. YUV=0x208 (2.032) YCbCr=0x204 (2.017).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSC_COEF2</name>
          <description>YUV2RGB coefficients Register 2</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C2</name>
              <description>Two's compliment Green V/Cr multiplier coefficient C2. YUV=0x76B (-0.581) YCbCr=0x730 (-0.813).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C3</name>
              <description>Two's compliment Green U/Cb multiplier coefficient C3. YUV=0x79C (-0.394) YCbCr=0x79C (-0.392).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF0</name>
          <description>RGB2YUV coefficients Register 0</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>YCBCR_MODE</name>
              <description>Asserted to use YCrCb mode. Must be assigned as 1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Asserted to enable this RGB2YCbCr CSC stage</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C0</name>
              <description>CSC parameters C0</description>
              <bitOffset>18</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_OFFSET</name>
              <description>CSC parameters UV_OFFSET</description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>Y_OFFSET</name>
              <description>CSC parameters Y_OFFSET</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF1</name>
          <description>RGB2YUV coefficients Register 1</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C1</name>
              <description>CSC parameters C1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C4</name>
              <description>CSC parameters C4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF2</name>
          <description>RGB2YUV coefficients Register 2</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C2</name>
              <description>CSC parameters C2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C3</name>
              <description>CSC parameters C3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF3</name>
          <description>RGB2YUV coefficients Register 3</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C6</name>
              <description>CSC parameters C6</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C5</name>
              <description>CSC parameters C5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RGB2YUV_COEF4</name>
          <description>RGB2YUV coefficients Register 4</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>C8</name>
              <description>CSC parameters C8</description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>C7</name>
              <description>CSC parameters C7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ImgReg1</name>
          <description>Image Control Register 1</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>RE</name>
              <description>Encoder Use only.
Asseted to enable the Restart Marker processing. A Restart Marker is inserted in the outputted ECS (Entropy Coded Segment) every NRST+1 MCUs</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NCOL</name>
              <description>Ncol is the number of color components in the image data to process minus 1. For example, for a grayscale image Ncol=0, for an RGB image, Ncol=2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ImgReg2</name>
          <description>Image Control Register 2</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMCU</name>
              <description>Encoder Use only.
The number of NMCU to be generated in encoder mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ImgReg3</name>
          <description>Image Control Register 3</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NRST</name>
              <description>Encoder use only.
It is the number of MCUs between two Restart Markers (if enabled) minus 1. The content of this register is ignored if the Re bit inregister 1 is not set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>Reg40,Reg41,Reg42,Reg43</dimIndex>
          <name>IMGREG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NBLOCK</name>
              <description>Encoder use only.
The number of data units (8x8 blocks of data) of the color componet contained in the MCU minus 1.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QT</name>
              <description>Encoder use only.
The selection of the quantization table.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HA</name>
              <description>Encoder use only.
The selection of the Huffman table for the encoding of the AC coefficients in the data units belonging to the color component.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HD</name>
              <description>Encoder use only.
The selection of the Huffman table for the encoding of the DC coefficients in the data units belonging to the color component.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GWC0</name>
      <description>GWC0</description>
      <groupName>GWC</groupName>
      <baseAddress>0xf1018000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1f0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>glb_ctrl</name>
          <description>control reg</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000081</resetMask>
          <fields>
            <field>
              <name>CLK_POL</name>
              <description>graphic clock polarity.
set to invert input graphic clock</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GWC_EN</name>
              <description>graphic window check enable.
set to enable the whole block</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_mask</name>
          <description>interrupt enable</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000B</resetMask>
          <fields>
            <field>
              <name>MASK_RREEZ</name>
              <description>freeze mask, set to disable changing ERR_MASK and FUNC_MASK.
can only be cleared by system reset</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUNC_MASK</name>
              <description>function interrupt mask</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_MASK</name>
              <description>error interrupt mask</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>irq_sts</name>
          <description>interrupt status</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_STS</name>
              <description>function interrupt status.
it's set when detect two VSYNC signals after the block is enabled(GWC_EN is set)
software write 1 to clear.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERR_STS</name>
              <description>error status, it's OR of GWC_FAIL_STS[15:0]</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GWC_FAIL_STS</name>
              <description>graphic window check fail interrupt status.
will be set if the calculated CRC not equal reference CRC.
one bit for each channel.
software write 1 to clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0xf0</dimIncrement>
          <dimIndex>ch0,ch15</dimIndex>
          <name>CHANNEL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <register>
            <name>cfg0</name>
            <description>config reg 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xCFFF1FFF</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>channel enable</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FREEZE</name>
                <description>freeze config. set to freeze all other config registers for current channel.
can only be cleared by system reset</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>START_ROW</name>
                <description>define the window start row number</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>START_COL</name>
                <description>define the window start column number</description>
                <bitOffset>0</bitOffset>
                <bitWidth>13</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>cfg1</name>
            <description>config reg 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0FFF1FFF</resetMask>
            <fields>
              <field>
                <name>END_ROW</name>
                <description>define the window end row number</description>
                <bitOffset>16</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>END_COL</name>
                <description>define the window end column number</description>
                <bitOffset>0</bitOffset>
                <bitWidth>13</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>refcrc</name>
            <description>reference CRC</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>REF_CRC</name>
                <description>reference CRC
polynomial function:  0x104C11DB7</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>calcrc</name>
            <description>calculated CRC</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CAL_CRC</name>
                <description>calculated CRC for last frame</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="GWC0">
      <name>GWC1</name>
      <description>GWC1</description>
      <groupName>GWC</groupName>
      <baseAddress>0xf101c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MIPI_DSI0</name>
      <description>MIPI_DSI0</description>
      <groupName>MIPI_DSI</groupName>
      <baseAddress>0xf1020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x194</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>version</name>
          <description>version</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x3134302A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>version of DSI</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pwr_up</name>
          <description>power up</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SHUTDOWNZ</name>
              <description>0x0: reset the core
0x1: power up the core</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clkmgr_cfg</name>
          <description>divide lanebyteclk for timeout</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TO_CLK_DIVISION</name>
              <description>the timeout clock division factor for HS to LP and LP to HS transition error</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_ESC_CLK_DIVISION</name>
              <description>the division factor for the TX Escape clock source lanebyteclk</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_vcid</name>
          <description>virtual channel ID for DPI traffic</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>DPI_VCID</name>
              <description>the DPI virtual channel id to the video mode packets</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_color_coding</name>
          <description>dpi color coding</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>LOOSELY18_EN</name>
              <description>when set to 1, this bit activates loosely packed variant to 18-bit configurations</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DPI_COLOR_CODING</name>
              <description>configures the DPI color for video mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_cfg_pol</name>
          <description>the polarity of DPI signals</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>COLORM_ACTIVE_LOW</name>
              <description>configures the color mode pin as active low</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHUTD_ACTIVE_LOW</name>
              <description>configures the shutdown pin as active low</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HSYNC_ACTIVE_LOW</name>
              <description>configures the horizontal synchronism pin as active low</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VSYNC_ACTIVE_LOW</name>
              <description>configures the vertical synchronism pin as active low</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATAEN_ACTIVE_LOW</name>
              <description>configures the data enable pin active low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_lp_cmd_tim</name>
          <description>the timing for low-power commands sent while in video mode</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF00FF</resetMask>
          <fields>
            <field>
              <name>OUTVACT_LPCMD_TIME</name>
              <description>transmission of commands in low-power mode, defines the size in bytes of the largest pachet that can fit in a line during the VSA VBP and VFP;</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INVACT_LPCMD_TIME</name>
              <description>transmission of commands in low-power mode, defines the size in bytes of the largest packet that can fit in a line during the VACT region.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pckhdl_cfg</name>
          <description>configures how EoTp, BTA, CRC and ECC to be used</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>EOTP_TX_LP_EN</name>
              <description>enable the EoTp transmission in low-power</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RX_EN</name>
              <description>enable the crc reception and error reporting</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_RX_EN</name>
              <description>enable the ecc reception error correction and reporting</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BTA_EN</name>
              <description>enable the bus turn-around request</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTP_RX_EN</name>
              <description>enable the EoTp reception</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EOTP_TX_EN</name>
              <description>enable the EoTp transmission in high-speed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gen_vcid</name>
          <description>configures the virtual channel ID of read response to store and return to generic interface</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00030303</resetMask>
          <fields>
            <field>
              <name>GEN_VCID_TX_AUTO</name>
              <description>indicates the generic interface virtual channel identification where generic packet is automatically generated and transmitted</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VCID_TEAR_AUTO</name>
              <description>indicates the virtual channel identification for tear effect by hardware</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VCID_RX</name>
              <description>indicates the generic interface read-back virtual channel identication</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mode_cfg</name>
          <description>configures the mode of operation between video or command mode</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CMD_VIDEO_MODE</name>
              <description>0x0: video mode
0x1: command mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_mode_cfg</name>
          <description>several aspect of video mode operation</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0111FF03</resetMask>
          <fields>
            <field>
              <name>VPG_ORIENTATION</name>
              <description>indicates the color bar orientation :
0x0: vertical mode
0x1: horizontal mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VPG_MODE</name>
              <description>0x0: colorbar
0x1: berpattern, vertical only</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VPG_EN</name>
              <description>enable video mode pattern generator</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_CMD_EN</name>
              <description>enable command transmission only in low-power mode</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_BTA_ACK_EN</name>
              <description>enable the request for an acknowledge response at the end of a frame</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_HFP_EN</name>
              <description>enable the return to low-power inside the HFP period when timing allows</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_HBP_EN</name>
              <description>enable the return to low-power inside the HBP period when timing allows</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VACT_EN</name>
              <description>enable the return to low-power inside the VACT period when timing allows</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VFP_EN</name>
              <description>enable the return to low-power inside the VFP period when timing allows</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VBP_EN</name>
              <description>enable the return to low-power inside the VBP period when timing allows</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_VSA_EN</name>
              <description>enable the return to low-power inside the VSA period when timing allows</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_MODE_TYPE</name>
              <description>indicates the video mode transmission type</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_pkt_size</name>
          <description>configures the video packet size</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>VID_PKT_SIZE</name>
              <description>configures the number of pixels in a single video packet</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_num_chunks</name>
          <description>configures the number of chunks to use</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>VID_NUM_CHUNKS</name>
              <description>configures the number of chunks to be transmitted a line period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_null_size</name>
          <description>configures the size of null packets</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>VID_NULL_SIZE</name>
              <description>configures the number of bytes inside a null packet</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_hsa_time</name>
          <description>configures the video HAS time</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VID_HSA_TIME</name>
              <description>configure the Horizontal synchronism active period in lane byte clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_hbp_time</name>
          <description>configure the video HBP time</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VID_HPB_TIME</name>
              <description>configures the Horizontal back porch period in lane byte clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_hline_time</name>
          <description>configures the overall time for each video line</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FFF</resetMask>
          <fields>
            <field>
              <name>VID_HLINE_TIME</name>
              <description>configures the size of the total line time in lane byte clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vsa_lines</name>
          <description>configures the vsa period</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>VSA_LINES</name>
              <description>configures the verical synchronism active period measured in number of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vbp_lines</name>
          <description>configures the vbp period</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>VBP_LINES</name>
              <description>configures the vertical back porch period measured in number of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vfp_lines</name>
          <description>configures the vfp period</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>VFP_LINIES</name>
              <description>configures the vertical front porch period measured in number of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vactive_lines</name>
          <description>configures the vertical resolution of video</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>V_ACTIVE_LINES</name>
              <description>configures the vertical active period measured in number of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_MODE_CFG</name>
          <description>This register configures several aspect of command mode operation, tearing effect, acknowledge for each packet and the speed mode to transmit each Data Type related to commands.</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x010F7F03</resetMask>
          <fields>
            <field>
              <name>MAX_RD_PKT_SIZE</name>
              <description>This bit configures the maximum read packet size command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCS_LW_TX</name>
              <description>This bit configures the DCS long write packet command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCS_SR_0P_TX</name>
              <description>This bit configures the DCS short read packet with zero parameter command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCS_SW_1P_TX</name>
              <description>This bit configures the DCS short write packet with one parameter command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCS_SW_0P_TX</name>
              <description>This bit configures the DCS short write packet with zero parameter command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_LW_TX</name>
              <description>This bit configures the Generic long write packet command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_SR_2P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_SR_1P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_SR_0P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_SW_2P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_SW_1P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_SW_0P_TX</name>
              <description>This bit configures the Generic short read packet with two parameters command transmission type:
0x0 (HIGHSPEED): Transition type is High Speed
0x1 (LOWPOWER): Transition type is Low Power</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACK_RQST_EN</name>
              <description>When set to 1, this bit enables the acknowledge request after each packet transmission.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEAR_FX_EN</name>
              <description>When set to 1, this bit enables the tearing effect acknowledge request.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gen_hdr</name>
          <description>sets the header for new packets sent using the generic interface</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_WC_MSBYTE</name>
              <description>configures the most significant byte of the header packet's word count for long packets or data 1 for shout packets</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_WC_LSBYTE</name>
              <description>configures the least significant byte of the header packet's word count for long packets or data0 for short packets</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_VC</name>
              <description>configures the virtual channel ID of the header packet</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_DT</name>
              <description>configures the packet data type of the header packet</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gen_pld_data</name>
          <description>sets the payload for packets sent using the generic interface</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GEN_PLD_B4</name>
              <description>indicates byte4 of the packet payload</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B3</name>
              <description>indicates byte3 of the packet payload</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B2</name>
              <description>indicates byte2 of the packet payload</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GEN_PLD_B1</name>
              <description>indicates byte1 of the packet payload</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>cmd_pkt_status</name>
          <description>information about the status of FIFOs related to DBI and Generic interface</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F007F</resetMask>
          <fields>
            <field>
              <name>GEN_BUFF_PLD_FULL</name>
              <description>the full status of the generic payload internal buffer</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_PLD_EMPTY</name>
              <description>the empty status of the generic payload internal buffer</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_CMD_FULL</name>
              <description>the full status of the generic command internal buffer</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_BUFF_CMD_EMPTY</name>
              <description>the empty status of the generic command internal buffer</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_RD_CMD_BUSY</name>
              <description>indicates a read command is issued and the entire response is not sotred in the FIFO</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_R_FULL</name>
              <description>indicates the full status of the generic read payoad FIFO</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_R_EMPTY</name>
              <description>indicates the empty status of the generic read payload FIFO</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_W_FULL</name>
              <description>indicates the full status of the generic write payload FIFO</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_W_EMPTY</name>
              <description>indicates the empty status of the generic write payload FIFO</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_FULL</name>
              <description>indicates the full status of the generic command FIFO</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_EMPTY</name>
              <description>indicates the empty status of the generic command FIFO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>to_cnt_cfg</name>
          <description>configures the trigger timeout errors</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HSTX_TO_CNT</name>
              <description>configures the timeout counter that triggers a high speed transmission timeout contention detection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPRX_TO_CNT</name>
              <description>configures the timeout counter that triggers a low power reception timeout contention detection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>hs_rd_to_cnt</name>
          <description>configures the peripheral response timeout after high speed read operations</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>HS_RD_TO_CNT</name>
              <description>sets a period for which DWC_mipi_dsi_host keeps the link still after sending a high speed read operation;</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>lp_rd_to_cnt</name>
          <description>configures the peripheral response timeout after low-power read operation</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>LP_RD_TO_CNT</name>
              <description>sets a period for which dwc_mipi_dsi_host keeps the link still after sending a low power read operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>hs_wr_to_cnt</name>
          <description>configures the peripheral response timeout after high speed write operations</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>HS_WR_TO_CNT</name>
              <description>sets the period for which dwc_mipi_dsi_host keeps the link still after sending a high speed write operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>lp_wr_to_cnt</name>
          <description>configures the peripheral response timeout after low power write operations</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>LP_WR_TO_CNT</name>
              <description>sets the period for which dsi host keeps the link still after sending a low power write operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>bta_to_cnt</name>
          <description>configures the periphera response timeout after bus turnaround</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>BTA_TO_CNT</name>
              <description>sets the period for which dsi host keeps the link still after completing a bus turnaround.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sdf_3d</name>
          <description>sotres 3d control information for vss packets in video mode</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001003F</resetMask>
          <fields>
            <field>
              <name>SEND_3D_CFG</name>
              <description>set the next vss packet to include 3d control payload in every vss packet</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RIGHT_FIRST</name>
              <description>0x0: left eye is sent first
0x1:right eye is sent first</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SECOND_VSYNC</name>
              <description>defines whether there is a second VSYNC pulse</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORMAT_3D</name>
              <description>defines 3D image format</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_3D</name>
              <description>defines 3D mode on/off</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>lpclk_ctrl</name>
          <description>configures the possibility for using non continuous clock in the clock lane</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>AUTO_CLKLANE_CTRL</name>
              <description>enables the automatic mechanism to stop providing clock in the clock lane</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQUESTCLKHS</name>
              <description>controls the D-PHY PPI txrequestclkhs signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_tmr_lpclk_cfg</name>
          <description>sets the time that dsi host assumes in calculations for the clock lane to switch between high-speed and low-power</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF03FF</resetMask>
          <fields>
            <field>
              <name>PHY_CLKHS2LP_TIME</name>
              <description>configures the maximum time that the d-phy clock lane takes to go from high-speed to low-power transmission</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_CLKLP2HS_TIME</name>
              <description>configures the maximum time that the d-phy clock lane takes to go from low-power to high-speed transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_tmr_cfg</name>
          <description>sets the time that dsi host assumes in calculations for data lanes to switch between hs to lp</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FF03FF</resetMask>
          <fields>
            <field>
              <name>PHY_HS2LP_TIME</name>
              <description>This field configures the maximum time that the D-PHY data
lanes take to go from high-speed to low-power transmission
measured in lane byte clock cycles</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_LP2HS_TIME</name>
              <description>This field configures the maximum time that the D-PHY data
lanes take to go from low-power to high-speed transmission
measured in lane byte clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_rstz</name>
          <description>controls resets and the pll of d-phy</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PHY_FORCEPLL</name>
              <description>when the d-phy is in ulps, enable the d-phy pll</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_ENABLECLK</name>
              <description>enable dphy clock lane</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_RSTZ</name>
              <description>make the dphy in reset state when set to 0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_SHUTDOWNZ</name>
              <description>places the dphy macro in power down mode when set to 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_if_cfg</name>
          <description>configures the number of active lanes</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FF03</resetMask>
          <fields>
            <field>
              <name>PHY_STOP_WAIT_TIME</name>
              <description>configures the minimum time phy needs to stay in stopstate before requesting an highspeed transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>N_LANES</name>
              <description>configures the number of active data lanes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_ulps_ctrl</name>
          <description>configures entering and leaving ulps</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PHY_TXEXITULPSLAN</name>
              <description>ulps mode exit on all active data lanes</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQULPSLAN</name>
              <description>ulps mode request on all active data lanes</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXEXITULPSCLK</name>
              <description>ulps mode exit on clock lane</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TXREQULPSCLK</name>
              <description>ulps mode request on clock lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_tx_triggers</name>
          <description>configures the pins that activate triggers in the d-phy</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PHY_TX_TRIGGERS</name>
              <description>controls the trigger transmissions</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_status</name>
          <description>contains information about the status of the d-phy</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>PHY_ULPSACTIVENOT3LANE</name>
              <description>indicates the status of ulpsactivenot3lane d-phy signal</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE3LANE</name>
              <description>This bit indicates the status of phystopstate3lane D-PHY
signal.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOT2LANE</name>
              <description>This bit indicates the status of ulpsactivenot2lane D-PHY
signa</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE2LANE</name>
              <description>This bit indicates the status of phystopstate2lane D-PHY
signal</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOT1LANE</name>
              <description>This bit indicates the status of ulpsactivenot1lane D-PHY
signal</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE1LANE</name>
              <description>This bit indicates the status of phystopstate1lane D-PHY
signal</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC0LANE</name>
              <description>This bit indicates the status of rxulpsesc0lane D-PHY signa</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOT0LANE</name>
              <description>This bit indicates the status of ulpsactivenot0lane D-PHY
signal</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATE0LANE</name>
              <description>This bit indicates the status of phystopstate0lane D-PHY
signal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ULPSACTIVENOTCLK</name>
              <description>This bit indicates the status of phyulpsactivenotclk D-PHY
signal</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATECLKLANE</name>
              <description>This bit indicates the status of phystopstateclklane D-PHY
signal</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_DIRECTION</name>
              <description>This bit indicates the status of phydirection D-PHY signal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_LOCK</name>
              <description>This bit indicates the status of phylock D-PHY signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_tst_ctrl0</name>
          <description>controls clock and clear pins of the d-phy vendor specific interface</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>PHY_TESTCLK</name>
              <description>reserve</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTCLR</name>
              <description>reserve</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_tst_ctrl1</name>
          <description>controls data and enable pins of the d-phy</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>PHY_TESTEN</name>
              <description>reserve</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_TESTDOUT</name>
              <description>reserve</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_TESTDIN</name>
              <description>reserve</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st0</name>
          <description>controls the status of interrupt</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>DPHY_ERRORS_4</name>
              <description>indicates LP1 contention error ErrContentionLP1 from lane0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_3</name>
              <description>indicates LP0 contention error ErrContentionLP0 from lane0</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_2</name>
              <description>indicates control error ErrControl from lane0</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_1</name>
              <description>indicates ErrSyncEsc low-power data transmission synchronization error from lane 0</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPHY_ERRORS_0</name>
              <description>indicates ErrEsc escape entry error from lane0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_15</name>
              <description>retrives the DSI protocal violation from the acknowledge error report</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_14</name>
              <description>retrives the reserved from the acknowledge error report</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_13</name>
              <description>retrives the invalid transmission length from the acknowledge error report</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_12</name>
              <description>retrieves the dsi vc id invalid from the acknowledge error report</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_11</name>
              <description>retrives the not recongnized dsi data type from the acknowledge error report</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_10</name>
              <description>retrives the checksum error from the acknowledge error report</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR_9</name>
              <description>retrives the ECC error multi-bit from the acknowledge error report</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR8</name>
              <description>retrives the ecc error sigle-bit from the acknowledge error report</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR7</name>
              <description>retrieves the reserved from the acknowledge error report</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR6</name>
              <description>retrieves the false control error fro the acknowledge error report</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR5</name>
              <description>retrives the peripheral timeout error from the acknowledge error report</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR4</name>
              <description>retrives the LP transmit sync error from the acknowledge error report</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR3</name>
              <description>retrives the Escap mode entry command error from the acknowledge error report</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR2</name>
              <description>retrives the EoT sync error from the acknowledge error report</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR1</name>
              <description>retrives the SoT sync error from the acknowledge error report</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACK_WITH_ERR0</name>
              <description>retrives the SoT serror from the acknowledge error report</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st1</name>
          <description>the interrupt source related to timeout etc</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00181FFF</resetMask>
          <fields>
            <field>
              <name>TEAR_REQUEST_ERR</name>
              <description>indicates tear_request has occurred but tear effect is not active in dsi host and device</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_BUFF_PLD_UNDER</name>
              <description>indicates an underflow when reading payload to build dsi packet for video mode</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_RECEV_ERR</name>
              <description>indicates that during a generic interface packet read back, the payload FIFO full</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_RD_ERR</name>
              <description>indicates that during a DCS read data, the payload FIFO becomes empty</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_SEND_ERR</name>
              <description>indicates the payload FIFO become empty when packet build</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_PLD_WR_ERR</name>
              <description>indicates the system tried to write a payload and FIFO is full</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GEN_CMD_WR_ERR</name>
              <description>indicates the system tried to write a command and FIFO is full</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_BPLD_WR_ERR</name>
              <description>indicates the payload FIFO is full during a DPI pixel line storage</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EOPT_ERR</name>
              <description>indicates that the EoTp packet has not been received at the end of the incoming peripheral transmission</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PKT_SIZE_ERR</name>
              <description>indicates that the packet size error has been detected during the packet reception</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_ERR</name>
              <description>indicates that the CRC error has been detected in the reveived packet payload</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_MULTI_ERR</name>
              <description>indicates that the ECC multiple error has been detected in a revieved packet</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_SIGLE_ERR</name>
              <description>indicates that the ECC single error has been detected and corrected in a reveived packet</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TO_LP_TX</name>
              <description>indicates that the low-power reception timeout counter reached the end and contention has been detected</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TO_HS_TX</name>
              <description>indicates that the high-speed transmission timeout counter reached the end and contention has been detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk0</name>
          <description>configures masks for the sources of interrupt that affec int_st0</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>MASK_DPHY_ERRORS_4</name>
              <description>disable LP1 contention error ErrContentionLP1 from lane0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_3</name>
              <description>disable LP0 contention error ErrContentionLP0 from lane0</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_2</name>
              <description>disable control error ErrControl from lane0</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_1</name>
              <description>disable ErrSyncEsc low-power data transmission synchronization error from lane 0</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPHY_ERRORS_0</name>
              <description>disable ErrEsc escape entry error from lane0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_15</name>
              <description>disable the DSI protocal violation from the acknowledge error report</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_14</name>
              <description>disable the reserved from the acknowledge error report</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_13</name>
              <description>disable the invalid transmission length from the acknowledge error report</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_12</name>
              <description>disable the dsi vc id invalid from the acknowledge error report</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_11</name>
              <description>disable the not recongnized dsi data type from the acknowledge error report</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_10</name>
              <description>disable the checksum error from the acknowledge error report</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR_9</name>
              <description>disable the ECC error multi-bit from the acknowledge error report</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR8</name>
              <description>disable the ecc error sigle-bit from the acknowledge error report</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR7</name>
              <description>disable the reserved from the acknowledge error report</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR6</name>
              <description>disable the false control error fro the acknowledge error report</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR5</name>
              <description>disable the peripheral timeout error from the acknowledge error report</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR4</name>
              <description>disable the LP transmit sync error from the acknowledge error report</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR3</name>
              <description>disable the Escap mode entry command error from the acknowledge error report</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR2</name>
              <description>disable the EoT sync error from the acknowledge error report</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR1</name>
              <description>disable the SoT sync error from the acknowledge error report</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ACK_WITH_ERR0</name>
              <description>disable the SoT serror from the acknowledge error report</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk1</name>
          <description>configures masks for int_st1</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00181FFF</resetMask>
          <fields>
            <field>
              <name>MASK_TEAR_REQUEST_ERR</name>
              <description>disable tear_request has occurred but tear effect is not active in dsi host and device</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPI_BUFF_PLD_UNDER</name>
              <description>disable an underflow when reading payload to build dsi packet for video mode</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_RECEV_ERR</name>
              <description>disable that during a generic interface packet read back, the payload FIFO full</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_RD_ERR</name>
              <description>disable that during a DCS read data, the payload FIFO becomes empty</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_SEND_ERR</name>
              <description>disable the payload FIFO become empty when packet build</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_PLD_WR_ERR</name>
              <description>disable the system tried to write a payload and FIFO is full</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_GEN_CMD_WR_ERR</name>
              <description>disable the system tried to write a command and FIFO is full</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_DPI_BPLD_WR_ERR</name>
              <description>disable the payload FIFO is full during a DPI pixel line storage</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_EOPT_ERR</name>
              <description>disable that the EoTp packet has not been received at the end of the incoming peripheral transmission</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PKT_SIZE_ERR</name>
              <description>disable that the packet size error has been detected during the packet reception</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_CRC_ERR</name>
              <description>disable that the CRC error has been detected in the reveived packet payload</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ECC_MULTI_ERR</name>
              <description>disable that the ECC multiple error has been detected in a revieved packet</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_ECC_SIGLE_ERR</name>
              <description>disable that the ECC single error has been detected and corrected in a reveived packet</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_TO_LP_TX</name>
              <description>disable that the low-power reception timeout counter reached the end and contention has been detected</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_TO_HS_TX</name>
              <description>disable that the high-speed transmission timeout counter reached the end and contention has been detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_cal</name>
          <description>controls the skew calibration of D-phy</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>TXSKEWCALHS</name>
              <description>High-speed skew calibration is started when txskewcalhs is
set high (assuming that PHY is in Stop state)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force0</name>
          <description>forces that affect the int_st0 register</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_DPHY_ERRORS_4</name>
              <description>force LP1 contention error ErrContentionLP1 from lane0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_3</name>
              <description>force LP0 contention error ErrContentionLP0 from lane0</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_2</name>
              <description>force control error ErrControl from lane0</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_1</name>
              <description>force ErrSyncEsc low-power data transmission synchronization error from lane 0</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPHY_ERRORS_0</name>
              <description>force ErrEsc escape entry error from lane0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_15</name>
              <description>force the DSI protocal violation from the acknowledge error report</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_14</name>
              <description>force the reserved from the acknowledge error report</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_13</name>
              <description>force the invalid transmission length from the acknowledge error report</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_12</name>
              <description>force the dsi vc id invalid from the acknowledge error report</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_11</name>
              <description>force the not recongnized dsi data type from the acknowledge error report</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_10</name>
              <description>force the checksum error from the acknowledge error report</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR_9</name>
              <description>force the ECC error multi-bit from the acknowledge error report</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR8</name>
              <description>force the ecc error sigle-bit from the acknowledge error report</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR7</name>
              <description>force the reserved from the acknowledge error report</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR6</name>
              <description>force the false control error fro the acknowledge error report</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR5</name>
              <description>force the peripheral timeout error from the acknowledge error report</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR4</name>
              <description>force the LP transmit sync error from the acknowledge error report</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR3</name>
              <description>force the Escap mode entry command error from the acknowledge error report</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR2</name>
              <description>force the EoT sync error from the acknowledge error report</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR1</name>
              <description>force the SoT sync error from the acknowledge error report</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ACK_WITH_ERR0</name>
              <description>force the SoT serror from the acknowledge error report</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force1</name>
          <description>forces interrupts that affect the int_st1 register</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00181FFF</resetMask>
          <fields>
            <field>
              <name>FORCE_TEAR_REQUEST_ERR</name>
              <description>force tear_request has occurred but tear effect is not active in dsi host and device</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPI_BUFF_PLD_UNDER</name>
              <description>force an underflow when reading payload to build dsi packet for video mode</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_RECEV_ERR</name>
              <description>force that during a generic interface packet read back, the payload FIFO full</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_RD_ERR</name>
              <description>force that during a DCS read data, the payload FIFO becomes empty</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_SEND_ERR</name>
              <description>force the payload FIFO become empty when packet build</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_PLD_WR_ERR</name>
              <description>force the system tried to write a payload and FIFO is full</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_GEN_CMD_WR_ERR</name>
              <description>force the system tried to write a command and FIFO is full</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DPI_BPLD_WR_ERR</name>
              <description>force the payload FIFO is full during a DPI pixel line storage</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_EOPT_ERR</name>
              <description>force that the EoTp packet has not been received at the end of the incoming peripheral transmission</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PKT_SIZE_ERR</name>
              <description>force that the packet size error has been detected during the packet reception</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_CRC_ERR</name>
              <description>force that the CRC error has been detected in the reveived packet payload</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ECC_MULTI_ERR</name>
              <description>force that the ECC multiple error has been detected in a revieved packet</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ECC_SIGLE_ERR</name>
              <description>force that the ECC single error has been detected and corrected in a reveived packet</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_TO_LP_TX</name>
              <description>force that the low-power reception timeout counter reached the end and contention has been detected</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_TO_HS_TX</name>
              <description>force that the high-speed transmission timeout counter reached the end and contention has been detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_tmr_rd</name>
          <description>configures times related to PHY to perform some operations in lane byte clock cycle</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FFF</resetMask>
          <fields>
            <field>
              <name>MAX_RD_TIME</name>
              <description>the maximum time required to perform a read command in lane byte clock cycles.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>auto_ulps_min_time</name>
          <description>configures the minimum time required by phy between ulpsactivenot and ulpsexitreq for clock and data lane</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>ULPS_MIN_TIME</name>
              <description>configures the minimum time required by phy between ulpsactivenot and ulpsexitreq for clock and data lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_mode</name>
          <description>select phy mode</description>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>PHY_MODE</name>
              <description>sel DPHY or CPHY</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_shadow_ctrl</name>
          <description>controls dpi shadow feature</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010101</resetMask>
          <fields>
            <field>
              <name>VID_SHADOW_PIN_REQ</name>
              <description>when set to 1, the video request is done by external pin</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_SHADOW_REQ</name>
              <description>when set to 1, request that the dpi register from regbank are copied to the auxiliary registers</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VID_SHADOW_EN</name>
              <description>when set to 1, DPI receives the active configuration from the auxiliary register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_vcid_act</name>
          <description>holds the value that controller is using for DPI_VCID</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>DPI_VCID</name>
              <description>specifies the DPI virtual channel id that is indexed to the video mode packets</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_color_coding_act</name>
          <description>holds the value that controller is using for DPI_COLOR_CODING</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000010F</resetMask>
          <fields>
            <field>
              <name>LOOSELY18_EN</name>
              <description>avtivates loosely packed variant to 18-bit configuration</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIP_COLOR_CODING</name>
              <description>configures the DPI color for video mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dpi_lp_cmd_tim_act</name>
          <description>holds value that controller is using for dpi_lp_cmd_time</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF00FF</resetMask>
          <fields>
            <field>
              <name>OUTVACT_LPCMD_TIME</name>
              <description>transmission of commands in low-power mode, it specifies the size in bytes of the lagest packet that can fit in a line during the VSA VBP and VFP regions.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INVACT_LPCMD_TIME</name>
              <description>transmission of commands in low-power mode, it specifies the size in bytes of the lagest packet that can fit in a line during the vact regions.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_mode_cfg_act</name>
          <description>holds value that controller is using for vid_mode_cfg</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>LP_CMD_EN</name>
              <description>enable the command transmission only in low-power mode</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_BTA_ACK_EN</name>
              <description>enable the request for an acknowledge response at the end of a frame</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_HFP_EN</name>
              <description>enable the returne to low-power inside the HFP period when timing allows</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_HBP_EN</name>
              <description>enable the returne to low-power inside the HBP period when timing allows</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VACT_EN</name>
              <description>enable the returne to low-power inside the VACT period when timing allows</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VFP_EN</name>
              <description>enable the returne to low-power inside the VFP period when timing allows</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VBP_EN</name>
              <description>enable the returne to low-power inside the VBP period when timing allows</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LP_VSA_EN</name>
              <description>enable the returne to low-power inside the VSA period when timing allows</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VID_MODE_TYPE</name>
              <description>specifies the video mode transmission type</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_pkt_size_act</name>
          <description>holds value that controller is using for vid_pkt_size</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>VID_PKT_SIZE</name>
              <description>the number of pixels in a single video packet</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_num_chunks_act</name>
          <description>holds value that controller is using for vid_num_chunks</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>VID_NUM_CHUNKS</name>
              <description>the number of chunks to be transmitted during a line period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_null_size_act</name>
          <description>holds the value that controller is using for vid_null_size</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>VID_NULL_SIZE</name>
              <description>the number of bytes in side a null packet</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_hsa_time_act</name>
          <description>the value of vid_hsa_time</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VID_HSA_TIME</name>
              <description>the horizontal synchronism active period in lane byte clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_hbp_time_act</name>
          <description>the value that controller is using for vid_hbp_time</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VID_HBP_TIME</name>
              <description>the horizontal back porch period in lane byte clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_hline_time_act</name>
          <description>the value for vid_hline_time</description>
          <addressOffset>0x150</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FFF</resetMask>
          <fields>
            <field>
              <name>VID_HLINE_TIME</name>
              <description>the size of total line: hsa+hbp+hact+hfp</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vsa_lines_act</name>
          <description>value for vid_vsa_lines</description>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>VSA_LINES</name>
              <description>vertical synchronism active period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vbp_lines_act</name>
          <description>value for vid_vbp_lines</description>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>VBP_LINES</name>
              <description>vertical back porch period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vfp_lines_act</name>
          <description>value for vid_vfp_lines</description>
          <addressOffset>0x15c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>VFP_LINES</name>
              <description>vertical porch period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_vactive_lines_act</name>
          <description>value for vid_vactive_lines</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>V_ACTIVE_LINES</name>
              <description>vertical active period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vid_pkt_status</name>
          <description>status of fifo related to dpi</description>
          <addressOffset>0x168</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>DPI_BUFF_PLD_FULL</name>
              <description>This bit indicates the full status of the payload internal buffer
for video Mode. This bit is set to 0 for command Mode</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_BUFF_PLD_EMPTY</name>
              <description>This bit indicates the empty status of the payload internal
buffer for video Mode. This bit is set to 0 for command Mod</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_W_FULL</name>
              <description>This bit indicates the full status of write payload FIFO for
video Mode. This bit is set to 0 for command Mode</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_PLD_W_EMPTY</name>
              <description>This bit indicates the empty status of write payload FIFO for
video Mode. This bit is set to 0 for command Mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_CMD_W_FULL</name>
              <description>This bit indicates the full status of write command FIFO for
video Mode. This bit is set to 0 for command Mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DPI_CMD_W_EMPTY</name>
              <description>This bit indicates the empty status of write command FIFO
for video Mode. This bit is set to 0 for command Mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>sdf_3d_act</name>
          <description>value for sdf_3d</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001003F</resetMask>
          <fields>
            <field>
              <name>SEND_3D_CFG</name>
              <description>When set, causes the next VSS packet to include 3D control
payload in every VSS packet.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RIGHT_FIRST</name>
              <description>This bit specifies the left/right order</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SECOND_VSYNC</name>
              <description>This field specifies whether there is a second VSYNC pulse
between Left and Right Images, when 3D Image Format is
Frame-based</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORMAT_3D</name>
              <description>This field specifies 3D Image Format</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE_3D</name>
              <description>This field specifies 3D Mode On/Off and Display Orientation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MIPI_DSI0">
      <name>MIPI_DSI1</name>
      <description>MIPI_DSI1</description>
      <groupName>MIPI_DSI</groupName>
      <baseAddress>0xf1024000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MIPI_CSI0</name>
      <description>MIPI_CSI0</description>
      <groupName>MIPI_CSI</groupName>
      <baseAddress>0xf1028000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2bc</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>version</name>
          <description>version code</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x3134302A</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VERSION</name>
              <description>version code</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>n_lanes</name>
          <description>the number of active lanes</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>N_LANES</name>
              <description>number of active data lanes</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>csi2_resetn</name>
          <description>the internal logic of the controller goes into the reset state when active</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>CSI2_RESETN</name>
              <description>DWC_mipi_csi2_host reset output, active low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_main</name>
          <description>contains the stateus of individual interrupt sources</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000700FF</resetMask>
          <fields>
            <field>
              <name>STATUS_INT_IPI4_FATAL</name>
              <description>status of int_st_ipi_fatal</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_LINE</name>
              <description>status of int_st_line</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PHY</name>
              <description>status of int_st_phy</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_ECC_CORRECTED</name>
              <description>status of status_int_ecc_corrected</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_DATA_ID</name>
              <description>status of status_int_data_id</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PLD_CRC_FATAL</name>
              <description>status of status_int_pld_crc_fatal</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_CRC_FRAME_FATAL</name>
              <description>status of status_int_crc_frame_fatal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_SEQ_FRAME_FATAL</name>
              <description>status of status_int_seq_frame_fatal</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_BNDRY_FRAME_FATAL</name>
              <description>status of int_st_bndry_frame_fatal</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PKT_FATAL</name>
              <description>status of int_st_pkt_fatal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PHY_FATAL</name>
              <description>status of int_st_phy_fatal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>data_ids_1</name>
          <description>programs data type fields for data ID monitors</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F3F</resetMask>
          <fields>
            <field>
              <name>DI3_DT</name>
              <description>data type for programmed data ID 3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI2_DT</name>
              <description>data type for programmed data ID 2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_DT</name>
              <description>data type for programmed data ID 1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_DT</name>
              <description>data type for programmed data ID 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>data_ids_2</name>
          <description>programs data type fields for data ID monitors</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F3F3F3F</resetMask>
          <fields>
            <field>
              <name>DI7_DT</name>
              <description>data type for programmed data ID 7</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI6_DT</name>
              <description>data type for programmed data ID 6</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI5_DT</name>
              <description>data type for programmed data ID 5</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI4_DT</name>
              <description>data type for programmed data ID 4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_ap_main</name>
          <description>contains the status of individual interrupt sources</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001FFF</resetMask>
          <fields>
            <field>
              <name>STATUS_INT_IPI_FATAL</name>
              <description>status of int_st_ipi_fatal</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_ST_AP_IPI_FATAL</name>
              <description>status of int_st_ap_ipi_fatal</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_LINE</name>
              <description>status of int_st_line</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_ECC_CORRECTED</name>
              <description>status of status_int_ecc_corrected</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_DATA_ID</name>
              <description>status of status_int_data_id</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PLD_CRC_FATAL</name>
              <description>status of status_int_pld_crc_fatal</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PHY</name>
              <description>status of int_st_phy</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_CRC_FRAME_FATAL</name>
              <description>status of status_int_crc_frame_fatal</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_SEQ_FRAME_FATAL</name>
              <description>status of status_int_seq_frame_fatal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_BNDRY_FRAME_FATAL</name>
              <description>status of int_st_bndry_frame_fatal</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PKT_FATAL</name>
              <description>status of int_st_pkt_fatal</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_PHY_FATAL</name>
              <description>status of int_st_phy_fatal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>STATUS_INT_ST_AP_GENERIC</name>
              <description>status of int_st_ap_generic</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_shutdownz</name>
          <description>controls the phy shutdown mode</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>PHY_SHUTDOWNZ</name>
              <description>shutdown input,active low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dphy_rstz</name>
          <description>controls the phy reset mode</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>DPHY_RSTZ</name>
              <description>phy reset output, active low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_rx</name>
          <description>contains the status of rx-related signals from phy</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00010000</resetValue>
          <resetMask>0x00030003</resetMask>
          <fields>
            <field>
              <name>PHY_RXCLKACTIVEHS</name>
              <description>indicates the d-phy clock lane is actively receiving a ddr clock</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSCLKNOT</name>
              <description>active low. Indicates the d-phy clock lane module has entered the Ultra low power state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULLPSESC_1</name>
              <description>lane module 1 has entered the ultra low power mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_RXULPSESC_0</name>
              <description>lane module 0 has entered the ultra low power mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_stopstate</name>
          <description>contains the stopstate signal status from phy</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010003</resetMask>
          <fields>
            <field>
              <name>PHY_STOPSTATECLK</name>
              <description>d-phy clock lane in stop state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATEDATA_1</name>
              <description>data lane 1 in stop state</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_STOPSTATEDATA_0</name>
              <description>data lane 0 in stop state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_mode</name>
          <description>selects how the ipi interface generates the video frame</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01010101</resetMask>
          <fields>
            <field>
              <name>IPI_ENABLE</name>
              <description>enables the interface</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_CUT_THROUGH</name>
              <description>cut-through mode state active when high</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_COLOR_COM</name>
              <description>if color mode components are deliverd as follows: 0x0 48bit intercase  0x1: 16bit interface</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_MODE</name>
              <description>indicates the video mode transmission type 0x0: camera timing 0x1:controller timing</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_vcid</name>
          <description>selects the vritual channel processed by ipi</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IPI_VCX_0_1</name>
              <description>virtual channel extension of data to be processed by pixel interface</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IP_VCID</name>
              <description>virtual channel of data to be processed by pixel interface</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_data_type</name>
          <description>selects the data type processed by ipi</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000013F</resetMask>
          <fields>
            <field>
              <name>EMBENDED_DATA</name>
              <description>enable embedded data processing on ipi interface</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DATA_TYPE</name>
              <description>data type of data to be processed by pixel interface</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_mem_flash</name>
          <description>control the flush of ipi memory</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000101</resetMask>
          <fields>
            <field>
              <name>IPI_AUTO_FLUSH</name>
              <description>memory is automatically flashed at each vsync</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_FLUSH</name>
              <description>flush ipi memory, this bit is auto clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_hsa_time</name>
          <description>configures the video horizontal synchronism active time</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>IPI_HSA_TIME</name>
              <description>configures the Horizontal Synchronism Active period in pixclk cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_hbp_time</name>
          <description>configures the video horizontal synchronism back porch time</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>IPI_HBP_TIME</name>
              <description>configures the Horizontal Synchronism back porch period in pixclk cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_hsd_time</name>
          <description>configures the vedeo Horizontal Sync Delay time</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>IPI_HSD_TIME</name>
              <description>configures the Horizontal Sync Porch delay period in pixclk cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_hline_time</name>
          <description>configures the overall tiem for each video line</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00007FFF</resetMask>
          <fields>
            <field>
              <name>IPI_HLIN_TIME</name>
              <description>configures the size of the line time counted in pixclk cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_softrstn</name>
          <description>congtrols the ipi logic reset state</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>IPI_SOFTRSTN</name>
              <description>resets ipi one, active low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_adv_features</name>
          <description>configures advanced features for ipi mode</description>
          <addressOffset>0xac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x013F3F01</resetMask>
          <fields>
            <field>
              <name>IPI_SYNC_EVENT_MODE</name>
              <description>for camera mode: 0x0- frame start do not trigger any sync event</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_EMBEDDED</name>
              <description>allows the use of embendded packets for ipi synchronization events</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_BLANKING</name>
              <description>allows the use of blankong packets for IPI synchronization events</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_NULL</name>
              <description>allows the use of null packets for IPI synchronization events</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LINE_START</name>
              <description>allows the use of line start packets for ipi synchronization events</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_VIDEO</name>
              <description>allows the use of video packets for ipi synchronization events</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_EVENT_SELECTION</name>
              <description>for camero mode, allows manual selection of the packet fo line delimiter as follows: 0x0-controller seletc it automaticlly 0x1-select packets from list programmed in 17:21</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DT</name>
              <description>datatype to overwrite</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPI_DT_OVERWRITE</name>
              <description>ignore datatype of the header using the programmed datatype for decoding</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_vsa_lines</name>
          <description>configures the vertical synchronism active period</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>IPI_VSA_LINES</name>
              <description>configures the vertical synchronism active period measured in number of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_vbp_lines</name>
          <description>configures the verticall back porch period</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>IPI_VBP_LINES</name>
              <description>configuress the vertical back porch period measured in number of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_vfp_lines</name>
          <description>configures the vertical front porch period</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000003FF</resetMask>
          <fields>
            <field>
              <name>IPI_VFP_LINES</name>
              <description>configures the vertical front porch period measured in number of horizontall lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ipi_vactive_lines</name>
          <description>configures the vertical resolution of video</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>IPI_VACTIVE_LINES</name>
              <description>configures the vertical active period measured in bumber of horizontal lines</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>vc_extension</name>
          <description>active extra bits for virtual channel</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>VCX</name>
              <description>indicates status of virtual channel extension: 0-virtual channel extension is enable  1-legacy mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_cal</name>
          <description>contains the calibration signal status from synopsys d-phy</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RXSKEWCALHS</name>
              <description>a low-to-high transition on rxskewcalhs signal means the the phy has  initiated the de-skew calibration</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_phy_fatal</name>
          <description>groups the phy interruptions caused by phy packets discarded</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000103</resetMask>
          <fields>
            <field>
              <name>ERR_DESKEW</name>
              <description>reports whenever data is lost due to an existent skew between lanes greater than 2 rxwordclkhs</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ERRSOTSYNCHS_1</name>
              <description>start of transmission error on data lane1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ERRSOTSYNCHS_0</name>
              <description>start of transmission error on data lane0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_phy_fatal</name>
          <description>interrupt mask for int_st_phy_fatal</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000103</resetMask>
          <fields>
            <field>
              <name>ERR_DESKEW</name>
              <description>mask for err_deskew</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTSYNCHS_1</name>
              <description>mask for phy_errsotsynchs_1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTSYNCHS_0</name>
              <description>mask for phy_errsotsynchs_0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_phy_fatal</name>
          <description>interrupt force register for test purposes</description>
          <addressOffset>0xe8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000103</resetMask>
          <fields>
            <field>
              <name>ERR_DESKEW</name>
              <description>force err_deskew</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTSYNCHS_1</name>
              <description>force phy_errsotsynchs_1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTSYNCHS_0</name>
              <description>force phy_errsotsynchs_0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_pkt_fatal</name>
          <description>groups the fatal interruption related with packet construction</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>ERR_ECC_DOUBLE</name>
              <description>header ecc contains at least 2 errors</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_pkt_fatal</name>
          <description>interrupt mask for int_st_pkt_fatal</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>MASK_ERR_ECC_DOUBLE</name>
              <description>mask for err_ecc_double</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_pkt_fatal</name>
          <description>interrupt force register is used for test purpos</description>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_ECC_DOUBLE</name>
              <description>force err_ecc_double</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_phy</name>
          <description>interruption caused by phy</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00030003</resetMask>
          <fields>
            <field>
              <name>PHY_ERRESC_1</name>
              <description>start of transmission error on data lane 1</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ERRESC_0</name>
              <description>start of transmission error on data lane 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ERRSOTHS_1</name>
              <description>start of transmission error on data lane 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ERRSOTHS_0</name>
              <description>start of transmission error on data lane 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_phy</name>
          <description>interrupt mask for int_st_phy</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00030003</resetMask>
          <fields>
            <field>
              <name>MASK_PHY_ERRESC_1</name>
              <description>mask for phy_erresc_1</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRESC_0</name>
              <description>mask for phy_erresc_0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTHS_1</name>
              <description>mask for phy_errsoths_1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_PHY_ERRSOTHS_0</name>
              <description>mask for phy_errsoths_0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_phy</name>
          <description>interrupt force register</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00030003</resetMask>
          <fields>
            <field>
              <name>FORCE_PHY_ERRESC_1</name>
              <description>force phy_erresc_1</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRESC_0</name>
              <description>force phy_erresc_0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTHS_1</name>
              <description>force phy_errsoths_1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ERRSOTHS_0</name>
              <description>force phy_errsoths_0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_ipi_fatal</name>
          <description>fatal interruption caused by ipi interface</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>INT_EVENT_FIFO_OVERFLOW</name>
              <description>reporting internal fifo overflow</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIXEL_IF_HLINE_ERR</name>
              <description>horizontal line time error</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>the fifo of pixel interface is not empty at the starat of a new frame</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIXEL_IF_FRAME_SYNC_ERR</name>
              <description>whenever in controller mode, notifies if a new frame is received but previous has not been completed</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_OVERFLOW</name>
              <description>the fifo of pixel interface has lost information because some data arrived and fifo is already full</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>the fifo has become empty before the expected bumber of pixels could be extracted to the pixel intefcese</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_ipi_fatal</name>
          <description>interrupt mask for int_st_ipi_fatal</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>MSK_INT_EVENT_FIFO_OVERFLOW</name>
              <description>mask int_event_fifo_overflow</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_HLINE_ERR</name>
              <description>mask pixel_if_hline_err</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>mask pixel_if_fifo_nempty_fs</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_FRAME_SYNC_ERR</name>
              <description>mask for pixel_if_frame_sync_err</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_OVERFLOW</name>
              <description>mask for pixel_if_fifo_overflow</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>mask for pixel_if_fifo_unterflow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_ipi_fatal</name>
          <description>interrupt force register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>FORCE_INT_EVENT_FIFO_OVERFLOW</name>
              <description>force int_event_fifo_overflow</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_HLINE_ERR</name>
              <description>force pixel_if_hline_err</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_NEMPTY_FS</name>
              <description>force pixel_if_fifo_nempty_fs</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_FRAME_SYNC_ERR</name>
              <description>force for frame_sync_err</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_OVERFLOW</name>
              <description>force for pixel_if_fifo_overflow</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIXEL_IF_FIFO_UNDERFLOW</name>
              <description>force for pixel_if_fifo_underflow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_ap_generic</name>
          <description>groups and notifies which interruption bits caused the interruption</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>SYNCHRONIZER_PIXCLK_AP_ERR</name>
              <description>ap error in synchronizer block for pixclk domain</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNCHRONIZER_RXBYTECLKHS_AP_ERR</name>
              <description>ap error in synchronizer block for rxbyteclkhs domain</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNCHRONIZER_FPCLK_AP_ERR</name>
              <description>ap error in synchronizer block for fpclk domain</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_HANDLE_AP_ERR</name>
              <description>ap error in error handler block</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_MSGR_AP_ERR</name>
              <description>ap error in err msgr block</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PREP_OUTS_AP_ERR</name>
              <description>ap error in prepare outs block</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PACKET_ANALYZER_AP_ERR</name>
              <description>ap error in packet analyzer block</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHY_ADAPTER_AP_ERR</name>
              <description>ap error in phy adapter block</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DESCRAMBLER_AP_ERR</name>
              <description>ap error in descrambler block</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIPELINE_DELAY_AP_ERR</name>
              <description>ap error in pipeline delay block</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DE_SKEW_AP_ERR</name>
              <description>ap error in de-skew block</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REG_BANK_AP_ERR</name>
              <description>ap error in register bank block</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>APB_AP_ERR</name>
              <description>ap error in apb block</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_ap_generic</name>
          <description>interrupt mask for int_st_ap_generic</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>MSK_SYNCHRONIZER_PIXCLK_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_SYNCHRONIZER_RXBYTECLKHS_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_SYNCHRONIZER_FPCLK_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_HANDLE_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_MSGR_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PREP_OUTS_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PACKET_ANALYZER_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PHY_ADAPTER_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_DESCRAMBLER_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_PIPELINE_DELAY_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_DE_SKEW_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_REG_BANK_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_APB_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_ap_generic</name>
          <description>interrupt force register used for test purposes</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_SYNCHRONIZER_PIXCLK_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_SYNCHRONIZER_RXBYTECLKHS_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_SYNCHRONIZER_FPCLK_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_HANDLE_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_MSGR_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PREP_OUTS_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PACKET_ANALYZER_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PHY_ADAPTER_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DESCRAMBLER_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_PIPELINE_DELAY_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_DE_SKEW_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_REG_BANK_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_APB_AP_ERR</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_ap_ipi_fatal</name>
          <description>groups and notifies which interruption bits</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>REDUNDANCY_ERR</name>
              <description>ap redundancy error in ipi1</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CRC_ERR</name>
              <description>ap crc error in ipi1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_MULTIPLE_ERR</name>
              <description>ap ecc multiple error in ipi1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_SINGLE_ERR</name>
              <description>ap ecc sigle error in ipi1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_RX_ERR</name>
              <description>ap parity rx error in ipi1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_TX_ERR</name>
              <description>ap parity tx error in ipi1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_ap_ipi_fatal</name>
          <description>interrupt mask for int_st_ap_ipi_fatal controls</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>MASK_REDUNDANCY_ERR</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_CRC_ERR</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_ECC_MULTIPLE_ERR</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_ECC_SINGLE_ERR</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_PARITY_RX_ERR</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MASK_PARITY_TX_ERR</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_ap_ipi_fatal</name>
          <description>interrupt force register</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>FORCE_REDUNDANCY_ERR</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORCE_CRC_ERR</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORCE_ECC_MULTIPLE_ERR</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORCE_ECC_SINGLE_ERR</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORCE_PARITY_RX_ERR</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FORCE_PARITY_TX_ERR</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_bndry_frame_fatal</name>
          <description>fatal interruption related with matching frame start with frame end for a specific virtual channel</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_BNDRY_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_bndry_frame_fatal</name>
          <description>interrupt mask for int_st_bndry_frame_fatal</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_BNDRY_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_bndry_frame_fatal</name>
          <description>interrupt force register is used for test purposes</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_BNDRY_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_seq_frame_fatal</name>
          <description>fatal interruption related with matching frame start with frame end for a specific virtual channel</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_SEQ_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_SEQ_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_seq_frame_fatal</name>
          <description>interrupt mask for int_st_seq_frame_fatal</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_SEQ_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_seq_frame_fatal</name>
          <description>interrupt force register is used for test purposes</description>
          <addressOffset>0x298</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_SEQ_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_crc_frame_fatal</name>
          <description>fatal interruption related with matching frame start with frame end for a specific virtual channel</description>
          <addressOffset>0x2a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ERR_F_CRC_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_F_CRC_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_crc_frame_fatal</name>
          <description>interrupt mask for int_st_crc_frame_fatal</description>
          <addressOffset>0x2a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_F_CRC_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_crc_frame_fatal</name>
          <description>interrupt force register is used for test purposes</description>
          <addressOffset>0x2a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_F_CRC_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_st_pld_crc_frame_fatal</name>
          <description>fatal interruption related with matching frame start with frame end for a specific virtual channel</description>
          <addressOffset>0x2b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ERR_CRC_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERR_CRC_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_msk_pld_crc_frame_fatal</name>
          <description>interrupt mask for int_st_crc_frame_fatal</description>
          <addressOffset>0x2b4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSK_ERR_CRC_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>int_force_pld_crc_frame_fatal</name>
          <description>interrupt force register is used for test purposes</description>
          <addressOffset>0x2b8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC15</name>
              <description>error matching frame start with frame end for virtual channel 15</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC14</name>
              <description>error matching frame start with frame end for virtual channel 14</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC13</name>
              <description>error matching frame start with frame end for virtual channel 13</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC12</name>
              <description>error matching frame start with frame end for virtual channel 12</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC11</name>
              <description>error matching frame start with frame end for virtual channel 11</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC10</name>
              <description>error matching frame start with frame end for virtual channel 10</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC9</name>
              <description>error matching frame start with frame end for virtual channel 9</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC8</name>
              <description>error matching frame start with frame end for virtual channel 8</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC7</name>
              <description>error matching frame start with frame end for virtual channel 7</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC6</name>
              <description>error matching frame start with frame end for virtual channel 6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC5</name>
              <description>error matching frame start with frame end for virtual channel 5</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC4</name>
              <description>error matching frame start with frame end for virtual channel 4</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC3</name>
              <description>error matching frame start with frame end for virtual channel 3</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC2</name>
              <description>error matching frame start with frame end for virtual channel 2</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC1</name>
              <description>error matching frame start with frame end for virtual channel 1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_ERR_CRC_MATCH_VC0</name>
              <description>error matching frame start with frame end for virtual channel 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MIPI_CSI0">
      <name>MIPI_CSI1</name>
      <description>MIPI_CSI1</description>
      <groupName>MIPI_CSI</groupName>
      <baseAddress>0xf102c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LVB</name>
      <description>LVB</description>
      <groupName>LVB</groupName>
      <baseAddress>0xf1030000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x6c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0307AF</resetMask>
          <fields>
            <field>
              <name>SPLIT_CH_REVERSE</name>
              <description>Just for split mode, reverse two channel data</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPLIT_CH_MODE</name>
              <description>Just for split mode
1: two channel pixel data are not aligned
0: two channel pixel data are  aligned</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPLIT_HSWHBP_WIDTH</name>
              <description>Just for split mode, the sum of HSW and HBP width is even
1: yes
0: no</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPLIT_MODE_EN</name>
              <description>Split mode enable:
1: enable
0: disable
Note: when using split mode, ch0/1 should be enabled, and should select same DI</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI1_VSYNC_POLARITY</name>
              <description>DI 1 vsync polarity:
1: active low
0: active high</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DI0_VSYNC_POLARITY</name>
              <description>DI 0 vsync polarity:
1: active low
0: active high</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDS_TXCLK_SHIFT</name>
              <description>Shift the LVDS TX PHY clock  in relation to the data.
000: txck is 7'b1100011
001: txck is 7b1110001
010: txck is 7b1111000
011: txck is 7b1000111
100: txck is 7b0001111
101: txck is 7b0011110
110: txck is 7b0111100
111: txck is 7b1100011</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_BIT_MAPPING</name>
              <description>Channel 1 data protocol:
1: JEIDA standard
0: SPWG standard</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_BIT_MAPPING</name>
              <description>Channel 0 data protocol:
1: JEIDA standard
0: SPWG standard</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_SEL</name>
              <description>Channel 1 select:
1: select DI 1
0: select DI 0</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1_EN</name>
              <description>Channel 1 enable:
1: enable
0: disable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_SEL</name>
              <description>Channel 0 select:
1: select DI 1
0: select DI 0</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0_EN</name>
              <description>Channel 0 enable:
1: enable
0: disable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_STAT</name>
          <description>LVDS TX PHY Status register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>LVDS1_TX_PHY_PLL_LOCK</name>
              <description>LVDS1 TX PHY PLL Lock indication Signal, 1 means pll already locked</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LVDS0_TX_PHY_PLL_LOCK</name>
              <description>LVDS0 TX PHY PLL Lock indication Signal, 1 means pll already locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>lvds0,lvds1</dimIndex>
          <name>PHY_POW_CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x0000001F</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>PWON_PLL</name>
              <description>pll power on</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCK_PD</name>
              <description>Power down control signal of channel txck
0: Normal operation
1: Power down channel</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX3_PD</name>
              <description>Power down control signal of channel tx3
0: Normal operation
1: Power down channel</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX2_PD</name>
              <description>Power down control signal of channel tx2
0: Normal operation
1: Power down channel</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX1_PD</name>
              <description>Power down control signal of channel tx1
0: Normal operation
1: Power down channel</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX0_PD</name>
              <description>Power down control signal of channel tx0
0: Normal operation
1: Power down channel</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>10</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>lvds0_tx0,lvds0_tx1,lvds0_tx2,lvds0_tx3,lvds0_txck,lvds1_tx0,lvds1_tx1,lvds1_tx2,lvds1_tx3,lvds1_txck</dimIndex>
          <name>TX_PHY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c</addressOffset>
          <register>
            <name>CTL0</name>
            <description>TX PHY Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x000A0358</resetValue>
            <resetMask>0x001FFFFF</resetMask>
            <fields>
              <field>
                <name>TX_IDLE</name>
                <description>Force the high-speed differential signal to common mode.
This signal can be set during IP power up stage to prevent unexpected leakage current in TXP/TXN
0: Normal operation
1: Force TXPN /TXMN to common mode</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RTERM_EN</name>
                <description>Inner Terminal Resistance enable
0: Disable rterm 2000ohm
1: Enable rterm 100ohm</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_BUS_WIDTH</name>
                <description>Parallel data bus width select
000: 4-bit mode, txN_data[3:0] are valid, txN_data[11:4] can be arbitrary state.
001: 6-bit mode, txN_data[5:0] are valid, txN_data[11:6] can be arbitrary state.
010: 7-bit mode. txN_data[6:0] are valid, txN_data[11:7] can be arbitrary state.
011: 8-bit mode. txN_data[7:0] are valid, txN_data[11:8] can be arbitrary state.
100: 9-bit mode. txN_data[8:0] are valid, txN_data[11:9] can be arbitrary state.
101: 10-bit mode. txN_data[9:0] are valid, txN_data[11:10] can be arbitrary state.
110: 11-bit mode. txN_data[10:0] are valid, txN_data[11] can be arbitrary state.
111: 12-bit mode. txN_data[11:0] are valid</description>
                <bitOffset>16</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_PHASE_SEL</name>
                <description>data/clock lane output phase adjustment:
0000: 0
0001: data lane is 1/32, clock lane is 1/16
0010: data lane is 2/32, clock lane is 2/16
0011: data lane is 3/32, clock lane is 3/16
0100: data lane is 4/32, clock lane is 4/16
0101: data lane is 5/32, clock lane is 5/16
0110: data lane is 6/32, clock lane is 6/16
0111: data lane is 7/32, clock lane is 7/16
1000: data lane is 8/32, clock lane is 8/16
1001: data lane is 9/32, clock lane is 9/16
1010: data lane is 10/32, clock lane is 10/16
1011: data lane is 11/32, clock lane is 11/16
1100: data lane is 12/32, clock lane is 12/16
1101: data lane is 13/32, clock lane is 13/16
1110: data lane is 14/32, clock lane is 14/16
1111: data lane is 15/32, clock lane is 15/16</description>
                <bitOffset>12</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_VCOM</name>
                <description>output Common Mode Voltage adjustment(Unit: V).
0000: 0.7
0001: 0.8
0010: 0.9
0011: 1.0
0100: 1.1
0101: 1.2
0110: 1.3
0111: 1.4
1000~1111: 1.5</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_AMP</name>
                <description>Output voltage Adjustment(Unit: mV).
0000 : 50
0001: 100
0010: 150
0011: 200
0100: 250
0101: 300
0110: 350
0111: 400
1000: 450
1001: 500
1010: 550
1011~1111: 600</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_SR</name>
                <description>output slew-rate trimming
00: slowest slew-rate;
11: fastest slew-rate</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_DEEMP</name>
                <description>output de-emphasis level trimming(Unit: dB)
00: 0
01: 2.5
10: 6.0
11: 6.0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL1</name>
            <description>TX_PHY Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000080</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>TX_CTL</name>
                <description>No description available</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PIXEL_MUX</name>
      <description>PIXEL_MUX</description>
      <groupName>PIXELMUX</groupName>
      <baseAddress>0xf1034000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x64</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PIXMUX</name>
          <description>pixel path mux register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF00FF</resetMask>
          <fields>
            <field>
              <name>RGB_EN</name>
              <description>RGB pixel bus enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RGB_SEL</name>
              <description>RGB pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GWC1_EN</name>
              <description>GWC1 pixel bus enable</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GWC1_SEL</name>
              <description>GWC1 pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GWC0_EN</name>
              <description>GWC0 pixel bus enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GWC0_SEL</name>
              <description>GWC0 pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVB_DI1_EN</name>
              <description>LVB DI1 pixel bus enable</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVB_DI1_SEL</name>
              <description>LVB DI1 pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVB_DI0_EN</name>
              <description>LVB DI0 pixel bus enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVB_DI0_SEL</name>
              <description>LVB DI0 pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_EN</name>
              <description>DSI0 pixel bus enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_SEL</name>
              <description>DSI0 pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_EN</name>
              <description>DSI1 pixel bus enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_SEL</name>
              <description>DSI1 pixel bus selection
1: LCDC1
0: LCDC0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM1_EN</name>
              <description>CAM1 pixel bus enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM1_SEL</name>
              <description>CAM1 pixel bus selection
111: Reserved
110: LCB1
101: LCB0
100: LCDC1
011: LCDC0
010: CSI1
001: CSI0
000: DVP</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM0_EN</name>
              <description>CAM0 pixel bus enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM0_SEL</name>
              <description>CAM0 pixel bus selection
111: Reserved
110: LCB1
101: LCB0
100: LCDC1
011: LCDC0
010: CSI1
001: CSI0
000: DVP</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>DSI0_CFG,DSI1_CFG</dimIndex>
          <name>DSI_SETTING[%s]</name>
          <description>no description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00200005</resetValue>
          <resetMask>0xFFFF000F</resetMask>
          <fields>
            <field>
              <name>DSI_DATA_ENABLE</name>
              <description>DSI pixel data type enable:
Bit0: RGB565_CFG1
Bit1: RGB565_CFG2
Bit2: RGB565_CFG3
Bit3: RGB666_CFG1
Bit4: RGB666_CFG2
Bit5: RGB888
Bit6: RGB_10BIT
Bit7: RGB_12BIT, no support
Bit8: YUV422_12BIT, no support
Bit9: YUV422_10BIT, no support
Bit10: YUV422_8BIT, no support
Bit11:YUV420_8BIT,no support
others: Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_DATA_TYPE</name>
              <description>DSI input pixel data type:
h0: RGB565_CFG1
h1: RGB565_CFG2
h2: RGB565_CFG3
h3: RGB666_CFG1
h4: RGB666_CFG2
h5: RGB888
h6: RGB_10BIT
h7: RGB_12BIT, no support
h8:YUV422_12BIT,no support
h9: YUV422_10BIT, no support
ha: YUV422_8BIT, no support
hb: YUV420_8BIT,no support
hc~hf: Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC</name>
          <description>common register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>LVB_DI1_CTL</name>
              <description>LVB DI1 optional general purpose control which is usually unused by display</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVB_DI0_CTL</name>
              <description>LVB DI0 optional general purpose control which is usually unused by display</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D0</name>
          <description>gpr write-read register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x07F7F3FF</resetMask>
          <fields>
            <field>
              <name>CSI1_CFG_AP_IF_CHECK_EN</name>
              <description>csi1 apb interface parity check enable</description>
              <bitOffset>22</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI1_CFG_AP_IF_INT_EN</name>
              <description>csi1 apb interface error interrupt enable</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI1_CFG_APB_SLVERROR_EN</name>
              <description>csi1 apb interface error check enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI0_CFG_AP_IF_CHECK_EN</name>
              <description>csi0 apb interface parity check enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI0_CFG_AP_IF_INT_EN</name>
              <description>csi0 apb interface error interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI0_CFG_APB_SLVERROR_EN</name>
              <description>csi0 apb interface error check enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_DPIUPDATECFG</name>
              <description>dsi1 dpi update configure</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_DPICOLORM</name>
              <description>dsi1 dpi cholor mode control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_DPISHUTDN</name>
              <description>dsi1 dpi shuntdown control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_DPIUPDATECFG</name>
              <description>dsi0 dpi update configure</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_DPICOLORM</name>
              <description>dsi0 dpi cholor mode control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_DPISHUTDN</name>
              <description>dsi0 dpi shuntdown control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI1_SOFT_RESET_N</name>
              <description>csi controller 1 reset, active low</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI0_SOFT_RESET_N</name>
              <description>csi controller 0 reset, active low</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI1_SOFT_RESET_N</name>
              <description>dsi controller 1 reset, active low</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI0_SOFT_RESET_N</name>
              <description>dsi controller 0 reset, active low</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D1</name>
          <description>gpr write-read register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>JPEG_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_P1_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_P0_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDC1_P1_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDC1_P0_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDC0_P1_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCDC0_P0_CTRL</name>
              <description>bit0: select cam0;
bit1: select cam1;
bit2: select jpeg;
bit3: select pdma</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D2</name>
          <description>gpr write-read register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x20003800</resetValue>
          <resetMask>0x3EFF7FFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY0_PORT_PLL_RDY_SEL</name>
              <description>tx phy0 port_pll_rdy_sel</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_RATE_LVDS</name>
              <description>tx phy0 rate_lvds</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_PHY_MODE</name>
              <description>tx phy0 phy_mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_REFCLK_DIV</name>
              <description>tx phy0 refclk_div</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_IDDQ_EN</name>
              <description>tx phy0 iddq_en</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_RESET_N</name>
              <description>tx phy0 reset, active low</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_SHUTDOWNZ</name>
              <description>tx phy0 shutdownz, active low</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_BYPS_CKDET</name>
              <description>tx phy0 byps_ckdet</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_PLL_DIV</name>
              <description>tx phy0 pll_div</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D3</name>
          <description>gpr write-read register 3</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY0_PLL_CTRL</name>
              <description>tx phy0 pll_ctrl</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D4</name>
          <description>gpr write-read register 4</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000900</resetValue>
          <resetMask>0xFFFFFDFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY0_TXCK_BIST_EN</name>
              <description>tx phy0 txck_bist_en</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX3_BIST_EN</name>
              <description>tx phy0 tx3_bist_en</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX2_BIST_EN</name>
              <description>tx phy0 tx2_bist_en</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX1_BIST_EN</name>
              <description>tx phy0 tx1_bist_en</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX0_BIST_EN</name>
              <description>tx phy0 tx0_bist_en</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TXCK_LPBK_EN</name>
              <description>tx_phy0 txck_lpbk_en</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX3_LPBK_EN</name>
              <description>tx_phy0 tx3_lpbk_en</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX2_LPBK_EN</name>
              <description>tx_phy0 tx2_lpbk_en</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX1_LPBK_EN</name>
              <description>tx_phy0 tx1_lpbk_en</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX0_LPBK_EN</name>
              <description>tx_phy0 tx0_lpbk_en</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TXCK_PAT_SEL</name>
              <description>tx phy0 txck_pat_sel</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX3_PAT_SEL</name>
              <description>tx phy0 tx3_pat_sel</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX2_PAT_SEL</name>
              <description>tx phy0 tx2_pat_sel</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX1_PAT_SEL</name>
              <description>tx phy0 tx1_pat_sel</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_TX0_PAT_SEL</name>
              <description>tx phy0 tx0_pat_sel</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_DSI0_PRBS_DISABLE</name>
              <description>tx phy0 dsi0_prbs_disable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_DSI0_PRBS_START</name>
              <description>tx phy0 dsi0_prbs_start</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY0_CKPHY_CTL</name>
              <description>tx phy0 ckphy_ctl</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D5</name>
          <description>gpr write-read register 5</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x20003800</resetValue>
          <resetMask>0x3EFF7FFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY1_PORT_PLL_RDY_SEL</name>
              <description>tx phy1 port_pll_rdy_sel</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_RATE_LVDS</name>
              <description>tx phy1 rate_lvds</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_PHY_MODE</name>
              <description>tx phy1 phy_mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_REFCLK_DIV</name>
              <description>tx phy1 refclk_div</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_IDDQ_EN</name>
              <description>tx phy1 iddq_en</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_RESET_N</name>
              <description>tx phy1 reset, active low</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_SHUTDOWNZ</name>
              <description>tx phy1 shutdownz, active low</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_BYPS_CKDET</name>
              <description>tx phy1 byps_ckdet</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_PLL_DIV</name>
              <description>tx phy1 pll_div</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D6</name>
          <description>gpr write-read register 6</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY1_PLL_CTRL</name>
              <description>tx phy1 pll_ctrl</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D7</name>
          <description>gpr write-read register 7</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000900</resetValue>
          <resetMask>0xFFFFFDFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY1_TXCK_BIST_EN</name>
              <description>tx phy1 txck_bist_en</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX3_BIST_EN</name>
              <description>tx phy1 tx3_bist_en</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX2_BIST_EN</name>
              <description>tx phy1 tx2_bist_en</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX1_BIST_EN</name>
              <description>tx phy1 tx1_bist_en</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX0_BIST_EN</name>
              <description>tx phy1 tx0_bist_en</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TXCK_LPBK_EN</name>
              <description>tx_phy1 txck_lpbk_en</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX3_LPBK_EN</name>
              <description>tx_phy1 tx3_lpbk_en</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX2_LPBK_EN</name>
              <description>tx_phy1 tx2_lpbk_en</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX1_LPBK_EN</name>
              <description>tx_phy1 tx1_lpbk_en</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX0_LPBK_EN</name>
              <description>tx_phy1 tx0_lpbk_en</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TXCK_PAT_SEL</name>
              <description>tx phy1 txck_pat_sel</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX3_PAT_SEL</name>
              <description>tx phy1 tx3_pat_sel</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX2_PAT_SEL</name>
              <description>tx phy1 tx2_pat_sel</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX1_PAT_SEL</name>
              <description>tx phy1 tx1_pat_sel</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_TX0_PAT_SEL</name>
              <description>tx phy1 tx0_pat_sel</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_DSI0_PRBS_DISABLE</name>
              <description>tx phy1 dsi0_prbs_disable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_DSI0_PRBS_START</name>
              <description>tx phy1 dsi0_prbs_start</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PHY1_CKPHY_CTL</name>
              <description>tx phy1 ckphy_ctl</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D8</name>
          <description>gpr write-read register 8</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7C0003</resetMask>
          <fields>
            <field>
              <name>RX_PHY0_BRUN_IN_MODE</name>
              <description>rx phy0 burn_in_mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_BURN_IN_EN_PAD</name>
              <description>rx phy0 burn_in_en_pad</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_LPBK_MODE</name>
              <description>rx phy0 lpbk_mode</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_FREQ_TRIM</name>
              <description>rx phy0 bist_freq_trim</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_RX0_BIST_EN</name>
              <description>rx phy0 rx0_bist_en rx1_bist_en</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_MODE</name>
              <description>rx phy0 bist_mode</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_EN_PAD</name>
              <description>rx phy0 bist_en_pad</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_EN</name>
              <description>rx phy0 bist_en</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_CKIN_SEL</name>
              <description>rx phy0 bist_ckin_sel</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY0_PHY_MODE</name>
              <description>rx phy0 phy_mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_WR_D9</name>
          <description>gpr write-read register 9</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7C0003</resetMask>
          <fields>
            <field>
              <name>RX_PHY1_BRUN_IN_MODE</name>
              <description>rx phy1 burn_in_mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_BURN_IN_EN_PAD</name>
              <description>rx phy1 burn_in_en_pad</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_LPBK_MODE</name>
              <description>rx phy1 lpbk_mode</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_FREQ_TRIM</name>
              <description>rx phy1 bist_freq_trim</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_RX0_BIST_EN</name>
              <description>rx phy1 rx0_bist_en rx1_bist_en</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_MODE</name>
              <description>rx phy1 bist_mode</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_EN_PAD</name>
              <description>rx phy1 bist_en_pad</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_EN</name>
              <description>rx phy1 bist_en</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_CKIN_SEL</name>
              <description>rx phy1 bist_ckin_sel</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_PHY1_PHY_MODE</name>
              <description>rx phy1 phy_mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D0</name>
          <description>gpr read-only register 0</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHY1_CTL_O</name>
              <description>{2'b0,
tx_phy1_tx3_ctl_o,tx_phy1_tx2_ctl_o,
tx_phy1_tx1_ctl_o,tx_phy1_tx0_ctl_o,
tx_phy1_txck_ctl_o,tx_phy1_pll_dtest_o}</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_CTL_O</name>
              <description>{2'b0,
tx_phy0_tx3_ctl_o,tx_phy0_tx2_ctl_o,
tx_phy0_tx1_ctl_o,tx_phy0_tx0_ctl_o,
tx_phy0_txck_ctl_o,tx_phy0_pll_dtest_o}</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D1</name>
          <description>gpr read-only register 1</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_CSI0_AP</name>
              <description>interrupt of csi0 ap</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI0_CFG_CSI_AP_DIAG_FAULTS</name>
              <description>csi0 ap diag faults</description>
              <bitOffset>5</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI0_STA_AP_IF_INT_STA</name>
              <description>csi0 apb parity check interrupt satus</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D2</name>
          <description>gpr read-only register 2</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>IRQ_CSI1_AP</name>
              <description>interrupt of csi1 ap</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI1_CFG_CSI_AP_DIAG_FAULTS</name>
              <description>csi1 ap diag faults</description>
              <bitOffset>5</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI1_STA_AP_IF_INT_STA</name>
              <description>csi1 apb parity check interrupt satus</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D3</name>
          <description>gpr read-only register 3</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>RX_PHY0_RXCK_CTLO</name>
              <description>rx phy0 rxck_ctlo</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_RX1_CTLO</name>
              <description>rx phy0 rx1_ctlo</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_RX0_CTLO</name>
              <description>rx phy0 rx0_ctlo</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D4</name>
          <description>gpr read-only register 4</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>RX_PHY1_RXCK_CTLO</name>
              <description>rx phy1 rxck_ctlo</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_RX1_CTLO</name>
              <description>rx phy1 rx1_ctlo</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_RX0_CTLO</name>
              <description>rx phy1 rx0_ctlo</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D5</name>
          <description>gpr read-only register 5</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DSI0_PRBS_STATE</name>
              <description>dsi0_prbs_state for debug only</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TXCK_BIST_DONE_PAD</name>
              <description>tx phy0 txck_done_pad</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TXCK_BIST_OK_PAD</name>
              <description>tx phy0 txck_ok_pad</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TXCK_BIST_DONE</name>
              <description>tx phy0 txck_bist_done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX3_BIST_DONE</name>
              <description>tx phy0 tx3_bist_done</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX2_BIST_DONE</name>
              <description>tx phy0 tx2_bist_done</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX1_BIST_DONE</name>
              <description>tx phy0 tx1_bist_done</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX0_BIST_DONE</name>
              <description>tx phy0 tx0_bist_done</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TXCK_BIST_OUT</name>
              <description>tx phy0 txck_bist_out</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX3_BIST_OUT</name>
              <description>tx phy0 tx3_bist_out</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX2_BIST_OUT</name>
              <description>tx phy0 tx2_bist_out</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX1_BIST_OUT</name>
              <description>tx phy0 tx1_bist_out</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY0_TX0_BIST_OUT</name>
              <description>tx phy0 tx0_bist_out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D6</name>
          <description>gpr read-only register 6</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>DSI1_PRBS_STATE</name>
              <description>dsi1_prbs_state for debug only</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TXCK_BIST_DONE_PAD</name>
              <description>tx phy1 txck_done_pad</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TXCK_BIST_OK_PAD</name>
              <description>tx phy1 txck_ok_pad</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TXCK_BIST_DONE</name>
              <description>tx phy1 txck_bist_done</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX3_BIST_DONE</name>
              <description>tx phy1 tx3_bist_done</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX2_BIST_DONE</name>
              <description>tx phy1 tx2_bist_done</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX1_BIST_DONE</name>
              <description>tx phy1 tx1_bist_done</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX0_BIST_DONE</name>
              <description>tx phy1 tx0_bist_done</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TXCK_BIST_OUT</name>
              <description>tx phy1 txck_bist_out</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX3_BIST_OUT</name>
              <description>tx phy1 tx3_bist_out</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX2_BIST_OUT</name>
              <description>tx phy1 tx2_bist_out</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX1_BIST_OUT</name>
              <description>tx phy1 tx1_bist_out</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_PHY1_TX0_BIST_OUT</name>
              <description>tx phy1 tx0_bist_out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D7</name>
          <description>gpr read-only register 7</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>RX_PHY0_BURN_IN_OK_PAD</name>
              <description>rx_phy0_burn_in_ok_pad</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_RX1_BIST_DONE</name>
              <description>rx phy0 rx1_bist_done</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_RX0_BIST_DONE</name>
              <description>rx phy0 rx0_bist_done</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_RX1_BIST_OUT</name>
              <description>rx phy0 rx1_bist_out</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_RX0_BIST_OUT</name>
              <description>rx phy0 rx0_bist_out</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_OK_PAD</name>
              <description>rx phy0 bist_ok_pad</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY0_BIST_DONE_PAD</name>
              <description>rx phy0 bist_done_pad</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D8</name>
          <description>gpr read-only register 8</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>RX_PHY1_BURN_IN_OK_PAD</name>
              <description>rx_phy1_burn_in_ok_pad</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_RX1_BIST_DONE</name>
              <description>rx phy1 rx1_bist_done</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_RX0_BIST_DONE</name>
              <description>rx phy1 rx0_bist_done</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_RX1_BIST_OUT</name>
              <description>rx phy1 rx1_bist_out</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_RX0_BIST_OUT</name>
              <description>rx phy1 rx0_bist_out</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_OK_PAD</name>
              <description>rx phy1 bist_ok_pad</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_PHY1_BIST_DONE_PAD</name>
              <description>rx phy1 bist_done_pad</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR_RO_D9</name>
          <description>gpr read-only register 9</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
        </register>
        <register>
          <name>GPR_WR1_CLR_D0</name>
          <description>gpr write1 set/no-write clr register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR_WR1_CLR_DATA</name>
              <description>gpr register, write 1 /no-write  set/clr matching bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCB</name>
      <description>LCB</description>
      <groupName>LCB</groupName>
      <baseAddress>0xf1038000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x98</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x000001F3</resetMask>
          <fields>
            <field>
              <name>LVDS_RXCK_SEL</name>
              <description>just for LVDS Display mode and CAM LINK mode,  clock selection:
1: LVDS1 RXCK
0: LVDS0 RXCK</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAM_LINK_WIDTH</name>
              <description>just for CAM LINK mode,  data width:
00: 24bit
01: 30bit
10: 36bit
11: reserved</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_MAPPING</name>
              <description>just for LVDS Display mode,  data protocol:
1: JEIDA standard
0: SPWG standard</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_WIDTH</name>
              <description>just for LVDS Display mode,  data width:
1: 24bit
0: 18bit(3line)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>mode selection
00: lvds display(4 line), two LVDS RX PHY must be LVDS display mode
01: cam link(4 line), two LVDS RX PHY must be LVDS display mode
10: sync code(2 line), LVDS RX PHY must be LVDS cameral mode
11: sync code(1line), LVDS RX PHY must be LVDS cameral mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_STAT</name>
          <description>LVDS RX PHY Status register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>LVDS1_RX_PHY_DLL_LOCK</name>
              <description>LVDS1 RX PHY DLL Lock indication Signal, 1 means dll already locked</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LVDS0_RX_PHY_DLL_LOCK</name>
              <description>LVDS0 RX PHY DLL Lock indication Signal, 1 means dll already locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>lvds0,lvds1</dimIndex>
          <name>PHY_POW_CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x0000000F</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>IDDQ_EN</name>
              <description>Power down control signal of channel rxck/rx1/rx0
0: Normal operation
1: Power down channel</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCK_PD</name>
              <description>Power down control signal of channel rxck
0: Normal operation
1: Power down channel</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX1_PD</name>
              <description>Power down control signal of channel rx1
0: Normal operation
1: Power down channel</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX0_PD</name>
              <description>Power down control signal of channel rx0
0: Normal operation
1: Power down channel</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>lvds0_rx0,lvds0_rx1,lvds1_rx0,lvds1_rx1</dimIndex>
          <name>PHY_D_CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00080E29</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>RX_VCOM</name>
              <description>bit 1: Receiver hysteresis enable signal. 0: enable; 1: disable
bit 0: Terminal impedance common mode selection control signal. 0: floating; 1: Ground</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RTERM</name>
              <description>Terminal impedance regulation control signal
0000: hi-z;
0001: 150ohm;
1000:100ohm;
1111:75ohm</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_CTL</name>
              <description>bit 0 :  Lane N Data MSB first enable signal. 0: LSB ; 1: MSB
bit 1 :  Lane N Data Polarity signal. 0: Not inverting; 1: Inverting
bit [4:2] : Phase difference between the output first bit data (rxN[6:0]) and the input clock (RCKP/N) in LVDS Display Mode.
bit 5 : Reserved
bit 6 : Output data sampling clock control signal
0: Sampling using the rising edge of the clock pck.
1: Sampling using the falling edge of the clock pck.
bit 7 : Reserved
bit 8 : Data Lane N Skew adjust enable in LVDS Camera Mode.
bit [12:9] : Data Lane N Skew adjust; 0000: min; 0111: default; 1111: max.
bit [15:13] : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>lvds0_rxck,lvds1_rxck</dimIndex>
          <name>PHY_CK_CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00080435</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>RX_VCOM</name>
              <description>bit 1: Receiver hysteresis enable signal. 0: enable; 1: disable
bit 0: Terminal impedance common mode selection control signal. 0: floating; 1: Ground</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_RTERM</name>
              <description>Terminal impedance regulation control signal
0000: hi-z;
0001: 150ohm;
1000:100ohm;
1111:75ohm</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_CTL</name>
              <description>bit 0 : DLL loop delay adjustment minimum control signal
0: used for RCKP/RCKNs frequency is 40Mhz~70Mhz
1:used for RCKP/RCKNs frequency is 70Mhz~110Mhz
bit [2:1] : DLL loop delay adjustment current regulation control signal. 00: min; 11: max
bit 3 : Reserved
bit 4 : Clock Lane Skew adjust enable in LVDS Camera Mode.
bit [7:5] : Bus width selection in LVDS Camera Mode
000: 4bit; 001:6bit; 010:7bit; 011:8bit; 100:9bit; 101:10bit; 110:11bit; 111:12bit.
bit [10:8] : DDR Clock duty cycle adjust in LVDS Camera Mode.
bit [15:11] : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>lvds0,lvds1</dimIndex>
          <name>PHY_ADJ_CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x414101FF</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>LVDS_RX0_DLINE_ADJ</name>
              <description>LVDS RX PHY RX0 line:
bit [7:0] : Lane N skew adjustment control signal between data and clock
0000000: max; 1111111: min
bit 8 : Reserved</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDS_RX1_DLINE_ADJ</name>
              <description>LVDS RX PHY RX1 line:
bit [7:0] : Lane N skew adjustment control signal between data and clock
0000000: max; 1111111: min
bit 8 : Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LVDS_DLL_TUNING_INT</name>
              <description>LVDS RX PHY RXCK line:
DLL loop delay coarse adjustment initial signal
00000000: min ; 11111111: max</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>lvds0,lvds1</dimIndex>
          <name>PHY_SU_CTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>SU_CTRL</name>
              <description>bit [2:0] : Reference voltage/current adjustment control signal. 000: min; 111: max
bit [3] : Internal bias circuit selection signal. 0: from Bandgap Mode; 1: from self-bias mode
bit [7:4] : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPU</name>
      <description>GPU</description>
      <groupName>GPU</groupName>
      <baseAddress>0xf1080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x50c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>AQHiClockControl</name>
          <description>clock control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00070100</resetValue>
          <resetMask>0x000F3FFE</resetMask>
          <fields>
            <field>
              <name>ISOLATE_GPU</name>
              <description>isolate GPU bit, used for power on/off</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDLE_VG</name>
              <description>vg pipe is idle</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE2_D</name>
              <description>2D pipe is idle or not present</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE3_D</name>
              <description>3D pipe is idle or not present</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_RAM_POWER_OPTIMIZATION</name>
              <description>disables ram power optimization</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFT_RESET</name>
              <description>soft reset the IP</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_DEBUG_REGISTERS</name>
              <description>disable debug registers</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_RAM_CLOCK_GATING</name>
              <description>disables clock gating for rams</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FSCALE_CMD_LOAD</name>
              <description>core clock frequency scale value enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FSCALE_VAL</name>
              <description>core clock frequency scale value</description>
              <bitOffset>2</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK2D_DIS</name>
              <description>disable 2D/VG clock</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AQHildle</name>
          <description>idle status register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x80001FFF</resetValue>
          <resetMask>0x80001FFF</resetMask>
          <fields>
            <field>
              <name>AXI_LP</name>
              <description>axi is in low power mode</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_BLT</name>
              <description>BLT is idle or not present</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_TS</name>
              <description>Tessellation Engine is idle</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_FP</name>
              <description>FP is idle or not present</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_IM</name>
              <description>Image Engine is idle</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_VG</name>
              <description>Vector Graphics Engine is idle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_TX</name>
              <description>TX is idle or not present</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_RA</name>
              <description>RA is idle or not present</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_SE</name>
              <description>SE is idle or not present</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PA</name>
              <description>PA is idle or not present</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_SH</name>
              <description>SH is idle or not present</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_PE</name>
              <description>Pixel engine is idle</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_DE</name>
              <description>DE is dile or not present</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE_FE</name>
              <description>0: fetch engine is busy  1:fetch engine is idle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AQIntrAcknowledge</name>
          <description>interrupt acknoledge register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTR_VEC</name>
              <description>for each interrupt event, 0=clear,1=interrupt active</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AQIntrEnbl</name>
          <description>interrupt enable register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTR_ENBL_VEC</name>
              <description>0=disable interrupt; 1=enable interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCChipRev</name>
          <description>chip revison register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REV</name>
              <description>revision</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GCChipDate</name>
          <description>chip date register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATE</name>
              <description>date</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcregHIChipPatchRev</name>
          <description>chip patch revision register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PATCH_REV</name>
              <description>patch revision</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcProductID</name>
          <description>product identification register</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x03002655</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TYPE</name>
              <description>product type is 3:VG</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM</name>
              <description>product number is 265</description>
              <bitOffset>4</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GRADE_LEVEL</name>
              <description>0:None_no extra letter on the product name for this core 1:nano 5:nano ultra</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcModulePowerControls</name>
          <description>module power control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFF00F7</resetMask>
          <fields>
            <field>
              <name>TURN_OFF_COUNTER</name>
              <description>counter value for clock gating the module if the module is idle for this amout of clock cycles</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TURN_ON_COUNTER</name>
              <description>number of clock cycle gating the module if the modules is idle for this amout of clockk cycles</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_STARVE_MODULE_CLOCK_GATING</name>
              <description>disable module level clock gating for starve/idle condition</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_STALL_MODULE_CLOCK_GATING</name>
              <description>disable module level clock gating for stall condition</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_MODULE_CLOCK_GATING</name>
              <description>enable module level clock gating</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcModulePowerModuleControl</name>
          <description>module power module control register</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001B05</resetMask>
          <fields>
            <field>
              <name>DISABLE_MODULE_CLOCKGATING_FLEXA</name>
              <description>disables module level clock gating for flexa, not supported for all variants</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MODULE_CLOCK_GATING_TS</name>
              <description>disables module level clock gating for TS</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MODULE_CLOCK_GATING_IM</name>
              <description>disables module level clock gating for IM</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MODULE_CLOCK_GATING_VG</name>
              <description>disables module lelvel clock gating for VG</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MODULE_CLOCK_GATING_PE</name>
              <description>disables module level clock gating for PE</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_MODULE_CLOCK_GATING_FE</name>
              <description>disables module level clock gating for FE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcModulePowerModuleStatus</name>
          <description>module power module status register</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001B05</resetMask>
          <fields>
            <field>
              <name>MODULE_CLOCK_GATED_FLEXA</name>
              <description>module level ckock gating is on for flexa</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODULE_CLOCK_GATED_TS</name>
              <description>module level ckock gating is on for ts</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODULE_CLOCK_GATED_IM</name>
              <description>module level clock gating is on for IM</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODULE_CLOCK_GATED_VG</name>
              <description>module level clock gating is on for VG</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODULE_CLOCK_GATED_PE</name>
              <description>module level clock gating is on for PE</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODULE_CLOCK_GATED_FE</name>
              <description>module level clock gating is on for FE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AQMemoryFePageTable</name>
          <description>fetch engine page table base address register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>BASE_ADDRESS</name>
              <description>base address for the FE virtual address lookup table</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AQMemoryDebug</name>
          <description>memory debug register</description>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <resetValue>0x3C000000</resetValue>
          <resetMask>0x3F0000FF</resetMask>
          <fields>
            <field>
              <name>ZCOMP_LIMIT</name>
              <description>not relevant for vector graphics IP</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_OUTSTANDING_READS</name>
              <description>limits the total number of outstanding read requests</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AQRegisterTimingControl</name>
          <description>timing control register</description>
          <addressOffset>0x42c</addressOffset>
          <size>32</size>
          <resetValue>0x00030000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>POWER_DOWN</name>
              <description>powerdown memory</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WTC</name>
              <description>WTC for fast rams</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_RTC</name>
              <description>RTC for fast rams</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOR_RF2P</name>
              <description>for 2 port ram</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOR_RF1P</name>
              <description>for 1 port ram</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcregFetchAddress</name>
          <description>fetch command buffer base address register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS</name>
              <description>address of command buffer</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE</name>
              <description>0=system  2=vritual 1=local</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcregFetchControl</name>
          <description>fetch control register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001FFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>number of 64bit words to fetch</description>
              <bitOffset>0</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>gcregCurrentFetchAddress</name>
          <description>current fetch command address register</description>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRESS</name>
              <description>address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ENET0</name>
      <description>ENET0</description>
      <groupName>ENET</groupName>
      <baseAddress>0xf1100000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3028</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MACCFG</name>
          <description>MAC Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>SARC</name>
              <description>Source Address Insertion or Replacement Control
 This field controls the source address insertion or replacement for all transmitted frames.
Bit 30 specifies which MAC Address register (0 or 1) is used for source address insertion or replacement based on the values of Bits [29:28]:
- 2'b0x: The input signals mti_sa_ctrl_i and ati_sa_ctrl_i control the SA field generation.
- 2'b10: - If Bit 30 is set to 0, the MAC inserts the content of the MAC Address 0 registers (registers 16 and 17) in the SA field of all transmitted frames.
             - If Bit 30 is set to 1 and the Enable MAC Address Register 1 option is selected during core configuration,
                the MAC inserts the content of the MAC Address 1 registers (registers 18 and 19) in the SA field of all transmitted frames.
- 2'b11: - If Bit 30 is set to 0, the MAC replaces the content of the MAC Address 0 registers (registers 16 and 17) in the SA field of all transmitted frames.
             - If Bit 30 is set to 1 and the Enable MAC Address Register 1 option is selected during core configuration,
                the MAC replaces the content of the MAC Address 1 registers (registers 18 and 19) in the SA field of all transmitted frames.
Note: - Changes to this field take effect only on the start of a frame.
If you write this register field when a frame is being transmitted, only the subsequent frame can use the updated value,
that is, the current frame does not use the updated value.
- These bits are reserved and RO when the Enable SA, VLAN, and CRC Insertion on TX feature is not selected during core configuration.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWOKPE</name>
              <description>IEEE 802.3as Support for 2K Packets
 When set, the MAC considers all frames, with up to 2,000 bytes length, as normal packets.
When Bit 20 (JE) is not set, the MAC considers all received frames of size more than 2K bytes as Giant frames.
When this bit is reset and Bit 20 (JE) is not set, the MAC considers all received frames of size more than 1,518 bytes (1,522 bytes for tagged) as Giant frames.
When Bit 20 is set, setting this bit has no effect on Giant Frame status.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SFTERR</name>
              <description>SMII Force Transmit Error
 When set, this bit indicates to the PHY to force a transmit error in the SMII frame being transmitted. This bit is reserved if the SMII PHY port is not selected during core configuration.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CST</name>
              <description>CRC Stripping for Type Frames
 When this bit is set, the last 4 bytes (FCS) of all frames of Ether type (Length/Type field greater than or equal to 1,536) are stripped and dropped before forwarding the frame to the application.
This function is not valid when the IP Checksum Engine (Type 1) is enabled in the MAC receiver. This function is valid when Type 2 Checksum Offload Engine is enabled.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TC</name>
              <description>Transmit Configuration in RGMII, SGMII, or SMII
 When set, this bit enables the transmission of duplex mode, link speed, and link up or down information to the PHY in the RGMII, SMII,
 or SGMII port. When this bit is reset, no such information is driven to the PHY.
This bit is reserved (and RO) if the RGMII, SMII, or SGMII PHY port is not selected during core configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WD</name>
              <description>Watchdog Disable
 When this bit is set, the MAC disables the watchdog timer on the receiver. The MAC can receive frames of up to 16,383 bytes.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JD</name>
              <description>Jabber Disable
 When this bit is set, the MAC disables the jabber timer on the transmitter. The MAC can transfer frames of up to 16,383 bytes.
When this bit is reset, the MAC cuts off the transmitter if the application sends out more than 2,048 bytes of data (10,240 if JE is set high) during transmission.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BE</name>
              <description>Frame Burst Enable
 When this bit is set, the MAC allows frame bursting during transmission in the GMII half-duplex mode. This bit is reserved (and RO) in the 10/100 Mbps only or full-duplex-only configurations.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JE</name>
              <description>Jumbo Frame Enable
 When this bit is set, the MAC allows Jumbo frames of 9,018 bytes (9,022 bytes for VLAN tagged frames) without reporting a giant frame error in the receive frame status.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IFG</name>
              <description>Inter-Frame Gap
 These bits control the minimum IFG between frames during transmission.
- 000: 96 bit times
- 001: 88 bit times
- 010: 80 bit times - ...
- 111: 40 bit times In the half-duplex mode, the minimum IFG can be configured only for 64 bit times (IFG = 100).
Lower values are not considered.
In the 1000-Mbps mode, the minimum IFG supported is 64 bit times (and above) in the GMAC-CORE configuration and 80 bit times (and above) in other configurations.
 When a JAM pattern is being transmitted because of backpressure activation, the MAC does not consider the minimum IFG.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRS</name>
              <description>Disable Carrier Sense During Transmission
 When set high, this bit makes the MAC transmitter ignore the (G)MII CRS signal during frame transmission in the half-duplex mode.
 This request results in no errors generated because of Loss of Carrier or No Carrier during such transmission.
When this bit is low, the MAC transmitter generates such errors because of Carrier Sense and can even abort the transmissions.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PS</name>
              <description>Port Select
 This bit selects the Ethernet line speed.
- 0: For 1000 Mbps operations
- 1: For 10 or 100 Mbps operations In 10 or 100 Mbps operations, this bit, along with FES bit, selects the exact line speed.
In the 10/100 Mbps-only (always 1) or 1000 Mbps-only (always 0) configurations, this bit is read-only with the appropriate value. In default 10/100/1000 Mbps configuration,
this bit is R_W. The mac_portselect_o or mac_speed_o[1] signal reflects the value of this bit.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FES</name>
              <description>Speed
 This bit selects the speed in the MII, RMII, SMII, RGMII, SGMII, or RevMII interface:
- 0: 10 Mbps
- 1: 100 Mbps This bit is reserved (RO) by default and is enabled only when the parameter SPEED_SELECT = Enabled.
This bit generates link speed encoding when Bit 24 (TC) is set in the RGMII, SMII, or SGMII mode.
This bit is always enabled for RGMII, SGMII, SMII, or RevMII interface.
In configurations with RGMII, SGMII, SMII, or RevMII interface, this bit is driven as an output signal (mac_speed_o[0]) to reflect the value of this bit in the mac_speed_o signal.
In configurations with RMII, MII, or GMII interface, you can optionally drive this bit as an output signal (mac_speed_o[0]) to reflect its value in the mac_speed_o signal.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DO</name>
              <description>Disable Receive Own
 When this bit is set, the MAC disables the reception of frames when the phy_txen_o is asserted in the half-duplex mode.
When this bit is reset, the MAC receives all packets that are given by the PHY while transmitting.
This bit is not applicable if the MAC is operating in the full-duplex mode. This bit is reserved (RO with default value) if the MAC is configured for the full-duplex-only operation.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LM</name>
              <description>Loopback Mode
 When this bit is set, the MAC operates in the loopback mode at GMII or MII.
The (G)MII Receive clock input (clk_rx_i) is required for the loopback to work properly, because the Transmit clock is not looped-back internally.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DM</name>
              <description>Duplex Mode
 When this bit is set, the MAC operates in the full-duplex mode where it can transmit and receive simultaneously.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPC</name>
              <description>Checksum Offload
When this bit is set, the MAC calculates the 16-bit ones complement of the ones complement sum of all received Ethernet frame payloads.
It also checks whether the IPv4 Header checksum (assumed to be bytes 2526 or 2930 (VLAN-tagged)
of the received Ethernet frame) is correct for the received frame and gives the status in the receive status word.
The MAC also appends the 16-bit checksum calculated for the IP header datagram payload (bytes after the IPv4 header)
and appends it to the Ethernet frame transferred to the application (when Type 2 COE is deselected).
When this bit is reset, this function is disabled.
When Type 2 COE is selected, this bit, when set, enables the IPv4 header checksum checking and IPv4 or IPv6 TCP, UDP, or ICMP payload checksum checking.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DR</name>
              <description>Disable Retry
When this bit is set, the MAC attempts only one transmission.
When a collision occurs on the GMII or MII interface,
the MAC ignores the current frame transmission and reports a Frame Abort with excessive collision error in the transmit frame status.
When this bit is reset, the MAC attempts retries based on the settings of the BL field (Bits [6:5]).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LUD</name>
              <description>Link Up or Down
 This bit indicates whether the link is up or down during the transmission of configuration in the RGMII, SGMII, or SMII interface:
- 0: Link Down
- 1: Link Up</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACS</name>
              <description>Automatic Pad or CRC Stripping
 When this bit is set, the MAC strips the Pad or FCS field on the incoming frames only if the value of the length field is less than 1,536 bytes.
All received frames with length field greater than or equal to 1,536 bytes are passed to the application without stripping the Pad or FCS field.
When this bit is reset, the MAC passes all incoming frames, without modifying them, to the Host.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BL</name>
              <description>Back-Off Limit
 The Back-Off limit determines the random integer number (r) of slot time delays
 (4,096 bit times for 1000 Mbps and 512 bit times for 10/100 Mbps) for which the MAC waits before rescheduling a transmission attempt during retries after a collision.
This bit is applicable only in the half-duplex mode and is reserved (RO) in the full-duplex-only configuration.
- 00: k= min (n, 10)
- 01: k = min (n, 8)
- 10: k = min (n, 4)
- 11: k = min (n, 1) where n = retransmission attempt. The random integer r takes the value in the range 0  r &lt; 2k</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC</name>
              <description>Deferral Check
 When this bit is set, the deferral check function is enabled in the MAC.
The MAC issues a Frame Abort status, along with the excessive deferral error bit set in the transmit frame status,
when the transmit state machine is deferred for more than 24,288 bit times in the 10 or 100 Mbps mode.
 If the MAC is configured for 1000 Mbps operation or if the Jumbo frame mode is enabled in the 10 or 100 Mbps mode,
 the threshold for deferral is 155,680 bits times. Deferral begins when the transmitter is ready to transmit,
but it is prevented because of an active carrier sense signal (CRS) on GMII or MII. The defer time is not cumulative.
For example, if the transmitter defers for 10,000 bit times because the CRS signal is active and then the CRS signal becomes inactive,
the transmitter transmits and collision happens.
Because of collision, the transmitter needs to back off and then defer again after back off completion.
In such a scenario, the deferral timer is reset to 0 and it is restarted.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TE</name>
              <description>Transmitter Enable
 When this bit is set, the transmit state machine of the MAC is enabled for transmission on the GMII or MII. When this bit is reset,
 the MAC transmit state machine is disabled after the completion of the transmission of the current frame, and does not transmit any further frames.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RE</name>
              <description>Receiver Enable
 When this bit is set, the receiver state machine of the MAC is enabled for receiving frames from the GMII or MII. When this bit is reset,
the MAC receive state machine is disabled after the completion of the reception of the current frame, and does not receive any further frames from the GMII or MII.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRELEN</name>
              <description>Preamble Length for Transmit frames
 These bits control the number of preamble bytes that are added to the beginning of every Transmit frame.
 The preamble reduction occurs only when the MAC is operating in the full-duplex mode.
- 2'b00: 7 bytes of preamble
- 2'b01: 5 bytes of preamble
- 2'b10: 3 bytes of preamble
- 2'b11: Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MACFF</name>
          <description>MAC Frame Filter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x803087FF</resetMask>
          <fields>
            <field>
              <name>RA</name>
              <description>Receive All
 When this bit is set, the MAC Receiver module passes all received frames, irrespective of whether they pass the address filter or not, to the Application.
The result of the SA or DA filtering is updated (pass or fail) in the corresponding bits in the Receive Status Word. When this bit is reset,
the Receiver module passes only those frames to the Application that pass the SA or DA address filter.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DNTU</name>
              <description>Drop non-TCP/UDP over IP Frames
 When set, this bit enables the MAC to drop the non-TCP or UDP over IP frames. The MAC forward only those frames that are processed by the Layer 4 filter.
When reset, this bit enables the MAC to forward all non-TCP or UDP over IP frames.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPFE</name>
              <description>Layer 3 and Layer 4 Filter Enable
 When set, this bit enables the MAC to drop frames that do not match the enabled Layer 3 and Layer 4 filters. If Layer 3 or Layer 4 filters are not enabled for matching,
this bit does not have any effect. When reset, the MAC forwards all frames irrespective of the match status of the Layer 3 and Layer 4 fields.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VTFE</name>
              <description>VLAN Tag Filter Enable
 When set, this bit enables the MAC to drop VLAN tagged frames that do not match the VLAN Tag comparison.
When reset, the MAC forwards all frames irrespective of the match status of the VLAN Tag.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPF</name>
              <description>Hash or Perfect Filter
 When this bit is set, it configures the address filter to pass a frame if it matches either the perfect filtering or the hash filtering as set by the HMC or HUC bits.
When this bit is low and the HUC or HMC bit is set, the frame is passed only if it matches the Hash filter.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAF</name>
              <description>Source Address Filter Enable
 When this bit is set, the MAC compares the SA field of the received frames with the values programmed in the enabled SA registers. If the comparison fails,
 the MAC drops the frame. When this bit is reset, the MAC forwards the received frame to the application with updated SAF bit of the Rx Status depending on the SA address comparison.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAIF</name>
              <description>SA Inverse Filtering
When this bit is set, the Address Check block operates in inverse filtering mode for the SA address comparison. The frames whose SA matches the SA registers are marked as failing the SA Address filter.
When this bit is reset, frames whose SA does not match the SA registers are marked as failing the SA Address filter.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCF</name>
              <description>Pass Control Frames
 These bits control the forwarding of all control frames (including unicast and multicast Pause frames).
- 00: MAC filters all control frames from reaching the application.
- 01: MAC forwards all control frames except Pause frames to application even if they fail the Address filter.
- 10: MAC forwards all control frames to application even if they fail the Address Filter.
- 11: MAC forwards control frames that pass the Address Filter.
The following conditions should be true for the Pause frames processing:
- Condition 1: The MAC is in the full-duplex mode and flow control is enabled by setting Bit 2 (RFE) of Register 6 (Flow Control Register) to 1.
- Condition 2: The destination address (DA) of the received frame matches the special multicast address or the MAC Address 0 when Bit 3 (UP) of the Register 6 (Flow Control Register) is set.
- Condition 3: The Type field of the received frame is 0x8808 and the OPCODE field is 0x0001.
Note: This field should be set to 01 only when the Condition 1 is true,
that is, the MAC is programmed to operate in the full-duplex mode and the RFE bit is enabled.
Otherwise, the Pause frame filtering may be inconsistent.
When Condition 1 is false, the Pause frames are considered as generic control frames.
Therefore, to pass all control frames (including Pause frames) when the full-duplex mode and flow control is not enabled,
you should set the PCF field to 10 or 11 (as required by the application).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBF</name>
              <description>Disable Broadcast Frames
 When this bit is set, the AFM module blocks all incoming broadcast frames. In addition, it overrides all other filter settings.
When this bit is reset, the AFM module passes all received broadcast frames.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PM</name>
              <description>Pass All Multicast
When set, this bit indicates that all received frames with a multicast destination address (first bit in the destination address field is '1') are passed.
When reset, filtering of multicast frame depends on HMC bit.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAIF</name>
              <description>DA Inverse Filtering
 When this bit is set, the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast frames.
When reset, normal filtering of frames is performed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HMC</name>
              <description>Hash Multicast
When set, the MAC performs destination address filtering of received multicast frames according to the hash table. When reset,
the MAC performs a perfect destination address filtering for multicast frames, that is, it compares the DA field with the values programmed in DA registers.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HUC</name>
              <description>Hash Unicast
 When set, the MAC performs destination address filtering of unicast frames according to the hash table.
When reset, the MAC performs a perfect destination address filtering for unicast frames, that is, it compares the DA field with the values programmed in DA registers.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PR</name>
              <description>Promiscuous Mode
When this bit is set, the Address Filter module passes all incoming frames irrespective of the destination or source address.
 The SA or DA Filter Fails status bits of the Receive Status Word are always cleared when PR is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_H</name>
          <description>Hash Table High Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTH</name>
              <description>Hash Table High
 This field contains the upper 32 bits of the Hash table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_L</name>
          <description>Hash Table Low Register</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HTL</name>
              <description>Hash Table Low
 This field contains the lower 32 bits of the Hash table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMII_ADDR</name>
          <description>GMII Address Register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PA</name>
              <description>Physical Layer Address
 This field indicates which of the 32 possible PHY devices are being accessed. For RevMII, this field gives the PHY Address of the RevMII module.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GR</name>
              <description>GMII Register
 These bits select the desired GMII register in the selected PHY device. For RevMII, these bits select the desired CSR register in the RevMII Registers set.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CR</name>
              <description>CSR Clock Range
 The CSR Clock Range selection determines the frequency of the MDC clock according to the CSR clock frequency used in your design.
The CSR clock corresponding to different GMAC configurations is given in Table 9-2 on page 564.
The suggested range of CSR clock frequency applicable for each value (when Bit[5] = 0)
ensures that the MDC clock is approximately between the frequency range 1.0 MHz2.5 MHz.
- 0000: The CSR clock frequency is 60100 MHz and the MDC clock frequency is CSR clock/42.
- 0001: The CSR clock frequency is 100150 MHz and the MDC clock frequency is CSR clock/62.
- 0010: The CSR clock frequency is 2035 MHz and the MDC clock frequency is CSR clock/16.
- 0011: The CSR clock frequency is 3560 MHz and the MDC clock frequency is CSR clock/26.
- 0100: The CSR clock frequency is 150250 MHz and the MDC clock frequency is CSR clock/102.
- 0101: The CSR clock frequency is 250300 MHz and the MDC clock is CSR clock/124.
- 0110, 0111: Reserved
When Bit 5 is set, you can achieve higher frequency of the MDC clock than the frequency limit of 2.5 MHz (specified in the IEEE Std 802.3) and program a clock divider of lower value.
For example,
when CSR clock is of 100 MHz frequency and you program these bits as 1010,
then the resultant MDC clock is of 12.5 MHz which is outside the limit of IEEE 802.3 specified range.
Program the following values only if the interfacing chips support faster MDC clocks.
- 1000: CSR clock/4
- 1001: CSR clock/6
- 1010: CSR clock/8
- 1011: CSR clock/10
- 1100: CSR clock/12
- 1101: CSR clock/14
- 1110: CSR clock/16
- 1111: CSR clock/18 These bits are not used for accessing RevMII. These bits are read-only if the RevMII interface is selected as single PHY interface.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GW</name>
              <description>GMII Write
 When set, this bit indicates to the PHY or RevMII that this is a Write operation using the GMII Data register. If this bit is not set,
it indicates that this is a Read operation, that is, placing the data in the GMII Data register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GB</name>
              <description>GMII Busy
 This bit should read logic 0 before writing to Register 4 and Register 5.
During a PHY or RevMII register access, the software sets this bit to 1b1 to indicate that a Read or Write access is in progress.
 Register 5 is invalid until this bit is cleared by the MAC.
Therefore, Register 5 (GMII Data) should be kept valid until the MAC clears this bit during a PHY Write operation.
Similarly for a read operation, the contents of Register 5 are not valid until this bit is cleared.
The subsequent read or write operation should happen only after the previous operation is complete.
Because there is no acknowledgment from the PHY to MAC after a read or write operation is completed,
there is no change in the functionality of this bit even when the PHY is not present.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GMII_DATA</name>
          <description>GMII Data Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>GD</name>
              <description>GMII Data
 This field contains the 16-bit data value read from the PHY or RevMII after a Management Read operation
or the 16-bit data value to be written to the PHY or RevMII before a Management Write operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLOWCTRL</name>
          <description>Flow Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF00BF</resetMask>
          <fields>
            <field>
              <name>PT</name>
              <description>Pause Time
 This field holds the value to be used in the Pause Time field in the transmit control frame.
If the Pause Time bits is configured to be double-synchronized to the (G)MII clock domain,
 then consecutive writes to this register should be performed only after at least four clock cycles in the destination clock domain.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZPQ</name>
              <description>Disable Zero-Quanta Pause
 When this bit is set, it disables the automatic generation of the Zero-Quanta Pause frames on the de-assertion of
the flow-control signal from the FIFO layer (MTL or external sideband flow control signal sbd_flowctrl_i/mti_flowctrl_i).
When this bit is reset, normal operation with automatic Zero-Quanta Pause frame generation is enabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLT</name>
              <description>Pause Low Threshold
 This field configures the threshold of the Pause timer at which the input flow control signal mti_flowctrl_i (or sbd_flowctrl_i) is checked for automatic retransmission of the Pause frame.
The threshold values should be always less than the Pause Time configured in Bits[31:16].
 For example, if PT = 100H (256 slot-times), and PLT = 01,
then a second Pause frame is automatically transmitted if the mti_flowctrl_i signal is asserted at 228 (256  28) slot times after the first Pause frame is transmitted.
The following list provides the threshold values for different values:
- 00: The threshold is Pause time minus 4 slot times (PT  4 slot times).
- 01: The threshold is Pause time minus 28 slot times (PT  28 slot times).
- 10: The threshold is Pause time minus 144 slot times (PT  144 slot times).
- 11: The threshold is Pause time minus 256 slot times (PT  256 slot times). The slot time is defined as the time taken to transmit 512 bits (64 bytes) on the GMII or MII interface.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UP</name>
              <description>Unicast Pause Frame Detect A pause frame is processed when it has the unique multicast address specified in the IEEE Std 802.3.
When this bit is set, the MAC can also detect Pause frames with unicast address of the station.
This unicast address should be as specified in the MAC Address0 High Register and MAC Address0 Low Register.
When this bit is reset, the MAC only detects Pause frames with unique multicast address.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFE</name>
              <description>Receive Flow Control Enable
 When this bit is set, the MAC decodes the received Pause frame and disables its transmitter for a specified (Pause) time. When this bit is reset, the decode function of the Pause frame is disabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFE</name>
              <description>Transmit Flow Control Enable
In the full-duplex mode, when this bit is set, the MAC enables the flow control operation to transmit Pause frames.
When this bit is reset, the flow control operation in the MAC is disabled, and the MAC does not transmit any Pause frames.
In the half-duplex mode, when this bit is set, the MAC enables the backpressure operation. When this bit is reset, the backpressure feature is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FCB_BPA</name>
              <description>Flow Control Busy or Backpressure Activate
 This bit initiates a Pause frame in the full-duplex mode and activates the backpressure function in the half-duplex mode if the TFE bit is set.
In the full-duplex mode, this bit should be read as 1'b0 before writing to the Flow Control register.
 To initiate a Pause frame, the Application must set this bit to 1'b1.
During a transfer of the Control Frame, this bit continues to be set to signify that a frame transmission is in progress.
After the completion of Pause frame transmission, the MAC resets this bit to 1'b0.
The Flow Control register should not be written to until this bit is cleared. In the half-duplex mode,
when this bit is set (and TFE is set), then backpressure is asserted by the MAC.
During backpressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision.
This control register bit is logically ORed with the mti_flowctrl_i input signal for the backpressure function.
When the MAC is configured for the full-duplex mode, the BPA is automatically disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VLAN_TAG</name>
          <description>VLAN Tag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>VTHM</name>
              <description>VLAN Tag Hash Table Match Enable
 When set, the most significant four bits of the VLAN tags CRC are used to index the content of Register 354 (VLAN Hash Table Register).
A value of 1 in the VLAN Hash Table register, corresponding to the index, indicates that the frame matched the VLAN hash table.
When Bit 16 (ETV) is set, the CRC of the 12-bit VLAN Identifier (VID) is used for comparison whereas when ETV is reset,
the CRC of the 16-bit VLAN tag is used for comparison. When reset, the VLAN Hash Match operation is not performed.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ESVL</name>
              <description>Enable S-VLAN
 When this bit is set, the MAC transmitter and receiver also consider the S-VLAN (Type = 0x88A8) frames as valid VLAN tagged frames.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VTIM</name>
              <description>VLAN Tag Inverse Match Enable
When set, this bit enables the VLAN Tag inverse matching. The frames that do not have matching VLAN Tag are marked as matched. When reset, this bit enables the VLAN Tag perfect matching.
 The frames with matched VLAN Tag are marked as matched.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETV</name>
              <description>Enable 12-Bit VLAN Tag Comparison
 When this bit is set, a 12-bit VLAN identifier is used for comparing and filtering instead of the complete 16-bit VLAN tag.
 Bits [11:0] of VLAN tag are compared with the corresponding field in the received VLAN-tagged frame. Similarly, when enabled,
only 12 bits of the VLAN tag in the received frame are used for hash-based VLAN filtering.
When this bit is reset, all 16 bits of the 15th and 16th bytes of the received VLAN frame are used for comparison and VLAN hash filtering.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VL</name>
              <description>VLAN Tag Identifier for Receive Frames
 This field contains the 802.1Q VLAN tag to identify the VLAN frames and is compared to the 15th and 16th bytes of the frames being received for VLAN frames.
The following list describes the bits of this field:
 - Bits [15:13]: User Priority
- Bit 12: Canonical Format Indicator (CFI) or Drop Eligible Indicator (DEI)
- Bits[11:0]: VLAN tags VLAN Identifier (VID) field When the ETV bit is set, only the VID (Bits[11:0]) is used for comparison.
   If VL (VL[11:0] if ETV is set) is all zeros, the MAC does not check the fifteenth and 16th bytes for VLAN tag comparison,
  and declares all frames with a Type field value of 0x8100 or 0x88a8 as VLAN frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RWKFRMFILT</name>
          <description>Remote Wake-Up Frame Filter Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPFRMFILT</name>
              <description>This is the address through which the application writes or reads the remote wake-up frame filter registers (wkupfmfilter_reg).
The wkupfmfilter_reg register is a pointer to eight wkupfmfilter_reg registers.
The wkupfmfilter_reg register is loaded by sequentially loading the eight register values.
Eight sequential writes to this address (0x0028) write all wkupfmfilter_reg registers.
 Similarly, eight sequential reads from this address (0x0028) read all wkupfmfilter_reg registers</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMT_CSR</name>
          <description>PMT Control and Status Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x9F000267</resetMask>
          <fields>
            <field>
              <name>RWKFILTRST</name>
              <description>Remote Wake-Up Frame Filter Register Pointer Reset
When this bit is set, it resets the remote wake-up frame filter register pointer to 3b000. It is automatically cleared after 1 clock cycle.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWKPTR</name>
              <description>Remote Wake-up FIFO Pointer
This field gives the current value (0 to 31) of the Remote Wake-up Frame filter register pointer. When the value of this pointer is equal to 7, 15, 23 or 31,
the contents of the Remote Wake-up Frame Filter Register are transferred to the clk_rx_i domain when a write occurs to that register.
 The maximum value of the pointer is 7, 15, 23 and 31 respectively depending on the number of Remote Wakeup Filters selected during configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GLBLUCAST</name>
              <description>Global Unicast
When set, enables any unicast packet filtered by the MAC (DAF) address recognition to be a remote wake-up frame.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWKPRCVD</name>
              <description>Remote Wake-Up Frame Received
When set, this bit indicates the power management event is generated because of the reception of a remote wake-up frame. This bit is cleared by a Read into this register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MGKPRCVD</name>
              <description>Magic Packet Received
When set, this bit indicates that the power management event is generated because of the reception of a magic packet. This bit is cleared by a Read into this register.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWKPKTEN</name>
              <description>Remote Wake-Up Frame Enable
When set, enables generation of a power management event because of remote wake-up frame reception.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MGKPKTEN</name>
              <description>Magic Packet Enable
When set, enables generation of a power management event because of magic packet reception.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDWN</name>
              <description>Power Down
When set, the MAC receiver drops all received frames until it receives the expected magic packet or remote wake-up frame.
This bit is then self-cleared and the power-down mode is disabled.
The Software can also clear this bit before the expected magic packet or remote wake-up frame is received.
The frames, received by the MAC after this bit is cleared, are forwarded to the application.
This bit must only be set when the Magic Packet Enable, Global Unicast, or Remote Wake-Upr Fame Enable bit is set high.
Note: You can gate-off the CSR clock during the power-down mode.
However, when the CSR clock is gated-off, you cannot perform any read or write operations on this register. Therefore, the Software cannot clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI_CSR</name>
          <description>LPI Control and Status Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F030F</resetMask>
          <fields>
            <field>
              <name>LPITXA</name>
              <description>LPI TX Automate
This bit controls the behavior of the MAC when it is entering or coming out of the LPI mode on the transmit side.
This bit is not functional in the GMAC-CORE configuration in which the Tx clock gating is done during the LPI mode. If the LPITXA and LPIEN bits are set to 1,
the MAC enters the LPI mode only after all outstanding frames (in the core) and pending frames (in the application interface) have been transmitted.
The MAC comes out of the LPI mode when the application sends any frame for transmission or the application issues a TX FIFO Flush command.
 In addition, the MAC automatically clears the LPIEN bit when it exits the LPI state.
If TX FIFO Flush is set in Bit 20 of Register 6 (Operation Mode Register),
when the MAC is in the LPI mode, the MAC exits the LPI mode.
When this bit is 0, the LPIEN bit directly controls behavior of the MAC when it is entering or coming out of the LPI mode.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLSEN</name>
              <description>PHY Link Status Enable
This bit enables the link status received on the RGMII, SGMII, or SMII receive paths to be used for activating the LPI LS TIMER.
When set, the MAC uses the link-status bits of Register 54 (SGMII/RGMII/SMII Control and Status Register) and Bit 17 (PLS) for the LPI LS Timer trigger.
 When cleared, the MAC ignores the link-status bits of Register 54 and takes only the PLS bit. This bit is RO and reserved if you have not selected the RGMII, SGMII, or SMII PHY interface.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLS</name>
              <description>PHY Link Status
This bit indicates the link status of the PHY. The MAC Transmitter asserts the LPI pattern only when the link status is up (okay) at least for the time indicated by the LPI LS TIMER.
When set, the link is considered to be okay (up) and when reset, the link is considered to be down.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPIEN</name>
              <description>LPI Enable
When set, this bit instructs the MAC Transmitter to enter the LPI state. When reset, this bit instructs the MAC to exit the LPI state and resume normal transmission.
This bit is cleared when the LPITXA bit is set and the MAC exits the LPI state because of the arrival of a new packet for transmission.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLPIST</name>
              <description>Receive LPI State
When set, this bit indicates that the MAC is receiving the LPI pattern on the GMII or MII interface.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPIST</name>
              <description>Transmit LPI State
When set, this bit indicates that the MAC is transmitting the LPI pattern on the GMII or MII interface.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLPIEX</name>
              <description>Receive LPI Exit
When set, this bit indicates that the MAC Receiver has stopped receiving the LPI pattern on the GMII or MII interface, exited the LPI state, and resumed the normal reception.
This bit is cleared by a read into this register.
Note: This bit may not get set if the MAC stops receiving the LPI pattern for a very short duration, such as, less than 3 clock cycles of CSR clock.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLPIEN</name>
              <description>Receive LPI Entry
When set, this bit indicates that the MAC Receiver has received an LPI pattern and entered the LPI state. This bit is cleared by a read into this register.
Note: This bit may not get set if the MAC stops receiving the LPI pattern for a very short duration, such as, less than 3 clock cycles of CSR clock.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPIEX</name>
              <description>Transmit LPI Exit
When set, this bit indicates that the MAC transmitter has exited the LPI state after the user has cleared the LPIEN bit and the LPI TW Timer has expired. This bit is cleared by a read into this register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPIEN</name>
              <description>Transmit LPI Entry
 When set, this bit indicates that the MAC Transmitter has entered the LPI state because of the setting of the LPIEN bit. This bit is cleared by a read into this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPI_TCR</name>
          <description>LPI Timers Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>LST</name>
              <description>LPI LS TIMER
This field specifies the minimum time (in milliseconds) for which the link status from the PHY should be up (OKAY) before the LPI pattern can be transmitted to the PHY.
 The MAC does not transmit the LPI pattern even when the LPIEN bit is set unless the LPI LS Timer reaches the programmed terminal count.
The default value of the LPI LS Timer is 1000 (1 sec) as defined in the IEEE standard.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWT</name>
              <description>LPI TW TIMER
This field specifies the minimum time (in microseconds) for which the MAC waits after it stops transmitting
 the LPI pattern to the PHY and before it resumes the normal transmission.
The TLPIEX status bit is set after the expiry of this timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_STATUS</name>
          <description>Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000EFF</resetMask>
          <fields>
            <field>
              <name>GPIIS</name>
              <description>GPI Interrupt Status
When the GPIO feature is enabled, this bit is set when any active event (LL or LH) occurs on the GPIS field (Bits [3:0])
 of Register 56 (General Purpose IO Register) and the corresponding GPIE bit is enabled.
This bit is cleared on reading lane 0 (GPIS) of Register 56 (General Purpose IO Register).
 When the GPIO feature is not enabled, this bit is reserved.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LPIIS</name>
              <description>LPI Interrupt Status
When the Energy Efficient Ethernet feature is enabled, this bit is set for any LPI state entry or exit in the MAC Transmitter or Receiver.
This bit is cleared on reading Bit 0 of Register 12 (LPI Control and Status Register). In all other modes, this bit is reserved.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSIS</name>
              <description>Timestamp Interrupt Status
When the Advanced Timestamp feature is enabled, this bit is set when any of the following conditions is true:
- The system time value equals or exceeds the value specified in the Target Time High and Low registers.
- There is an overflow in the seconds register.
 - The Auxiliary snapshot trigger is asserted. This bit is cleared on reading Bit 0 of Register 458 (Timestamp Status Register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCRXIPIS</name>
              <description>MMC Receive Checksum Offload Interrupt Status
This bit is set high when an interrupt is generated in the MMC Receive Checksum Offload Interrupt Register. This bit is cleared when all the bits in this interrupt register are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCTXIS</name>
              <description>MMC Transmit Interrupt Status
This bit is set high when an interrupt is generated in the MMC Transmit Interrupt Register. This bit is cleared when all the bits in this interrupt register are cleared.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCRXIS</name>
              <description>MMC Receive Interrupt Status
This bit is set high when an interrupt is generated in the MMC Receive Interrupt Register. This bit is cleared when all the bits in this interrupt register are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MMCIS</name>
              <description>MMC Interrupt Status
This bit is set high when any of the Bits [7:5] is set high and cleared only when all of these bits are low.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMTIS</name>
              <description>PMT Interrupt Status
This bit is set when a magic packet or remote wake-up frame is received in the power-down mode (see Bits 5 and 6 in the PMT Control and Status Register).
This bit is cleared when both Bits[6:5] are cleared because of a read operation to the PMT Control and Status register.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PCSANCIS</name>
              <description>PCS Auto-Negotiation Complete
This bit is set when the Auto-negotiation is completed in the TBI, RTBI, or SGMII PHY interface (Bit 5 in Register 49 (AN Status Register)).
This bit is cleared when you perform a read operation to the AN Status register.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PCSLCHGIS</name>
              <description>PCS Link Status Changed
This bit is set because of any change in Link Status in the TBI, RTBI, or SGMII PHY interface (Bit 2 in Register 49 (AN Status Register)).
This bit is cleared when you perform a read operation on the AN Status register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RGSMIIIS</name>
              <description>RGMII or SMII Interrupt Status
This bit is set because of any change in value of the Link Status of RGMII or SMII interface (Bit 3 in Register 54 (SGMII/RGMII/SMII Control and Status Register)).
This bit is cleared when you perform a read operation on the SGMII/RGMII/SMII Control and Status Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000060F</resetMask>
          <fields>
            <field>
              <name>LPIIM</name>
              <description>LPI Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of the LPI Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIM</name>
              <description>Timestamp Interrupt Mask
 When set, this bit disables the assertion of the interrupt signal because of the setting of Timestamp Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMTIM</name>
              <description>PMT Interrupt Mask
 When set, this bit disables the assertion of the interrupt signal because of the setting of PMT Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCSANCIM</name>
              <description>PCS AN Completion Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of PCS Auto-negotiation complete bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCSLCHGIM</name>
              <description>PCS Link Status Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of the PCS Link-status changed bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RGSMIIIM</name>
              <description>RGMII or SMII Interrupt Mask
When set, this bit disables the assertion of the interrupt signal because of the setting of the RGMII or SMII Interrupt Status bit in Register 14 (Interrupt Status Register).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAC_ADDR_0_HIGH</name>
          <description>MAC Address 0 High Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>AE</name>
              <description>Address Enable
 This bit is RO. The bit value is fixed at 1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADDRHI</name>
              <description>MAC Address0 [47:32]
 This field contains the upper 16 bits (47:32) of the first 6-byte MAC address. The MAC uses this field for filtering the received frames and inserting the MAC address in the Transmit Flow Control (Pause) Frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MAC_ADDR_0_LOW</name>
          <description>MAC Address 0 Low Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDRLO</name>
              <description>MAC Address0 [31:0]
 This field contains the lower 32 bits of the first 6-byte MAC address. This is used by the MAC for filtering the received frames and inserting the MAC address in the Transmit Flow Control (Pause) Frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>1,2,3,4</dimIndex>
          <name>MAC_ADDR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x48</addressOffset>
          <register>
            <name>HIGH</name>
            <description>MAC Address High Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFF00FFFF</resetMask>
            <fields>
              <field>
                <name>AE</name>
                <description>Address Enable
When this bit is set, the address filter module uses the second MAC address for perfect filtering. When this bit is reset, the address filter module ignores the address for filtering.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SA</name>
                <description>Source Address
When this bit is set, the MAC Address1[47:0] is used to compare with the SA fields of the received frame. When this bit is reset, the MAC Address1[47:0] is used to compare with the DA fields of the received frame.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MBC</name>
                <description>Mask Byte Control
These bits are mask control bits for comparison of each of the MAC Address bytes.
When set high, the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers.
Each bit controls the masking of the bytes as follows:
- Bit 29: Register 18[15:8]
- Bit 28: Register 18[7:0]
- Bit 27: Register 19[31:24] -
...
- Bit 24: Register 19[7:0]
You can filter a group of addresses (known as group address filtering) by masking one or more bytes of the address.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ADDRHI</name>
                <description>MAC Address1 [47:32]
This field contains the upper 16 bits (47:32) of the second 6-byte MAC address.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOW</name>
            <description>MAC Address Low Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADDRLO</name>
                <description>MAC Address1 [31:0]
This field contains the lower 32 bits of the second 6-byte MAC address. The content of this field is undefined until loaded by the Application after the initialization process.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>XMII_CSR</name>
          <description>SGMII/RGMII/SMII Control and Status Register</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>FALSCARDET</name>
              <description>False Carrier Detected
 This bit indicates whether the SMII PHY detected false carrier (1'b1). This bit is reserved when the MAC is configured for the SGMII or RGMII PHY interface.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>JABTO</name>
              <description>Jabber Timeout
 This bit indicates whether there is jabber timeout error (1'b1) in the received frame. This bit is reserved when the MAC is configured for the SGMII or RGMII PHY interface.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LNKSTS</name>
              <description>Link Status
 This bit indicates whether the link between the local PHY and the remote PHY is up or down.
It gives the status of the link between the SGMII of MAC and the SGMII of the local PHY.
The status bits are received from the local PHY during ANEG betweent he MAC and PHY on the SGMII link.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LNKSPEED</name>
              <description>Link Speed
 This bit indicates the current speed of the link:
- 00: 2.5 MHz
- 01: 25 MHz
- 10: 125 MHz Bit 2 is reserved when the MAC is configured for the SMII PHY interface.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LNKMOD</name>
              <description>Link Mode
 This bit indicates the current mode of operation of the link:
- 1b0: Half-duplex mode
- 1b1: Full-duplex mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDOG_WTO</name>
          <description>Watchdog Timeout Register</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00013FFF</resetMask>
          <fields>
            <field>
              <name>PWE</name>
              <description>Programmable Watchdog Enable
 When this bit is set and Bit 23 (WD) of Register 0 (MAC Configuration Register) is reset,
the WTO field (Bits[13:0]) is used as watchdog timeout for a received frame.
When this bit is cleared, the watchdog timeout for a received frame is controlled by the setting of Bit 23 (WD) and Bit 20 (JE) in Register 0 (MAC Configuration Register).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WTO</name>
              <description>Watchdog Timeout
When Bit 16 (PWE) is set and Bit 23 (WD) of Register 0 (MAC Configuration Register) is reset,
this field is used as watchdog timeout for a received frame.
 If the length of a received frame exceeds the value of this field, such frame is terminated and declared as an error frame.
Note: When Bit 16 (PWE) is set, the value in this field should be more than 1,522 (0x05F2).
Otherwise, the IEEE Std 802.3-specified valid tagged frames are declared as error frames and are dropped.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_cntrl</name>
          <description>MMC Control establishes the operating mode of MMC.</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000013F</resetMask>
          <fields>
            <field>
              <name>UCDBC</name>
              <description>Update MMC Counters for Dropped Broadcast Frames
When set, the MAC updates all related MMC Counters for Broadcast frames that are dropped because of the setting of Bit 5 (DBF) of Register 1 (MAC Frame Filter).
 When reset, the MMC Counters are not updated for dropped Broadcast frames.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTPRSTLVL</name>
              <description>Full-Half Preset
When this bit is low and Bit 4 is set, all MMC counters get preset to almost-half value. All octet counters get preset to 0x7FFF_F800 (half
- 2KBytes) and all frame-counters gets preset to 0x7FFF_FFF0 (half
- 16). When this bit is high and Bit 4 is set, all MMC counters get preset to almost-full value. All octet counters get preset to 0xFFFF_F800 (full
- 2KBytes) and all frame-counters gets preset to 0xFFFF_FFF0 (full
- 16). For 16-bit counters, the almost-half preset values are 0x7800 and 0x7FF0 for the respective octet and frame counters. Similarly, the almost-full preset values for the 16-bit counters are 0xF800 and 0xFFF0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTPRST</name>
              <description>Counters Preset
When this bit is set, all counters are initialized or preset to almost full or almost half according to Bit 5. This bit is cleared automatically after 1 clock cycle.
This bit, along with Bit 5, is useful for debugging and testing the assertion of interrupts because of MMC counter becoming half-full or full.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTFREEZ</name>
              <description>MMC Counter Freeze
When this bit is set, it freezes all MMC counters to their current value.
Until this bit is reset to 0, no MMC counter is updated because of any transmitted or received frame.
 If any MMC counter is read with the Reset on Read bit set, then that counter is also cleared in this mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTONRD</name>
              <description>Reset on Read
When this bit is set, the MMC counters are reset to zero after Read (self-clearing after reset). The counters are cleared when the least significant byte lane (Bits[7:0]) is read.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTSTOPRO</name>
              <description>Counter Stop Rollover
When this bit is set, the counter does not roll over to zero after reaching the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CNTRST</name>
              <description>Counters Reset
When this bit is set, all counters are reset. This bit is cleared automatically after 1 clock cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_rx</name>
          <description>MMC Receive Interrupt</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>RXCTRLFIS</name>
              <description>MMC Receive Control Frame Counter Interrupt Status
This bit is set when the rxctrlframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRCVERRFIS</name>
              <description>MMC Receive Error Frame Counter Interrupt Status
This bit is set when the rxrcverror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXWDOGFIS</name>
              <description>MMC Receive Watchdog Error Frame Counter Interrupt Status
This bit is set when the rxwatchdog error counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXVLANGBFIS</name>
              <description>MMC Receive VLAN Good Bad Frame Counter Interrupt Status
This bit is set when the rxvlanframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFOVFIS</name>
              <description>MMC Receive FIFO Overflow Frame Counter Interrupt Status
This bit is set when the rxfifooverflow counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPAUSFIS</name>
              <description>MMC Receive Pause Frame Counter Interrupt Status
This bit is set when the rxpauseframes counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXORANGEFIS</name>
              <description>MMC Receive Out Of Range Error Frame Counter Interrupt Status.
This bit is set when the rxoutofrangetype counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLENERFIS</name>
              <description>MMC Receive Length Error Frame Counter Interrupt Status
This bit is set when the rxlengtherror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUCGFIS</name>
              <description>MMC Receive Unicast Good Frame Counter Interrupt Status
This bit is set when the rxunicastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX1024TMAXOCTGBFIS</name>
              <description>MMC Receive 1024 to Maximum Octet Good Bad Frame Counter Interrupt Status.
This bit is set when the rx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX512T1023OCTGBFIS</name>
              <description>MMC Receive 512 to 1023 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX256T511OCTGBFIS</name>
              <description>MMC Receive 256 to 511 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX128T255OCTGBFIS</name>
              <description>MMC Receive 128 to 255 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX65T127OCTGBFIS</name>
              <description>MMC Receive 65 to 127 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx65to127octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX64OCTGBFIS</name>
              <description>MMC Receive 64 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the rx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOSIZEGFIS</name>
              <description>MMC Receive Oversize Good Frame Counter Interrupt Status
This bit is set when the rxoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUSIZEGFIS</name>
              <description>MMC Receive Undersize Good Frame Counter Interrupt Status
This bit is set when the rxundersize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXJABERFIS</name>
              <description>MMC Receive Jabber Error Frame Counter Interrupt Status
This bit is set when the rxjabbererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRUNTFIS</name>
              <description>MMC Receive Runt Frame Counter Interrupt Status
This bit is set when the rxrunterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXALGNERFIS</name>
              <description>MMC Receive Alignment Error Frame Counter Interrupt Status
This bit is set when the rxalignmenterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCRCERFIS</name>
              <description>MMC Receive CRC Error Frame Counter Interrupt Status
This bit is set when the rxcrcerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXMCGFIS</name>
              <description>MMC Receive Multicast Good Frame Counter Interrupt Status
This bit is set when the rxmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBCGFIS</name>
              <description>MMC Receive Broadcast Good Frame Counter Interrupt Status
This bit is set when the rxbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGOCTIS</name>
              <description>MMC Receive Good Octet Counter Interrupt Status
This bit is set when the rxoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGBOCTIS</name>
              <description>MMC Receive Good Bad Octet Counter Interrupt Status
This bit is set when the rxoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGBFRMIS</name>
              <description>MMC Receive Good Bad Frame Counter Interrupt Status
This bit is set when the rxframecount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_tx</name>
          <description>MMC Transmit Interrupt</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOSIZEGFIS</name>
              <description>MMC Transmit Oversize Good Frame Counter Interrupt Status
This bit is set when the txoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXVLANGFIS</name>
              <description>MMC Transmit VLAN Good Frame Counter Interrupt Status
This bit is set when the txvlanframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPAUSFIS</name>
              <description>MMC Transmit Pause Frame Counter Interrupt Status
This bit is set when the txpauseframeserror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXDEFFIS</name>
              <description>MMC Transmit Excessive Deferral Frame Counter Interrupt Status
This bit is set when the txexcessdef counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGFRMIS</name>
              <description>MMC Transmit Good Frame Counter Interrupt Status
This bit is set when the txframecount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGOCTIS</name>
              <description>MMC Transmit Good Octet Counter Interrupt Status
This bit is set when the txoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCARERFIS</name>
              <description>MMC Transmit Carrier Error Frame Counter Interrupt Status
This bit is set when the txcarriererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXCOLFIS</name>
              <description>MMC Transmit Excessive Collision Frame Counter Interrupt Status
This bit is set when the txexesscol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLATCOLFIS</name>
              <description>MMC Transmit Late Collision Frame Counter Interrupt Status
This bit is set when the txlatecol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDEFFIS</name>
              <description>MMC Transmit Deferred Frame Counter Interrupt Status
This bit is set when the txdeferred counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCOLGFIS</name>
              <description>MMC Transmit Multiple Collision Good Frame Counter Interrupt Status
This bit is set when the txmulticol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCOLGFIS</name>
              <description>MMC Transmit Single Collision Good Frame Counter Interrupt Status
This bit is set when the txsinglecol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUFLOWERFIS</name>
              <description>MMC Transmit Underflow Error Frame Counter Interrupt Status
This bit is set when the txunderflowerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGBFIS</name>
              <description>MMC Transmit Broadcast Good Bad Frame Counter Interrupt Status
This bit is set when the txbroadcastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGBFIS</name>
              <description>MMC Transmit Multicast Good Bad Frame Counter Interrupt Status
The bit is set when the txmulticastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUCGBFIS</name>
              <description>MMC Transmit Unicast Good Bad Frame Counter Interrupt Status
This bit is set when the txunicastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX1024TMAXOCTGBFIS</name>
              <description>MMC Transmit 1024 to Maximum Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX512T1023OCTGBFIS</name>
              <description>MMC Transmit 512 to 1023 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX256T511OCTGBFIS</name>
              <description>MMC Transmit 256 to 511 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX128T255OCTGBFIS</name>
              <description>MMC Transmit 128 to 255 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX65T127OCTGBFIS</name>
              <description>MMC Transmit 65 to 127 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx65to127octets_gb counter reaches half the maximum value, and also when it reaches the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX64OCTGBFIS</name>
              <description>MMC Transmit 64 Octet Good Bad Frame Counter Interrupt Status
This bit is set when the tx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGFIS</name>
              <description>MMC Transmit Multicast Good Frame Counter Interrupt Status
This bit is set when the txmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGFIS</name>
              <description>MMC Transmit Broadcast Good Frame Counter Interrupt Status
This bit is set when the txbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBFRMIS</name>
              <description>MMC Transmit Good Bad Frame Counter Interrupt Status
This bit is set when the txframecount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBOCTIS</name>
              <description>MMC Transmit Good Bad Octet Counter Interrupt Status
This bit is set when the txoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_mask_rx</name>
          <description>MMC Receive Interrupt mask</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFE</resetMask>
          <fields>
            <field>
              <name>RXCTRLFIM</name>
              <description>MMC Receive Control Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxctrlframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRCVERRFIM</name>
              <description>MMC Receive Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxrcverror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXWDOGFIM</name>
              <description>MMC Receive Watchdog Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxwatchdog counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXVLANGBFIM</name>
              <description>MMC Receive VLAN Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxvlanframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXFOVFIM</name>
              <description>MMC Receive FIFO Overflow Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxfifooverflow counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPAUSFIM</name>
              <description>MMC Receive Pause Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxpauseframes counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXORANGEFIM</name>
              <description>MMC Receive Out Of Range Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxoutofrangetype counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXLENERFIM</name>
              <description>MMC Receive Length Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxlengtherror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUCGFIM</name>
              <description>MMC Receive Unicast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxunicastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX1024TMAXOCTGBFIM</name>
              <description>MMC Receive 1024 to Maximum Octet Good Bad Frame Counter Interrupt Mask.
Setting this bit masks the interrupt when the rx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX512T1023OCTGBFIM</name>
              <description>MMC Receive 512 to 1023 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX256T511OCTGBFIM</name>
              <description>MMC Receive 256 to 511 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX128T255OCTGBFIM</name>
              <description>MMC Receive 128 to 255 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX65T127OCTGBFIM</name>
              <description>MMC Receive 65 to 127 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx65to127octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX64OCTGBFIM</name>
              <description>MMC Receive 64 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOSIZEGFIM</name>
              <description>MMC Receive Oversize Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUSIZEGFIM</name>
              <description>MMC Receive Undersize Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxundersize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXJABERFIM</name>
              <description>MMC Receive Jabber Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxjabbererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXRUNTFIM</name>
              <description>MMC Receive Runt Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxrunterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXALGNERFIM</name>
              <description>MMC Receive Alignment Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxalignmenterror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXCRCERFIM</name>
              <description>MMC Receive CRC Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxcrcerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXMCGFIM</name>
              <description>MMC Receive Multicast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXBCGFIM</name>
              <description>MMC Receive Broadcast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGOCTIM</name>
              <description>MMC Receive Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXGBOCTIM</name>
              <description>MMC Receive Good Bad Octet Counter Interrupt Mask.
Setting this bit masks the interrupt when the rxoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_intr_mask_tx</name>
          <description>MMC Transmit Interrupt Mask</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03FFFFFF</resetMask>
          <fields>
            <field>
              <name>TXOSIZEGFIM</name>
              <description>MMC Transmit Oversize Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txoversize_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXVLANGFIM</name>
              <description>MMC Transmit VLAN Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txvlanframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPAUSFIM</name>
              <description>MMC Transmit Pause Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txpauseframes counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXDEFFIM</name>
              <description>MMC Transmit Excessive Deferral Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txexcessdef counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGFRMIM</name>
              <description>MMC Transmit Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txframecount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGOCTIM</name>
              <description>MMC Transmit Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the txoctetcount_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXCARERFIM</name>
              <description>MMC Transmit Carrier Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txcarriererror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXEXCOLFIM</name>
              <description>MMC Transmit Excessive Collision Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txexcesscol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXLATCOLFIM</name>
              <description>MMC Transmit Late Collision Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txlatecol counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXDEFFIM</name>
              <description>MMC Transmit Deferred Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txdeferred counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCOLGFIM</name>
              <description>MMC Transmit Multiple Collision Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txmulticol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCOLGFIM</name>
              <description>MMC Transmit Single Collision Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txsinglecol_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUFLOWERFIM</name>
              <description>MMC Transmit Underflow Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txunderflowerror counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGBFIM</name>
              <description>MMC Transmit Broadcast Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txbroadcastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGBFIM</name>
              <description>MMC Transmit Multicast Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txmulticastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXUCGBFIM</name>
              <description>MMC Transmit Unicast Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txunicastframes_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX1024TMAXOCTGBFIM</name>
              <description>MMC Transmit 1024 to Maximum Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx1024tomaxoctets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX512T1023OCTGBFIM</name>
              <description>MMC Transmit 512 to 1023 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx512to1023octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX256T511OCTGBFIM</name>
              <description>MMC Transmit 256 to 511 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx256to511octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX128T255OCTGBFIM</name>
              <description>MMC Transmit 128 to 255 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx128to255octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX65T127OCTGBFIM</name>
              <description>MMC Transmit 65 to 127 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx65to127octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX64OCTGBFIM</name>
              <description>MMC Transmit 64 Octet Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the tx64octets_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXMCGFIM</name>
              <description>MMC Transmit Multicast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txmulticastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXBCGFIM</name>
              <description>MMC Transmit Broadcast Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txbroadcastframes_g counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBFRMIM</name>
              <description>MMC Transmit Good Bad Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the txframecount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXGBOCTIM</name>
              <description>MMC Transmit Good Bad Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the txoctetcount_gb counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx64octets_gb</name>
          <description>Number of good and bad frames transmitted with length 64 bytes,
exclusive of preamble and retried frames.</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length 64 bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx65to127octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
65 and 127 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 65 and 127 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx128to255octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
128 and 255 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 128 and 255 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx256to511octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
256 and 511 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 256 and 511 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx512to1023octets_gb</name>
          <description>Number of good and bad frames transmitted with length between
512 and 1,023 (inclusive) bytes, exclusive of preamble and retried
frames.</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 512 and 1,023 (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tx1024tomaxoctets_gb</name>
          <description>Number of good and bad frames transmitted with length between
1,024 and maxsize (inclusive) bytes, exclusive of preamble and
retried frames.</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames transmitted with length between 1,024 and maxsize (inclusive) bytes, exclusive of preamble and retried frames.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rxframecount_gb</name>
          <description>Number of good and bad frames received</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good and bad frames received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_ipc_intr_mask_rx</name>
          <description>MMC IPC Receive Checksum Offload Interrupt Mask maintains
the mask for the interrupt generated from the receive IPC statistic
counters.</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>RXICMPEROIM</name>
              <description>MMC Receive ICMP Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGOIM</name>
              <description>MMC Receive ICMP Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPEROIM</name>
              <description>MMC Receive TCP Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGOIM</name>
              <description>MMC Receive TCP Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPEROIM</name>
              <description>MMC Receive UDP Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGOIM</name>
              <description>MMC Receive IPV6 No Payload Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYOIM</name>
              <description>MMC Receive IPV6 Header Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HEROIM</name>
              <description>MMC Receive IPV6 Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GOIM</name>
              <description>MMC Receive IPV6 Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLOIM</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_udsbl_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGOIM</name>
              <description>MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_frag_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYOIM</name>
              <description>MMC Receive IPV4 No Payload Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HEROIM</name>
              <description>MMC Receive IPV4 Header Error Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GOIM</name>
              <description>MMC Receive IPV4 Good Octet Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPERFIM</name>
              <description>MMC Receive ICMP Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGFIM</name>
              <description>MMC Receive ICMP Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxicmp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPERFIM</name>
              <description>MMC Receive TCP Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGFIM</name>
              <description>MMC Receive TCP Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxtcp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPERFIM</name>
              <description>MMC Receive UDP Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGFIM</name>
              <description>MMC Receive UDP Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxudp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYFIM</name>
              <description>MMC Receive IPV6 No Payload Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HERFIM</name>
              <description>MMC Receive IPV6 Header Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GFIM</name>
              <description>MMC Receive IPV6 Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv6_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLFIM</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_udsbl_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGFIM</name>
              <description>MMC Receive IPV4 Fragmented Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_frag_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYFIM</name>
              <description>MMC Receive IPV4 No Payload Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HERFIM</name>
              <description>MMC Receive IPV4 Header Error Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GFIM</name>
              <description>MMC Receive IPV4 Good Frame Counter Interrupt Mask
Setting this bit masks the interrupt when the rxipv4_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>mmc_ipc_intr_rx</name>
          <description>MMC Receive Checksum Offload Interrupt maintains the interrupt
that the receive IPC statistic counters generate. See Table 4-25
for further detail.</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF3FFF</resetMask>
          <fields>
            <field>
              <name>RXICMPEROIS</name>
              <description>MMC Receive ICMP Error Octet Counter Interrupt Status
This bit is set when the rxicmp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGOIS</name>
              <description>MMC Receive ICMP Good Octet Counter Interrupt Status
This bit is set when the rxicmp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPEROIS</name>
              <description>MMC Receive TCP Error Octet Counter Interrupt Status
This bit is set when the rxtcp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGOIS</name>
              <description>MMC Receive TCP Good Octet Counter Interrupt Status
This bit is set when the rxtcp_gd_octets counter reaches half of the maximum value or the maximum value</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPEROIS</name>
              <description>MMC Receive UDP Error Octet Counter Interrupt Status
This bit is set when the rxudp_err_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGOIS</name>
              <description>MMC Receive UDP Good Octet Counter Interrupt Status
This bit is set when the rxudp_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYOIS</name>
              <description>MMC Receive IPV6 No Payload Octet Counter Interrupt Status
This bit is set when the rxipv6_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HEROIS</name>
              <description>MMC Receive IPV6 Header Error Octet Counter Interrupt Status
This bit is set when the rxipv6_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GOIS</name>
              <description>MMC Receive IPV6 Good Octet Counter Interrupt Status
This bit is set when the rxipv6_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLOIS</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Status
This bit is set when the rxipv4_udsbl_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGOIS</name>
              <description>MMC Receive IPV4 Fragmented Octet Counter Interrupt Status
This bit is set when the rxipv4_frag_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYOIS</name>
              <description>MMC Receive IPV4 No Payload Octet Counter Interrupt Status
This bit is set when the rxipv4_nopay_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HEROIS</name>
              <description>MMC Receive IPV4 Header Error Octet Counter Interrupt Status
This bit is set when the rxipv4_hdrerr_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GOIS</name>
              <description>MMC Receive IPV4 Good Octet Counter Interrupt Status
This bit is set when the rxipv4_gd_octets counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPERFIS</name>
              <description>MMC Receive ICMP Error Frame Counter Interrupt Status
This bit is set when the rxicmp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXICMPGFIS</name>
              <description>MMC Receive ICMP Good Frame Counter Interrupt Status
This bit is set when the rxicmp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPERFIS</name>
              <description>MMC Receive TCP Error Frame Counter Interrupt Status
This bit is set when the rxtcp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXTCPGFIS</name>
              <description>MMC Receive TCP Good Frame Counter Interrupt Status
This bit is set when the rxtcp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPERFIS</name>
              <description>MMC Receive UDP Error Frame Counter Interrupt Status
This bit is set when the rxudp_err_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXUDPGFIS</name>
              <description>MMC Receive UDP Good Frame Counter Interrupt Status
This bit is set when the rxudp_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6NOPAYFIS</name>
              <description>MMC Receive IPV6 No Payload Frame Counter Interrupt Status
This bit is set when the rxipv6_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6HERFIS</name>
              <description>MMC Receive IPV6 Header Error Frame Counter Interrupt Status
This bit is set when the rxipv6_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV6GFIS</name>
              <description>MMC Receive IPV6 Good Frame Counter Interrupt Status
This bit is set when the rxipv6_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4UDSBLFIS</name>
              <description>MMC Receive IPV4 UDP Checksum Disabled Frame Counter Interrupt Status
This bit is set when the rxipv4_udsbl_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4FRAGFIS</name>
              <description>MMC Receive IPV4 Fragmented Frame Counter Interrupt Status
This bit is set when the rxipv4_frag_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4NOPAYFIS</name>
              <description>MMC Receive IPV4 No Payload Frame Counter Interrupt Status
This bit is set when the rxipv4_nopay_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4HERFIS</name>
              <description>MMC Receive IPV4 Header Error Frame Counter Interrupt Status
This bit is set when the rxipv4_hdrerr_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXIPV4GFIS</name>
              <description>MMC Receive IPV4 Good Frame Counter Interrupt Status
This bit is set when the rxipv4_gd_frms counter reaches half of the maximum value or the maximum value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rxipv4_gd_fms</name>
          <description>Number of good IPv4 datagrams received with the TCP, UDP, or
ICMP payload</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRMCNT</name>
              <description>Number of good IPv4 datagrams received with the TCP, UDP, or ICMP payload</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>1</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0</dimIndex>
          <name>L3_L4_CFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <register>
            <name>L3_L4_CTRL</name>
            <description>Layer 3 and Layer 4 Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x003DFFFD</resetMask>
            <fields>
              <field>
                <name>L4DPIM0</name>
                <description>Layer 4 Destination Port Inverse Match Enable
 When set, this bit indicates that the Layer 4 Destination Port number field is enabled for inverse matching.
When reset, this bit indicates that the Layer 4 Destination Port number field is enabled for perfect matching.
 This bit is valid and applicable only when Bit 20 (L4DPM0) is set high.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4DPM0</name>
                <description>Layer 4 Destination Port Match Enable
 When set, this bit indicates that the Layer 4 Destination Port number field is enabled for matching.
When reset, the MAC ignores the Layer 4 Destination Port number field for matching.</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4SPIM0</name>
                <description>Layer 4 Source Port Inverse Match Enable
When set, this bit indicates that the Layer 4 Source Port number field is enabled for inverse matching.
When reset, this bit indicates that the Layer 4 Source Port number field is enabled for perfect matching.
This bit is valid and applicable only when Bit 18 (L4SPM0) is set high.</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4SPM0</name>
                <description>Layer 4 Source Port Match Enable
When set, this bit indicates that the Layer 4 Source Port number field is enabled for matching. When reset, the MAC ignores the Layer 4 Source Port number field for matching.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4PEN0</name>
                <description>Layer 4 Protocol Enable
When set, this bit indicates that the Source and Destination Port number fields for UDP frames are used for matching.
When reset, this bit indicates that the Source and Destination Port number fields for TCP frames are used for matching.
The Layer 4 matching is done only when either L4SPM0 or L4DPM0 bit is set high.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3HDBM0</name>
                <description>Layer 3 IP DA Higher Bits Match
 IPv4 Frames: This field contains the number of higher bits of IP Destination Address that are matched in the IPv4 frames. The following list describes the values of this field:
- 0: No bits are masked.
- 1: LSb[0] is masked.
- 2: Two LSbs [1:0] are masked. - ...
- 31: All bits except MSb are masked. IPv6 Frames: Bits [12:11] of this field correspond to Bits [6:5] of L3HSBM0,
which indicate the number of lower bits of IP Source or Destination Address that are masked in the IPv6 frames.
The following list describes the concatenated values of the L3HDBM0[1:0] and L3HSBM0 bits:
- 0: No bits are masked.
- 1: LSb[0] is masked.
- 2: Two LSbs [1:0] are masked. - 
- 127: All bits except MSb are masked. This field is valid and applicable only if L3DAM0 or L3SAM0 is set high.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3HSBM0</name>
                <description>Layer 3 IP SA Higher Bits Match
 IPv4 Frames: This field contains the number of lower bits of IP Source Address that are masked for matching in the IPv4 frames. The following list describes the values of this field:
- 0: No bits are masked.
- 1: LSb[0] is masked.
- 2: Two LSbs [1:0] are masked. - ...
- 31: All bits except MSb are masked. IPv6 Frames: This field contains Bits [4:0] of the field that indicates the number of higher bits of IP Source or Destination Address matched in the IPv6 frames.
This field is valid and applicable only if L3DAM0 or L3SAM0 is set high.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3DAIM0</name>
                <description>Layer 3 IP DA Inverse Match Enable
When set, this bit indicates that the Layer 3 IP Destination Address field is enabled for inverse matching.
When reset, this bit indicates that the Layer 3 IP Destination Address field is enabled for perfect matching. This bit is valid and applicable only when Bit 4 (L3DAM0) is set high.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3DAM0</name>
                <description>Layer 3 IP DA Match Enable
When set, this bit indicates that Layer 3 IP Destination Address field is enabled for matching. When reset, the MAC ignores the Layer 3 IP Destination Address field for matching.
Note: When Bit 0 (L3PEN0) is set, you should set either this bit or Bit 2 (L3SAM0) because either IPv6 DA or SA can be checked for filtering.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3SAIM0</name>
                <description>Layer 3 IP SA Inverse Match Enable
When set, this bit indicates that the Layer 3 IP Source Address field is enabled for inverse matching. When reset, this bit indicates that the Layer 3 IP Source Address field is enabled for perfect matching.
This bit is valid and applicable only when Bit 2 (L3SAM0) is set high.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3SAM0</name>
                <description>Layer 3 IP SA Match Enable
When set, this bit indicates that the Layer 3 IP Source Address field is enabled for matching. When reset, the MAC ignores the Layer 3 IP Source Address field for matching.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L3PEN0</name>
                <description>Layer 3 Protocol Enable
 When set, this bit indicates that the Layer 3 IP Source or Destination Address matching is enabled for the IPv6 frames.
When reset, this bit indicates that the Layer 3 IP Source or Destination Address matching is enabled for the IPv4 frames.
The Layer 3 matching is done only when either L3SAM0 or L3DAM0 bit is set high.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L4_Addr</name>
            <description>Layer 4 Address Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L4DP0</name>
                <description>Layer 4 Destination Port Number Field
When Bit 16 (L4PEN0) is reset and Bit 20 (L4DPM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the TCP Destination Port Number field in the IPv4 or IPv6 frames.
When Bit 16 (L4PEN0) and Bit 20 (L4DPM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the UDP Destination Port Number field in the IPv4 or IPv6 frames.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>L4SP0</name>
                <description>Layer 4 Source Port Number Field
 When Bit 16 (L4PEN0) is reset and Bit 20 (L4DPM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
 this field contains the value to be matched with the TCP Source Port Number field in the IPv4 or IPv6 frames.
When Bit 16 (L4PEN0) and Bit 20 (L4DPM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the UDP Source Port Number field in the IPv4 or IPv6 frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_0</name>
            <description>Layer 3 Address 0 Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A00</name>
                <description>Layer 3 Address 0 Field
 When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [31:0] of the IP Source Address field in the IPv6 frames.
When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [31:0] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset and Bit 2 (L3SAM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with the IP Source Address field in the IPv4 frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_1</name>
            <description>Layer 3 Address 1 Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A10</name>
                <description>Layer 3 Address 1 Field
 When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [63:32] of the IP Source Address field in the IPv6 frames.
When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [63:32] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset and Bit 4 (L3DAM0) is set in Register 256 (Layer 3 and Layer 4 Control Register 0),
 this field contains the value to be matched with the IP Destination Address field in the IPv4 frames.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_2</name>
            <description>Layer 3 Address 2 Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A20</name>
                <description>Layer 3 Address 2 Field
 When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [95:64] of the IP Source Address field in the IPv6 frames.
When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains value to be matched with Bits [95:64] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset in Register 256 (Layer 3 and Layer 4 Control Register 0), this register is not used.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>L3_Addr_3</name>
            <description>Layer 3 Address 3 Register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>L3A30</name>
                <description>Layer 3 Address 3 Field When Bit 0 (L3PEN0) and Bit 2 (L3SAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [127:96] of the IP Source Address field in the IPv6 frames.
 When Bit 0 (L3PEN0) and Bit 4 (L3DAM0) are set in Register 256 (Layer 3 and Layer 4 Control Register 0),
this field contains the value to be matched with Bits [127:96] of the IP Destination Address field in the IPv6 frames.
When Bit 0 (L3PEN0) is reset in Register 256 (Layer 3 and Layer 4 Control Register 0), this register is not used.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>VLAN_TAG_INC_RPL</name>
          <description>VLAN Tag Inclusion or Replacement Register</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>CSVL</name>
              <description>C-VLAN or S-VLAN
 When this bit is set, S-VLAN type (0x88A8) is inserted or replaced in the 13th and 14th bytes of transmitted frames. When this bit is reset, C-VLAN type (0x8100) is inserted or replaced in the transmitted frames.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLP</name>
              <description>VLAN Priority Control
When this bit is set, the control Bits [17:16] are used for VLAN deletion, insertion, or replacement. When this bit is reset, the mti_vlan_ctrl_i control input is used, and Bits [17:16] are ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLC</name>
              <description>VLAN Tag Control in Transmit Frames
- 2b00: No VLAN tag deletion, insertion, or replacement
- 2b01: VLAN tag deletion The MAC removes the VLAN type (bytes 13 and 14) and VLAN tag (bytes 15 and 16) of all transmitted frames with VLAN tags.
- 2b10: VLAN tag insertion The MAC inserts VLT in bytes 15 and 16 of the frame after inserting the Type value (0x8100/0x88a8) in bytes 13 and 14.
This operation is performed on all transmitted frames, irrespective of whether they already have a VLAN tag.
- 2b11: VLAN tag replacement The MAC replaces VLT in bytes 15 and 16 of all VLAN-type transmitted frames (Bytes 13 and 14 are 0x8100/0x88a8).
Note: Changes to this field take effect only on the start of a frame.
If you write this register field when a frame is being transmitted, only the subsequent frame can use the updated value, that is, the current frame does not use the updated value.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VLT</name>
              <description>VLAN Tag for Transmit Frames
 This field contains the value of the VLAN tag to be inserted or replaced. The value must only be changed when the transmit lines are inactive or during the initialization phase.
 Bits[15:13] are the User Priority, Bit 12 is the CFI/DEI, and Bits[11:0] are the VLAN tags VID field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VLAN_HASH</name>
          <description>VLAN Hash Table Register</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>VLHT</name>
              <description>VLAN Hash Table
 This field contains the 16-bit VLAN Hash Table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTRL</name>
          <description>Timestamp Control Register</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F07FF3F</resetMask>
          <fields>
            <field>
              <name>ATSEN3</name>
              <description>Auxiliary Snapshot 3 Enable
This field controls capturing the Auxiliary Snapshot Trigger 3. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[3] input is enabled. When this bit is reset, the events on this input are ignored.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration or the selected number in the Number of IEEE 1588 Auxiliary Snapshot Inputs option is less than four.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSEN2</name>
              <description>Auxiliary Snapshot 2 Enable
This field controls capturing the Auxiliary Snapshot Trigger 2. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[2] input is enabled. When this bit is reset, the events on this input are ignored.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration or the selected number in the Number of IEEE 1588 Auxiliary Snapshot Inputs option is less than three.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSEN1</name>
              <description>Auxiliary Snapshot 1 Enable
This field controls capturing the Auxiliary Snapshot Trigger 1. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[1] input is enabled. When this bit is reset, the events on this input are ignored.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration or the selected number in the Number of IEEE 1588 Auxiliary Snapshot Inputs option is less than two.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSEN0</name>
              <description>Auxiliary Snapshot 0 Enable
This field controls capturing the Auxiliary Snapshot Trigger 0. When this bit is set, the Auxiliary snapshot of event on ptp_aux_trig_i[0] input is enabled. When this bit is reset, the events on this input are ignored.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATSFC</name>
              <description>Auxiliary Snapshot FIFO Clear
When set, it resets the pointers of the Auxiliary Snapshot FIFO. This bit is cleared when the pointers are reset and the FIFO is empty. When this bit is high, auxiliary snapshots get stored in the FIFO.
This bit is reserved when the Add IEEE 1588 Auxiliary Snapshot option is not selected during core configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSENMACADDR</name>
              <description>Enable MAC address for PTP Frame Filtering
When set, the DA MAC address (that matches any MAC Address register) is used to filter the PTP frames when PTP is directly sent over Ethernet.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SNAPTYPSEL</name>
              <description>Select PTP packets for Taking Snapshots
 These bits along with Bits 15 and 14 decide the set of PTP packet types for which snapshot needs to be taken.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSMSTRENA</name>
              <description>Enable Snapshot for Messages Relevant to Master
When set, the snapshot is taken only for the messages relevant to the master node. Otherwise, the snapshot is taken for the messages relevant to the slave node.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSEVNTENA</name>
              <description>Enable Timestamp Snapshot for Event Messages
When set, the timestamp snapshot is taken only for event messages (SYNC, Delay_Req, Pdelay_Req, or Pdelay_Resp). When reset, the snapshot is taken for all messages except Announce, Management, and Signaling.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIPV4ENA</name>
              <description>Enable Processing of PTP Frames Sent over IPv4-UDP
 When set, the MAC receiver processes the PTP packets encapsulated in UDP over IPv4 packets. When this bit is clear, the MAC ignores the PTP transported over UDP-IPv4 packets. This bit is set by default.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIPV6ENA</name>
              <description>Enable Processing of PTP Frames Sent over IPv6-UDP
When set, the MAC receiver processes PTP packets encapsulated in UDP over IPv6 packets. When this bit is clear, the MAC ignores the PTP transported over UDP-IPv6 packets.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSIPENA</name>
              <description>Enable Processing of PTP over Ethernet Frames
When set, the MAC receiver processes the PTP packets encapsulated directly in the Ethernet frames. When this bit is clear, the MAC ignores the PTP over Ethernet packets</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSVER2ENA</name>
              <description>Enable PTP packet Processing for Version 2 Format
When set, the PTP packets are processed using the 1588 version 2 format. Otherwise, the PTP packets are processed using the version 1 format.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSCTRLSSR</name>
              <description>Timestamp Digital or Binary Rollover Control
When set, the Timestamp Low register rolls over after 0x3B9A_C9FF value (that is, 1 nanosecond accuracy) and increments the timestamp (High) seconds.
 When reset, the rollover value of sub-second register is 0x7FFF_FFFF.
The sub-second increment has to be programmed correctly depending on the PTP reference clock frequency and the value of this bit.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSENALL</name>
              <description>Enable Timestamp for All Frames
When set, the timestamp snapshot is enabled for all frames received by the MAC.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSADDREG</name>
              <description>Addend Reg Update
When set, the content of the Timestamp Addend register is updated in the PTP block for fine correction. This is cleared when the update is completed.
This register bit should be zero before setting it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSTRIG</name>
              <description>Timestamp Interrupt Trigger Enable
When set, the timestamp interrupt is generated when the System Time becomes greater than the value written in the Target Time register.
This bit is reset after the generation of the Timestamp Trigger Interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSUPDT</name>
              <description>Timestamp Update
When set, the system time is updated (added or subtracted) with the value specified in Register 452 (System Time  Seconds Update Register)
and Register 453 (System Time  Nanoseconds Update Register). This bit should be read zero before updating it.
This bit is reset when the update is completed in hardware. The Timestamp Higher Word register (if enabled during core configuration) is not updated.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSINIT</name>
              <description>Timestamp Initialize
When set, the system time is initialized (overwritten) with the value specified in the Register 452 (System Time  Seconds Update Register)
and Register 453 (System Time  Nanoseconds Update Register). This bit should be read zero before updating it.
This bit is reset when the initialization is complete.
The Timestamp Higher Word register (if enabled during core configuration) can only be initialized.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSCFUPDT</name>
              <description>Timestamp Fine or Coarse Update
When set, this bit indicates that the system times update should be done using the fine update method. When reset, it indicates the system timestamp update should be done using the Coarse method.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSENA</name>
              <description>Timestamp Enable
When set, the timestamp is added for the transmit and receive frames. When disabled, timestamp is not added for the transmit and receive frames and the Timestamp Generator is also suspended.
You need to initialize the Timestamp (system time) after enabling this mode. On the receive side, the MAC processes the 1588 frames only if this bit is set.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUB_SEC_INCR</name>
          <description>Sub-Second Increment Register</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>SSINC</name>
              <description>Sub-second Increment Value
The value programmed in this field is accumulated every clock cycle (of clk_ptp_i) with the contents of the sub-second register.
For example, when PTP clock is 50 MHz (period is 20 ns), you should program 20 (0x14)
when the System Time- Nanoseconds register has an accuracy of 1 ns [Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register)].
When TSCTRLSSR is clear, the Nanoseconds register has a resolution of ~0.465ns.
In this case, you should program a value of 43 (0x2B) that is derived by 20ns/0.465.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_SEC</name>
          <description>System Time - Seconds Register</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Second
 The value in this field indicates the current value in seconds of the System Time maintained by the MAC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_NSEC</name>
          <description>System Time - Nanoseconds Register</description>
          <addressOffset>0x70c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
 The value in this field has the sub second representation of time, with an accuracy of 0.46 ns.
When Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register), each bit represents 1 ns and the maximum value is 0x3B9A_C9FF, after which it rolls-over to zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_SEC_UPD</name>
          <description>System Time - Seconds Update Register</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSS</name>
              <description>Timestamp Second
 The value in this field indicates the time in seconds to be initialized or added to the system time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYST_NSEC_UPD</name>
          <description>System Time - Nanoseconds Update Register</description>
          <addressOffset>0x714</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDSUB</name>
              <description>Add or Subtract Time
 When this bit is set, the time value is subtracted with the contents of the update register. When this bit is reset, the time value is added with the contents of the update register.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSSS</name>
              <description>Timestamp Sub Seconds
The value in this field has the sub second representation of time, with an accuracy of 0.46 ns.
When Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register), each bit represents 1 ns and the programmed value should not exceed 0x3B9A_C9FF.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_ADDEND</name>
          <description>Timestamp Addend Register</description>
          <addressOffset>0x718</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSAR</name>
              <description>Timestamp Addend Register
This field indicates the 32-bit time value to be added to the Accumulator register to achieve time synchronization.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TGTTM_SEC</name>
          <description>Target Time Seconds Register</description>
          <addressOffset>0x71c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TSTR</name>
              <description>Target Time Seconds Register
 This register stores the time in seconds.
When the timestamp value matches or exceeds both Target Timestamp registers,
then based on Bits [6:5] of Register 459 (PPS Control Register), the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TGTTM_NSEC</name>
          <description>Target Time Nanoseconds Register</description>
          <addressOffset>0x720</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRGTBUSY</name>
              <description>Target Time Register Busy
 The MAC sets this bit when the PPSCMD field (Bit [3:0]) in Register 459 (PPS Control Register) is programmed to 010 or 011.
Programming the PPSCMD field to 010 or 011, instructs the MAC to synchronize the Target Time Registers to the PTP clock domain.
The MAC clears this bit after synchronizing the Target Time Registers to the PTP clock domain
The application must not update the Target Time Registers when this bit is read as 1.
Otherwise, the synchronization of the previous programmed time gets corrupted. This bit is reserved when the Enable Flexible Pulse-Per-Second Output feature is not selected.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTSLO</name>
              <description>Target Timestamp Low Register
This register stores the time in (signed) nanoseconds.
When the value of the timestamp matches the both Target Timestamp registers,
then based on the TRGTMODSEL0 field (Bits [6:5]) in Register 459 (PPS Control Register),
the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).
This value should not exceed 0x3B9A_C9FF when Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register).
The actual start or stop time of the PPS signal output may have an error margin up to one unit of sub-second increment value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTM_H_SEC</name>
          <description>System Time - Higher Word Seconds Register</description>
          <addressOffset>0x724</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TSHWR</name>
              <description>Timestamp Higher Word Register
This field contains the most significant 16-bits of the timestamp seconds value. This register is optional and can be selected using the Enable IEEE 1588 Higher Word Register option during core configuration.
The register is directly written to initialize the value. This register is incremented when there is an overflow from the 32-bits of the System Time - Seconds register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_STATUS</name>
          <description>Timestamp Status Register</description>
          <addressOffset>0x728</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F0F03FF</resetMask>
          <fields>
            <field>
              <name>ATSNS</name>
              <description>Number of Auxiliary Timestamp Snapshots
This field indicates the number of Snapshots available in the FIFO. A value equal to the selected depth of FIFO (4, 8, or 16) indicates that the Auxiliary Snapshot FIFO is full.
These bits are cleared (to 00000) when the Auxiliary snapshot FIFO clear bit is set.
This bit is valid only if the Add IEEE 1588 Auxiliary Snapshot option is selected during core configuration.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATSSTM</name>
              <description>Auxiliary Timestamp Snapshot Trigger Missed
 This bit is set when the Auxiliary timestamp snapshot FIFO is full and external trigger was set.
This indicates that the latest snapshot is not stored in the FIFO. This bit is valid only if the Add IEEE 1588 Auxiliary Snapshot option is selected during core configuration.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATSSTN</name>
              <description>Auxiliary Timestamp Snapshot Trigger Identifier
These bits identify the Auxiliary trigger inputs for which the timestamp available in the Auxiliary Snapshot Register is applicable.
When more than one bit is set at the same time, it means that corresponding auxiliary triggers were sampled at the same clock.
These bits are applicable only if the number of Auxiliary snapshots is more than one.
One bit is assigned for each trigger as shown in the following list:
- Bit 16: Auxiliary trigger 0
- Bit 17: Auxiliary trigger 1
- Bit 18: Auxiliary trigger 2
- Bit 19: Auxiliary trigger 3
 The software can read this register to find the triggers that are set when the timestamp is taken.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR3</name>
              <description>Timestamp Target Time Error
This bit is set when the target time, being programmed in Register 496 and Register 497, is already elapsed. This bit is cleared when read by the application.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT3</name>
              <description>Timestamp Target Time Reached for Target Time PPS3
When set, this bit indicates that the value of system time is greater than or equal to the value specified in Register 496 (PPS3 Target Time High Register) and Register 497 (PPS3 Target Time Low Register).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR2</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT2</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR1</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT1</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTRGTERR</name>
              <description>No description available</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUXTSTRIG</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSTARGT</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TSSOVF</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PPS_CTRL</name>
          <description>PPS Control Register</description>
          <addressOffset>0x72c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x6767677F</resetMask>
          <fields>
            <field>
              <name>TRGTMODSEL3</name>
              <description>Target Time Register Mode for PPS3 Output
This field indicates the Target Time registers (register 496 and 497) mode for PPS3 output signal. This field is similar to the TRGTMODSEL0 field.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCMD3</name>
              <description>Flexible PPS3 Output Control
This field controls the flexible PPS3 output (ptp_pps_o[3]) signal. This field is similar to PPSCMD0[2:0] in functionality.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRGTMODSEL2</name>
              <description>Target Time Register Mode for PPS2 Output
This field indicates the Target Time registers (register 488 and 489) mode for PPS2 output signal. This field is similar to the TRGTMODSEL0 field.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCMD2</name>
              <description>Flexible PPS2 Output Control
This field controls the flexible PPS2 output (ptp_pps_o[2]) signal. This field is similar to PPSCMD0[2:0] in functionality.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRGTMODSEL1</name>
              <description>Target Time Register Mode for PPS1 Output
This field indicates the Target Time registers (register 480 and 481) mode for PPS1 output signal. This field is similar to the TRGTMODSEL0 field.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCMD1</name>
              <description>Flexible PPS1 Output Control
This field controls the flexible PPS1 output (ptp_pps_o[1]) signal. This field is similar to PPSCMD0[2:0] in functionality.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TRGTMODSEL0</name>
              <description>Target Time Register Mode for PPS0 Output
 This field indicates the Target Time registers (register 455 and 456) mode for PPS0 output signal:
- 00: Indicates that the Target Time registers are programmed only for generating the interrupt event.
- 01: Reserved
- 10: Indicates that the Target Time registers are programmed for generating the interrupt event and starting or stopping the generation of the PPS0 output signal.
- 11: Indicates that the Target Time registers are programmed only for starting or stopping the generation of the PPS0 output signal. No interrupt is asserted.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSEN0</name>
              <description>Flexible PPS Output Mode Enable
When set low, Bits [3:0] function as PPSCTRL (backward compatible). When set high, Bits[3:0] function as PPSCMD.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PPSCTRLCMD0</name>
              <description>PPSCTRL0: PPS0 Output Frequency Control
This field controls the frequency of the PPS0 output (ptp_pps_o[0]) signal.
The default value of PPSCTRL is 0000, and the PPS output is 1 pulse (of width clk_ptp_i) every second.
For other values of PPSCTRL, the PPS output becomes a generated clock of following frequencies:
- 0001: The binary rollover is 2 Hz, and the digital rollover is 1 Hz.
- 0010: The binary rollover is 4 Hz, and the digital rollover is 2 Hz.
- 0011: The binary rollover is 8 Hz, and the digital rollover is 4 Hz.
- 0100: The binary rollover is 16 Hz, and the digital rollover is 8 Hz. - ...
- 1111: The binary rollover is 32.768 KHz, and the digital rollover is 16.384 KHz.
Note: In the binary rollover mode, the PPS output (ptp_pps_o) has a duty cycle of 50 percent with these frequencies.
In the digital rollover mode, the PPS output frequency is an average number.
The actual clock is of different frequency that gets synchronized every second. For example:
- When PPSCTRL = 0001, the PPS (1 Hz) has a low period of 537 ms and a high period of 463 ms
- When PPSCTRL = 0010, the PPS (2 Hz) is a sequence of:
  - One clock of 50 percent duty cycle and 537 ms period
  - Second clock of 463 ms period (268 ms low and 195 ms high)
- When PPSCTRL = 0011, the PPS (4 Hz) is a sequence of:
  - Three clocks of 50 percent duty cycle and 268 ms period
  - Fourth clock of 195 ms period (134 ms low and 61 ms high)
PPSCMD0: Flexible PPS0 Output Control
0000: No Command
0001: START Single Pulse
This command generates single pulse rising at the start point defined in
Target Time Registers and of a duration defined
in the PPS0 Width Register.
0010: START Pulse Train
This command generates the train of pulses rising at the start point
defined in the Target Time Registers and of a duration defined in the
PPS0 Width Register and repeated at interval defined in the PPS
Interval Register. By default, the PPS pulse train is free-running unless
stopped by STOP Pulse train at time or STOP Pulse Train
immediately commands.
0011: Cancel START
This command cancels the START Single Pulse and START Pulse Train
commands if the system time has not crossed the programmed start
time.
0100: STOP Pulse train at time
This command stops the train of pulses initiated by the START Pulse
Train command (PPSCMD = 0010) after the time programmed in the
Target Time registers elapses.
0101: STOP Pulse Train immediately
This command immediately stops the train of pulses initiated by the
START Pulse Train command (PPSCMD = 0010).
0110: Cancel STOP Pulse train
This command cancels the STOP pulse train at time command if the
programmed stop time has not elapsed. The PPS pulse train becomes
free-running on the successful execution of this command.
0111-1111: Reserved
Note: These bits get cleared automatically</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUX_TS_NSEC</name>
          <description>Auxiliary Timestamp - Nanoseconds Register</description>
          <addressOffset>0x730</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUXTSLO</name>
              <description>Contains the lower 31 bits (nano-seconds field) of the auxiliary timestamp.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUX_TS_SEC</name>
          <description>Auxiliary Timestamp - Seconds Register</description>
          <addressOffset>0x734</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AUXTSHI</name>
              <description>Contains the lower 32 bits of the Seconds field of the auxiliary timestamp.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PPS0_INTERVAL</name>
          <description>PPS Interval Register</description>
          <addressOffset>0x760</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSINT</name>
              <description>PPS0 Output Signal Interval
These bits store the interval between the rising edges of PPS0 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval.
For example, if the PTP reference clock is 50 MHz (period of 20ns),
and desired interval between rising edges of PPS0 signal output is 100ns
 (that is, five units of sub-second increment value), then you should program value 4 (5  1) in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PPS0_WIDTH</name>
          <description>PPS Width Register</description>
          <addressOffset>0x764</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PPSWIDTH</name>
              <description>PPS0 Output Signal Width
These bits store the width between the rising edge and corresponding falling edge of the PPS0 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval.
For example, if PTP reference clock is 50 MHz (period of 20ns),
and desired width between the rising and corresponding falling edges of PPS0 signal output is 80ns
 (that is, four units of sub-second increment value), then you should program value 3 (4  1) in this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>1,2,3</dimIndex>
          <name>PPS[%s]</name>
          <description>no description available</description>
          <addressOffset>0x780</addressOffset>
          <register>
            <name>TGTTM_SEC</name>
            <description>PPS Target Time Seconds Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TSTRH1</name>
                <description>PPS1 Target Time Seconds Register
This register stores the time in seconds.
When the timestamp value matches or exceeds both Target Timestamp registers,
then based on Bits [14:13], TRGTMODSEL1, of Register 459 (PPS Control Register),
the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TGTTM_NSEC</name>
            <description>PPS Target Time Nanoseconds Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRGTBUSY1</name>
                <description>PPS1 Target Time Register Busy
The MAC sets this bit when the PPSCMD1 field (Bits [10:8]) in Register 459 (PPS Control Register) is programmed to 010 or 011.
Programming the PPSCMD1 field to 010 or 011 instructs the MAC to synchronize the Target Time Registers to the PTP clock domain.
The MAC clears this bit after synchronizing the Target Time Registers to the PTP clock domain
The application must not update the Targeers wht Time Registen this bit is read as 1.
Otherwise, the synchronization of the previous programmed time gets corrupted.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TTSL1</name>
                <description>Target Time Low for PPS1 Register
This register stores the time in (signed) nanoseconds.
When the value of the timestamp matches the both Target Timestamp registers,
then based on the TRGTMODSEL1 field (Bits [14:13]) in Register 459 (PPS Control Register),
 the MAC starts or stops the PPS signal output and generates an interrupt (if enabled).
 This value should not exceed 0x3B9A_C9FF when Bit 9 (TSCTRLSSR) is set in Register 448 (Timestamp Control Register).
The actual start or stop time of the PPS signal output may have an error margin up to one unit of sub-second increment value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>31</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTERVAL</name>
            <description>PPS Interval Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PPSINT</name>
                <description>PPS1 Output Signal Interval
These bits store the interval between the rising edges of PPS1 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval. For example, if the PTP reference clock is 50 MHz (period of 20ns),
 and desired interval between rising edges of PPS1 signal output is 100ns (that is, five units of sub-second increment value),
then you should program value 4 (5  1) in this register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WIDTH</name>
            <description>PPS Width Register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PPSWIDTH</name>
                <description>PPS1 Output Signal Width
These bits store the width between the rising edge and corresponding falling edge of the PPS1 signal output in terms of units of sub-second increment value.
You need to program one value less than the required interval. For example,
 if PTP reference clock is 50 MHz (period of 20ns),
and desired width between the rising and corresponding falling edges of PPS1 signal output is 80ns (that is, four units of sub-second increment value),
then you should program value 3 (4  1) in this register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DMA_BUS_MODE</name>
          <description>Bus Mode Register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xBFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RIB</name>
              <description>Rebuild INCRx Burst
When this bit is set high and the AHB master gets an EBT (Retry, Split, or Losing bus grant),
 the AHB master interface rebuilds the pending beats of any burst transfer initiated with INCRx.
The AHB master interface rebuilds the beats with a combination of specified bursts with INCRx and SINGLE.
By default, the AHB master interface rebuilds pending beats of an EBT with an unspecified (INCR) burst.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRWG</name>
              <description>Channel Priority
Weights This field sets the priority weights for Channel 0 during the round-robin arbitration between the DMA channels for the system bus.
- 00: The priority weight is 1.
- 01: The priority weight is 2.
- 10: The priority weight is 3.
- 11: The priority weight is 4. This field is present in all DWC_gmac configurations except GMAC-AXI when you select the AV feature. Otherwise, this field is reserved and read-only (RO).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXPR</name>
              <description>Transmit Priority
When set, this bit indicates that the transmit DMA has higher priority than the receive DMA during arbitration for the system-side bus. In the GMAC-AXI configuration, this bit is reserved and read-only (RO).</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MB</name>
              <description>Mixed Burst
When this bit is set high and the FB bit is low, the AHB master interface starts all bursts of length more than 16 with INCR (undefined burst),
whereas it reverts to fixed burst transfers (INCRx and SINGLE) for burst length of 16 and less.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAL</name>
              <description>Address-Aligned Beats
When this bit is set high and the FB bit is equal to 1,
the AHB or AXI interface generates all bursts aligned to the start address LS bits. If the FB bit is equal to 0,
 the first burst (accessing the start address of data buffer) is not aligned, but subsequent bursts are aligned to the address.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBLX8</name>
              <description>PBLx8 Mode
When set high, this bit multiplies the programmed PBL value (Bits [22:17] and Bits[13:8]) eight times.
Therefore, the DMA transfers the data in 8, 16, 32, 64, 128, and 256 beats depending on the PBL value.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USP</name>
              <description>Use Separate PBL
When set high, this bit configures the Rx DMA to use the value configured in Bits [22:17] as PBL.
The PBL value in Bits [13:8] is applicable only to the Tx DMA operations.
When reset to low, the PBL value in Bits [13:8] is applicable for both DMA engines.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RPBL</name>
              <description>Rx DMA PBL
This field indicates the maximum number of beats to be transferred in one Rx DMA transaction.
This is the maximum value that is used in a single block Read or Write.
The Rx DMA always attempts to burst as specified in the RPBL bit each time it starts a Burst transfer on the host bus.
 You can program RPBL with values of 1, 2, 4, 8, 16, and 32. Any other value results in undefined behavior.
This field is valid and applicable only when USP is set high.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FB</name>
              <description>Fixed Burst
 This bit controls whether the AHB or AXI master interface performs fixed burst transfers or not.
When set, the AHB interface uses only SINGLE, INCR4, INCR8, or INCR16 during start of the normal burst transfers.
When reset, the AHB or AXI interface uses SINGLE and INCR burst transfer operations.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PR</name>
              <description>Priority Ratio
 These bits control the priority ratio in the weighted round-robin arbitration between the Rx DMA and Tx DMA.
 These bits are valid only when Bit 1 (DA) is reset. The priority ratio is Rx:Tx or Tx:Rx depending on whether Bit 27 (TXPR) is reset or set.
- 00: The Priority Ratio is 1:1.
- 01: The Priority Ratio is 2:1.
- 10: The Priority Ratio is 3:1.
- 11: The Priority Ratio is 4:1.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBL</name>
              <description>Programmable Burst Length
These bits indicate the maximum number of beats to be transferred in one DMA transaction.
This is the maximum value that is used in a single block Read or Write.
The DMA always attempts to burst as specified in PBL each time it starts a Burst transfer on the host bus.
PBL can be programmed with permissible values of 1, 2, 4, 8, 16, and 32.
Any other value results in undefined behavior. When USP is set high, this PBL value is applicable only for Tx DMA transactions.
If the number of beats to be transferred is more than 32, then perform the following steps: 1. Set the PBLx8 mode. 2. Set the PBL.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATDS</name>
              <description>Alternate Descriptor Size
When set, the size of the alternate descriptor (described in Alternate or Enhanced Descriptors on page 545) increases to 32 bytes (8 DWORDS).
This is required when the Advanced Timestamp feature or the IPC Full Checksum Offload Engine (Type 2) is enabled in the receiver.
The enhanced descriptor is not required if the Advanced Timestamp and IPC Full Checksum Offload Engine (Type 2) features are not enabled.
 In such case, you can use the 16 bytes descriptor to save 4 bytes of memory.
This bit is present only when you select the Alternate Descriptor feature and any one of the following features during core configuration:
- Advanced Timestamp feature - IPC Full Checksum Offload Engine (Type 2) feature Otherwise, this bit is reserved and is read-only.
When reset, the descriptor size reverts back to 4 DWORDs (16 bytes).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSL</name>
              <description>Descriptor Skip Length
This bit specifies the number of Word, Dword, or Lword (depending on the 32-bit, 64-bit, or 128-bit bus) to skip between two unchained descriptors.
The address skipping starts from the end of current descriptor to the start of next descriptor.
When the DSL value is equal to zero, the descriptor table is taken as contiguous by the DMA in Ring mode.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DA</name>
              <description>DMA Arbitration Scheme
This bit specifies the arbitration scheme between the transmit and receive paths of Channel 0.
- 0: Weighted round-robin with Rx:Tx or Tx:Rx The priority between the paths is according to the priority specified in Bits [15:14] (PR) and priority weights specified in Bit 27 (TXPR).
- 1: Fixed priority The transmit path has priority over receive path when Bit 27 (TXPR) is set. Otherwise, receive path has priority over the transmit path.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWR</name>
              <description>Software Reset
 When this bit is set, the MAC DMA Controller resets the logic and all internal registers of the MAC.
It is cleared automatically after the reset operation is complete in all of the DWC_gmac clock domains.
Before reprogramming any register of the DWC_gmac, you should read a zero (0) value in this bit.
Note: - The Software reset function is driven only by this bit.
Bit 0 of Register 64 (Channel 1 Bus Mode Register) or Register 128 (Channel 2 Bus Mode Register) has no impact on the Software reset function.
- The reset operation is completed only when all resets in all active clock domains are de-asserted.
Therefore, it is essential that all PHY inputs clocks (applicable for the selected PHY interface) are present for the software reset completion.
The time to complete the software reset operation depends on the frequency of the slowest active clock.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_TX_POLL_DEMAND</name>
          <description>Transmit Poll Demand Register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPD</name>
              <description>Transmit Poll Demand
When these bits are written with any value,
the DMA reads the current descriptor to which the Register 18 (Current Host Transmit Descriptor Register) is pointing.
 If that descriptor is not available (owned by the Host),
the transmission returns to the Suspend state and Bit 2 (TU) of Register 5 (Status Register) is asserted.
If the descriptor is available, the transmission resumes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RX_POLL_DEMAND</name>
          <description>Receive Poll Demand Register</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RPD</name>
              <description>Receive Poll Demand
When these bits are written with any value,
the DMA reads the current descriptor to which the Register 19 (Current Host Receive Descriptor Register) is pointing.
 If that descriptor is not available (owned by the Host),
the reception returns to the Suspended state and Bit 7 (RU) of Register 5 (Status Register) is asserted.
If the descriptor is available, the Rx DMA returns to the active state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RX_DESC_LIST_ADDR</name>
          <description>Receive Descriptor List Address Register</description>
          <addressOffset>0x100c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDESLA</name>
              <description>Start of Receive List
This field contains the base address of the first descriptor in the Receive Descriptor list.
The LSB bits (1:0, 2:0, or 3:0) for 32-bit, 64-bit, or 128-bit bus width are ignored and internally taken as all-zero by the DMA. Therefore, these LSB bits are read-only (RO).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_TX_DESC_LIST_ADDR</name>
          <description>Transmit Descriptor List Address Register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDESLA</name>
              <description>Start of Transmit List
This field contains the base address of the first descriptor in the Transmit Descriptor list.
The LSB bits (1:0, 2:0, 3:0) for 32-bit, 64-bit, or 128-bit bus width are ignored and are internally taken as all-zero by the DMA. Therefore, these LSB bits are read-only (RO).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7FFFE7FF</resetMask>
          <fields>
            <field>
              <name>GLPII</name>
              <description>GLPII: GMAC LPI Interrupt (for Channel 0)
This bit indicates an interrupt event in the LPI logic of the MAC.
To reset this bit to 1'b0, the software must read the corresponding registers in the DWC_gmac to get the exact cause of the interrupt and clear its source.
Note: GLPII status is given only in Channel 0 DMA register and is applicable only when the Energy Efficient Ethernet feature is enabled. Otherwise, this bit is reserved.
When this bit is high, the interrupt signal from the MAC (sbd_intr_o) is high.
-or- GTMSI: GMAC TMS Interrupt (for Channel 1 and Channel 2) This bit indicates an interrupt event in the traffic manager and scheduler logic of DWC_gmac.
To reset this bit, the software must read the corresponding registers (Channel Status Register) to get the exact cause of the interrupt and clear its source.
Note: GTMSI status is given only in Channel 1 and Channel 2 DMA register when the AV feature is enabled and corresponding additional transmit channels are present.
Otherwise, this bit is reserved. When this bit is high, the interrupt signal from the MAC (sbd_intr_o) is high.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTI</name>
              <description>Timestamp Trigger Interrupt
This bit indicates an interrupt event in the Timestamp Generator block of the DWC_gmac.
The software must read the corresponding registers in the DWC_gmac to get the exact cause of the interrupt and clear its source to reset this bit to 1'b0.
 When this bit is high, the interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high.
This bit is applicable only when the IEEE 1588 Timestamp feature is enabled. Otherwise, this bit is reserved.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPI</name>
              <description>GMAC PMT Interrupt
This bit indicates an interrupt event in the PMT module of the DWC_gmac.
 The software must read the PMT Control and Status Register in the MAC to get the exact cause of interrupt and clear its source to reset this bit to 1b0.
The interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high when this bit is high.
This bit is applicable only when the Power Management feature is enabled.
Otherwise, this bit is reserved. Note: The GPI and pmt_intr_o interrupts are generated in different clock domains.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GMI</name>
              <description>GMAC MMC Interrupt
 This bit reflects an interrupt event in the MMC module of the DWC_gmac.
The software must read the corresponding registers in the DWC_gmac
to get the exact cause of the interrupt and clear the source of interrupt to make this bit as 1b0.
The interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high when this bit is high.
This bit is applicable only when the MAC Management Counters (MMC) are enabled. Otherwise, this bit is reserved.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GLI</name>
              <description>GMAC Line Interface Interrupt
When set, this bit reflects any of the following interrupt events in the DWC_gmac interfaces (if present and enabled in your configuration):
- PCS (TBI, RTBI, or SGMII): Link change or auto-negotiation complete event
- SMII or RGMII: Link change event - General Purpose Input Status (GPIS):
     Any LL or LH event on the gpi_i input ports To identify the exact cause of the interrupt,
    the software must first read Bit 11 and Bits[2:0] of Register 14 (Interrupt Status Register) and then to clear the source of interrupt (which also clears the GLI interrupt),
     read any of the following corresponding registers:
- PCS (TBI, RTBI, or SGMII): Register 49 (AN Status Register)
- SMII or RGMII: Register 54 (SGMII/RGMII/SMII Control and Status Register)
- General Purpose Input (GPI): Register 56 (General Purpose IO Register) The interrupt signal from the DWC_gmac subsystem (sbd_intr_o) is high when this bit is high.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EB</name>
              <description>Error Bits
This field indicates the type of error that caused a Bus Error, for example, error response on the AHB or AXI interface.
 This field is valid only when Bit 13 (FBI) is set. This field does not generate an interrupt.
- 0 0 0: Error during Rx DMA Write Data Transfer
- 0 1 1: Error during Tx DMA Read Data Transfer
- 1 0 0: Error during Rx DMA Descriptor Write Access
- 1 0 1: Error during Tx DMA Descriptor Write Access
- 1 1 0: Error during Rx DMA Descriptor Read Access
- 1 1 1: Error during Tx DMA Descriptor Read Access Note: 001 and 010 are reserved.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TS</name>
              <description>Transmit Process State
This field indicates the Transmit DMA FSM state. This field does not generate an interrupt.
- 3b000: Stopped; Reset or Stop Transmit Command issued
- 3b001: Running; Fetching Transmit Transfer Descriptor
- 3b010: Running; Waiting for status
- 3b011: Running; Reading Data from host memory buffer and queuing it to transmit buffer (Tx FIFO)
- 3b100: TIME_STAMP write state
- 3b101: Reserved for future use
- 3b110: Suspended; Transmit Descriptor Unavailable or Transmit Buffer Underflow
- 3b111: Running; Closing Transmit Descriptor</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RS</name>
              <description>Receive Process State
This field indicates the Receive DMA FSM state. This field does not generate an interrupt.
- 3b000: Stopped: Reset or Stop Receive Command issued
- 3b001: Running: Fetching Receive Transfer Descriptor
- 3b010: Reserved for future use
- 3b011: Running: Waiting for receive packet
- 3b100: Suspended: Receive Descriptor Unavailable
- 3b101: Running: Closing Receive Descriptor
- 3b110: TIME_STAMP write state
- 3b111: Running: Transferring the receive packet data from receive buffer to host memory</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NIS</name>
              <description>Normal Interrupt Summary
Normal Interrupt Summary bit value is the logical OR of the following bits when the corresponding interrupt bits are enabled in
Register 7 (Interrupt Enable Register):
- Register 5[0]: Transmit Interrupt
- Register 5[2]: Transmit Buffer Unavailable
- Register 5[6]: Receive Interrupt
- Register 5[14]: Early Receive Interrupt Only unmasked bits
 (interrupts for which interrupt enable is set in Register 7) affect the Normal Interrupt Summary bit.
 This is a sticky bit and must be cleared (by writing 1 to this bit) each time a corresponding bit, which causes NIS to be set, is cleared.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AIS</name>
              <description>Abnormal Interrupt Summary
Abnormal Interrupt Summary bit value is the logical OR of the following
when the corresponding interrupt bits are enabled in Register 7 (Interrupt Enable Register):
- Register 5[1]: Transmit Process Stopped
- Register 5[3]: Transmit Jabber Timeout
- Register 5[4]: Receive FIFO Overflow
- Register 5[5]: Transmit Underflow
- Register 5[7]: Receive Buffer Unavailable
- Register 5[8]: Receive Process Stopped
- Register 5[9]: Receive Watchdog Timeout
- Register 5[10]: Early Transmit Interrupt
- Register 5[13]: Fatal Bus Error Only unmasked bits affect the Abnormal Interrupt Summary bit.
This is a sticky bit and must be cleared (by writing 1 to this bit) each time a corresponding bit, which causes AIS to be set, is cleared.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERI</name>
              <description>Early Receive Interrupt
This bit indicates that the DMA filled the first data buffer of the packet. This bit is cleared when the software writes 1 to this bit or Bit 6 (RI) of this register is set (whichever occurs earlier).</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FBI</name>
              <description>Fatal Bus Error Interrupt
This bit indicates that a bus error occurred, as described in Bits [25:23]. When this bit is set, the corresponding DMA engine disables all of its bus accesses.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETI</name>
              <description>Early Transmit Interrupt
This bit indicates that the frame to be transmitted is fully transferred to the MTL Transmit FIFO.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWT</name>
              <description>Receive Watchdog Timeout
When set, this bit indicates that the Receive Watchdog Timer expired while receiving the current frame and the current frame is truncated after the watchdog timeout.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RPS</name>
              <description>Receive Process Stopped
This bit is asserted when the Receive Process enters the Stopped state.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RU</name>
              <description>Receive Buffer Unavailable
This bit indicates that the host owns the Next Descriptor in the Receive List and the DMA cannot acquire it.
The Receive Process is suspended. To resume processing Receive descriptors,
 the host should change the ownership of the descriptor and issue a Receive Poll Demand command.
 If no Receive Poll Demand is issued, the Receive Process resumes when the next recognized incoming frame is received.
This bit is set only when the previous Receive Descriptor is owned by the DMA.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RI</name>
              <description>Receive Interrupt
This bit indicates that the frame reception is complete.
When reception is complete, the Bit 31 of RDES1 (Disable Interrupt on Completion) is reset in the last Descriptor,
and the specific frame status information is updated in the descriptor.
The reception remains in the Running state.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNF</name>
              <description>Transmit Underflow
This bit indicates that the Transmit Buffer had an Underflow during frame transmission. Transmission is suspended and an Underflow Error TDES0[1] is set.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVF</name>
              <description>Receive Overflow
This bit indicates that the Receive Buffer had an Overflow during frame reception. If the partial frame is transferred to the application, the overflow status is set in RDES0[11].</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TJT</name>
              <description>Transmit Jabber Timeout
This bit indicates that the Transmit Jabber Timer expired, which happens when the frame size exceeds 2,048 (10,240 bytes when the Jumbo frame is enabled).
When the Jabber Timeout occurs, the transmission process is aborted and placed in the Stopped state. This causes the Transmit Jabber Timeout TDES0[14] flag to assert.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TU</name>
              <description>Transmit Buffer Unavailable
This bit indicates that the host owns the Next Descriptor in the Transmit List and the DMA cannot acquire it. Transmission is suspended. Bits[22:20] explain the Transmit Process state transitions.
To resume processing Transmit descriptors, the host should change the ownership of the descriptor by setting TDES0[31] and then issue a Transmit Poll Demand command.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPS</name>
              <description>Transmit Process Stopped
This bit is set when the transmission is stopped.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TI</name>
              <description>Transmit Interrupt
This bit indicates that the frame transmission is complete. When transmission is complete, Bit 31 (OWN) of TDES0 is reset, and the specific frame status information is updated in the descriptor.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_OP_MODE</name>
          <description>Operation Mode Register</description>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x13F1FFFE</resetMask>
          <fields>
            <field>
              <name>DT</name>
              <description>Disable Dropping of TCP/IP Checksum Error Frames
When this bit is set, the MAC does not drop the frames which only have errors detected by the Receive Checksum Offload engine.
 Such frames do not have any errors (including FCS error) in the Ethernet frame received by the MAC but have errors only in the encapsulated payload.
When this bit is reset, all error frames are dropped if the FEF bit is reset. If the IPC Full Checksum Offload Engine (Type 2) is disabled, this bit is reserved (RO with value 1'b0).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSF</name>
              <description>Receive Store and Forward
When this bit is set, the MTL reads a frame from the Rx FIFO only after the complete frame has been written to it, ignoring the RTC bits.
 When this bit is reset, the Rx FIFO operates in the cut-through mode, subject to the threshold specified by the RTC bits.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFF</name>
              <description>Disable Flushing of Received Frames
When this bit is set, the Rx DMA does not flush any frames because of the unavailability of receive descriptors or buffers as it does normally when this bit is reset. (See Receive Process Suspended on page 83.)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFA_2</name>
              <description>MSB of Threshold for Activating Flow Control
If the DWC_gmac is configured for an Rx FIFO size of 8 KB or more,
this bit (when set) provides additional threshold levels for activating the flow control in both half-duplex and full-duplex modes.
This bit (as Most Significant Bit), along with the RFA (Bits [10:9]), gives the following thresholds for activating flow control:
- 100: Full minus 5 KB, that is, FULL  5 KB
- 101: Full minus 6 KB, that is, FULL  6 KB
- 110: Full minus 7 KB, that is, FULL  7 KB
- 111: Reserved This bit is reserved (and RO) if the Rx FIFO is 4 KB or less deep.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFD_2</name>
              <description>MSB of Threshold for Deactivating Flow Control
If the DWC_gmac is configured for Rx FIFO size of 8 KB or more,
 this bit (when set) provides additional threshold levels for deactivating the flow control in both half-duplex and full-duplex modes.
 This bit (as Most Significant Bit) along with the RFD (Bits [12:11]) gives the following thresholds for deactivating flow control:
- 100: Full minus 5 KB, that is, FULL  5 KB
- 101: Full minus 6 KB, that is, FULL  6 KB
- 110: Full minus 7 KB, that is, FULL  7 KB
- 111: Reserved This bit is reserved (and RO) if the Rx FIFO is 4 KB or less deep.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSF</name>
              <description>Transmit Store and Forward
When this bit is set, transmission starts when a full frame resides in the MTL Transmit FIFO.
When this bit is set, the TTC values specified in Bits [16:14] are ignored.
This bit should be changed only when the transmission is stopped.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FTF</name>
              <description>Flush Transmit FIFO
When this bit is set, the transmit FIFO controller logic is reset to its default values and thus all data in the Tx FIFO is lost or flushed.
This bit is cleared internally when the flushing operation is complete.
The Operation Mode register should not be written to until this bit is cleared.
The data which is already accepted by the MAC transmitter is not flushed.
It is scheduled for transmission and results in underflow and runt frame transmission.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TTC</name>
              <description>Transmit Threshold Control
These bits control the threshold level of the MTL Transmit FIFO.
 Transmission starts when the frame size within the MTL Transmit FIFO is larger than the threshold.
In addition, full frames with a length less than the threshold are also transmitted.
 These bits are used only when Bit 21 (TSF) is reset.
- 000: 64
- 001: 128
- 010: 192
- 011: 256
- 100: 40
- 101: 32
- 110: 24
- 111: 16</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ST</name>
              <description>Start or Stop Transmission Command
When this bit is set, transmission is placed in the Running state, and the DMA checks the Transmit List at the current position for a frame to be transmitted.
Descriptor acquisition is attempted either from the current position in the list,
which is the Transmit List Base Address set by Register 4 (Transmit Descriptor List Address Register),
or from the position retained when transmission was stopped previously.
 If the DMA does not own the current descriptor,
transmission enters the Suspended state and Bit 2 (Transmit Buffer Unavailable) of Register 5 (Status Register) is set.
The Start Transmission command is effective only when transmission is stopped.
If the command is issued before setting Register 4 (Transmit Descriptor List Address Register),
 then the DMA behavior is unpredictable. When this bit is reset,
the transmission process is placed in the Stopped state after completing the transmission of the current frame.
The Next Descriptor position in the Transmit List is saved,
and it becomes the current position when transmission is restarted.
To change the list address, you need to program Register 4 (Transmit Descriptor List Address Register) with a new value when this bit is reset.
The new value is considered when this bit is set again.
The stop transmission command is effective only when the transmission of the current frame is complete or the transmission is in the Suspended state.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFD</name>
              <description>Threshold for Deactivating Flow Control (in half-duplex and full-duplex modes) These bits control the threshold (Fill-level of Rx FIFO) at which the flow control is de-asserted after activation.
- 00: Full minus 1 KB, that is, FULL  1 KB
- 01: Full minus 2 KB, that is, FULL  2 KB
- 10: Full minus 3 KB, that is, FULL  3 KB
- 11: Full minus 4 KB, that is, FULL  4 KB
The de-assertion is effective only after flow control is asserted.
 If the Rx FIFO is 8 KB or more, an additional Bit (RFD_2) is used for more threshold levels as described in Bit 22.
These bits are reserved and read-only when the Rx FIFO depth is less than 4 KB.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RFA</name>
              <description>Threshold for Activating Flow Control (in half-duplex and full-duplex modes)
These bits control the threshold (Fill level of Rx FIFO) at which the flow control is activated.
- 00: Full minus 1 KB, that is, FULL1KB.
- 01: Full minus 2 KB, that is, FULL2KB.
- 10: Full minus 3 KB, that is, FULL3KB.
- 11: Full minus 4 KB, that is, FULL4KB.
These values are applicable only to Rx FIFOs of 4 KB or more and when Bit 8 (EFC) is set high. If the Rx FIFO is 8 KB or more,
an additional Bit (RFA_2) is used for more threshold levels as described in Bit 23.
These bits are reserved and read-only when the depth of Rx FIFO is less than 4 KB.
Note: When FIFO size is exactly 4 KB, although the DWC_gmac allows you to program the value of these bits to 11,
the software should not program these bits to 2'b11. The value 2'b11 means flow control on FIFO empty condition</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EFC</name>
              <description>Enable HW Flow Control
When this bit is set, the flow control signal operation based on the fill-level of Rx FIFO is enabled.
When reset, the flow control operation is disabled.
 This bit is not used (reserved and always reset) when the Rx FIFO is less than 4 KB.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Forward Error Frames
When this bit is reset, the Rx FIFO drops frames with error status (CRC error, collision error, GMII_ER, giant frame, watchdog timeout, or overflow).
However, if the start byte (write) pointer of a frame is already transferred to the read controller side (in Threshold mode),
then the frame is not dropped. In the GMAC-MTL configuration in which the Frame Length FIFO is also enabled during core configuration,
the Rx FIFO drops the error frames if that frame's start byte is not transferred (output) on the ARI bus.
When the FEF bit is set, all frames except runt error frames are forwarded to the DMA.
If the Bit 25 (RSF) is set and the Rx FIFO overflows when a partial frame is written,
then the frame is dropped irrespective of the FEF bit setting.
However, if the Bit 25 (RSF) is reset and the Rx FIFO overflows when a partial frame is written, then a partial frame may be forwarded to the DMA.
Note: When FEF bit is reset, the giant frames are dropped if the giant frame status is given in Rx Status (in Table 8-6 or Table 8-23) in the following configurations:
- The IP checksum engine (Type 1) and full checksum offload engine (Type 2) are not selected.
 - The advanced timestamp feature is not selected but the extended status is selected.
The extended status is available with the following features:
- L3-L4 filter in GMAC-CORE or GMAC-MTL configurations
- Full checksum offload engine (Type 2) with enhanced descriptor format in the GMAC-DMA, GMAC-AHB, or GMAC-AXI configurations.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUF</name>
              <description>Forward Undersized Good Frames
When set, the Rx FIFO forwards Undersized frames (that is, frames with no Error and length less than 64 bytes) including pad-bytes and CRC
When reset, the Rx FIFO drops all frames of less than 64 bytes, unless a frame is already transferred because of the lower value of Receive Threshold, for example, RTC = 01.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DGF</name>
              <description>Drop Giant Frames
When set, the MAC drops the received giant frames in the Rx FIFO,
that is, frames that are larger than the computed giant frame limit.
When reset, the MAC does not drop the giant frames in the Rx FIFO.
Note: This bit is available in the following configurations in which the giant frame status is not provided in Rx status and giant frames are not dropped by default:
- Configurations in which IP Checksum Offload (Type 1) is selected in Rx
- Configurations in which the IPC Full Checksum Offload Engine (Type 2) is selected in Rx with normal descriptor format
- Configurations in which the Advanced Timestamp feature is selected In all other configurations, this bit is not used (reserved and always reset).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC</name>
              <description>Receive Threshold Control
These two bits control the threshold level of the MTL Receive FIFO.
Transfer (request) to DMA starts when the frame size within the MTL Receive FIFO is larger than the threshold.
In addition, full frames with length less than the threshold are automatically transferred.
The value of 11 is not applicable if the configured Receive FIFO size is 128 bytes.
These bits are valid only when the RSF bit is zero, and are ignored when the RSF bit is set to 1.
- 00: 64
- 01: 32
- 10: 96
- 11: 128</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSF</name>
              <description>Operate on Second Frame
When this bit is set, it instructs the DMA to process the second frame of the Transmit data even before the status for the first frame is obtained.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SR</name>
              <description>Start or Stop Receive
When this bit is set, the Receive process is placed in the Running state.
The DMA attempts to acquire the descriptor from the Receive list and processes the incoming frames.
The descriptor acquisition is attempted from the current position in the list,
which is the address set by the Register 3 (Receive Descriptor List Address Register) or the position retained when the Receive process was previously stopped.
If the DMA does not own the descriptor, reception is suspended and Bit 7 (Receive Buffer Unavailable) of Register 5 (Status Register) is set.
The Start Receive command is effective only when the reception has stopped.
 If the command is issued before setting Register 3 (Receive Descriptor List Address Register), the DMA behavior is unpredictable.
When this bit is cleared, the Rx DMA operation is stopped after the transfer of the current frame.
The next descriptor position in the Receive list is saved and becomes the current position after the Receive process is restarted.
The Stop Receive command is effective only when the Receive process is in either the Running (waiting for receive packet) or in the Suspended state.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_INTR_EN</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x101c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001E7FF</resetMask>
          <fields>
            <field>
              <name>NIE</name>
              <description>Normal Interrupt Summary Enable
When this bit is set, normal interrupt summary is enabled.
When this bit is reset, normal interrupt summary is disabled.
This bit enables the following interrupts in Register 5 (Status Register):
 - Register 5[0]: Transmit Interrupt
- Register 5[2]: Transmit Buffer Unavailable
- Register 5[6]: Receive Interrupt
 - Register 5[14]: Early Receive Interrupt</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AIE</name>
              <description>Abnormal Interrupt Summary Enable
When this bit is set, abnormal interrupt summary is enabled.
When this bit is reset, the abnormal interrupt summary is disabled.
This bit enables the following interrupts in Register 5 (Status Register):
- Register 5[1]: Transmit Process Stopped
- Register 5[3]: Transmit Jabber Timeout
- Register 5[4]: Receive Overflow
- Register 5[5]: Transmit Underflow
- Register 5[7]: Receive Buffer Unavailable
- Register 5[8]: Receive Process Stopped
- Register 5[9]: Receive Watchdog Timeout
- Register 5[10]: Early Transmit Interrupt
 - Register 5[13]: Fatal Bus Error</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERE</name>
              <description>Early Receive Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Early Receive Interrupt is enabled. When this bit is reset, the Early Receive Interrupt is disabled.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FBE</name>
              <description>Fatal Bus Error Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Fatal Bus Error Interrupt is enabled. When this bit is reset, the Fatal Bus Error Enable Interrupt is disabled.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ETE</name>
              <description>Early Transmit Interrupt Enable
When this bit is set with an Abnormal Interrupt Summary Enable (Bit 15), the Early Transmit Interrupt is enabled. When this bit is reset, the Early Transmit Interrupt is disabled.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RWE</name>
              <description>Receive Watchdog Timeout Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Watchdog Timeout Interrupt is enabled. When this bit is reset, the Receive Watchdog Timeout Interrupt is disabled.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSE</name>
              <description>Receive Stopped Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Stopped Interrupt is enabled. When this bit is reset, the Receive Stopped Interrupt is disabled.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RUE</name>
              <description>Receive Buffer Unavailable Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Buffer Unavailable Interrupt is enabled. When this bit is reset, the Receive Buffer Unavailable Interrupt is disabled.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RIE</name>
              <description>Receive Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Receive Interrupt is enabled. When this bit is reset, the Receive Interrupt is disabled.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNE</name>
              <description>Underflow Interrupt Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Transmit Underflow Interrupt is enabled. When this bit is reset, the Underflow Interrupt is disabled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVE</name>
              <description>Overflow Interrupt Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Receive Overflow Interrupt is enabled. When this bit is reset, the Overflow Interrupt is disabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TJE</name>
              <description>Transmit Jabber Timeout Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Transmit Jabber Timeout Interrupt is enabled. When this bit is reset, the Transmit Jabber Timeout Interrupt is disabled.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TUE</name>
              <description>Transmit Buffer Unavailable Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Transmit Buffer Unavailable Interrupt is enabled. When this bit is reset, the Transmit Buffer Unavailable Interrupt is disabled.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSE</name>
              <description>Transmit Stopped Enable
When this bit is set with Abnormal Interrupt Summary Enable (Bit 15), the Transmission Stopped Interrupt is enabled. When this bit is reset, the Transmission Stopped Interrupt is disabled.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIE</name>
              <description>Transmit Interrupt Enable
When this bit is set with Normal Interrupt Summary Enable (Bit 16), the Transmit Interrupt is enabled. When this bit is reset, the Transmit Interrupt is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_MISS_OVF_CNT</name>
          <description>Missed Frame And Buffer Overflow Counter Register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFFFFF</resetMask>
          <fields>
            <field>
              <name>ONFCNTOVF</name>
              <description>Overflow Bit for FIFO Overflow Counter
This bit is set every time the Overflow Frame Counter (Bits[27:17]) overflows,
that is, the Rx FIFO overflows with the overflow frame counter at maximum value.
In such a scenario, the overflow frame counter is reset to all-zeros and this bit indicates that the rollover happened.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVFFRMCNT</name>
              <description>Overflow Frame Counter
This field indicates the number of frames missed by the application. This counter is incremented each time the MTL FIFO overflows. The counter is cleared when this register is read with mci_be_i[2] at 1b1.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISCNTOVF</name>
              <description>Overflow Bit for Missed Frame Counter
This bit is set every time Missed Frame Counter (Bits[15:0]) overflows,
that is, the DMA discards an incoming frame because of the Host Receive Buffer being unavailable with the missed frame counter at maximum value. In such a scenario,
 the Missed frame counter is reset to all-zeros and this bit indicates that the rollover happened.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MISFRMCNT</name>
              <description>Missed Frame Counter
This field indicates the number of frames missed by the controller because of the Host Receive Buffer being unavailable.
This counter is incremented each time the DMA discards an incoming frame. The counter is cleared when this register is read with mci_be_i[0] at 1b1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_RX_INTR_WDOG</name>
          <description>Receive Interrupt Watchdog Timer Register</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>RIWT</name>
              <description>RI Watchdog Timer Count
This bit indicates the number of system clock cycles multiplied by 256 for which the watchdog timer is set.
The watchdog timer gets triggered with the programmed value after the Rx DMA completes the transfer
of a frame for which the RI status bit is not set because of the setting in the corresponding descriptor RDES1[31].
When the watchdog timer runs out, the RI bit is set and the timer is stopped.
The watchdog timer is reset when the RI bit is set high because of automatic setting of RI as per RDES1[31] of any received frame.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_AXI_MODE</name>
          <description>AXI Bus Mode Register</description>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0FF30FF</resetMask>
          <fields>
            <field>
              <name>EN_LPI</name>
              <description>Enable Low Power Interface (LPI)
When set to 1, this bit enables the LPI mode supported by the GMAC-AXI configuration and accepts the LPI request from the AXI System Clock controller.
When set to 0, this bit disables the LPI mode and always denies the LPI request from the AXI System Clock controller.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPI_XIT_FRM</name>
              <description>Unlock on Magic Packet or Remote Wake-Up Frame
When set to 1, this bit enables the GMAC-AXI to come out of the LPI mode only when the magic packet or remote wake-up frame is received.
When set to 0, this bit enables the GMAC-AXI to come out of LPI mode when any frame is received.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_OSR_LMT</name>
              <description>AXI Maximum Write Outstanding Request Limit
This value limits the maximum outstanding request on the AXI write interface.
Maximum outstanding requests = WR_OSR_LMT+1 Note: - Bit 22 is reserved if AXI_GM_MAX_WR_REQUESTS = 4. - Bit 23 bit is reserved if AXI_GM_MAX_WR_REQUESTS != 16.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_OSR_LMT</name>
              <description>AXI Maximum Read Outstanding Request Limit
This value limits the maximum outstanding request on the AXI read interface.
Maximum outstanding requests = RD_OSR_LMT+1 Note: - Bit 18 is reserved if AXI_GM_MAX_RD_REQUESTS = 4. - Bit 19 is reserved if AXI_GM_MAX_RD_REQUESTS != 16.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ONEKBBE</name>
              <description>1 KB Boundary Crossing Enable for the GMAC-AXI Master
When set, the GMAC-AXI master performs burst transfers that do not cross 1 KB boundary.
When reset, the GMAC-AXI master performs burst transfers that do not cross 4 KB boundary.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXI_AAL</name>
              <description>Address-Aligned Beats
This bit is read-only bit and reflects the Bit 25 (AAL) of Register 0 (Bus Mode Register).
When this bit is set to 1, the GMAC-AXI performs address-aligned burst transfers on both read and write channels.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN256</name>
              <description>AXI Burst Length 256
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 256 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 256. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN128</name>
              <description>AXI Burst Length 128
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 128 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 128 or more. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN64</name>
              <description>AXI Burst Length 64
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 64 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 64 or more. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN32</name>
              <description>AXI Burst Length 32
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 32 on the AXI master interface.
This bit is present only when the configuration parameter AXI_BL is set to 32 or more. Otherwise, this bit is reserved and is read-only (RO).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN16</name>
              <description>AXI Burst Length 16
When this bit is set to 1 or UNDEF is set to 1, the GMAC-AXI is allowed to select a burst length of 16 on the AXI master interface.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN8</name>
              <description>AXI Burst Length 8
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 8 on the AXI master interface.
Setting this bit has no effect when UNDEF is set to 1.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLEN4</name>
              <description>AXI Burst Length 4
When this bit is set to 1, the GMAC-AXI is allowed to select a burst length of 4 on the AXI master interface.
Setting this bit has no effect when UNDEF is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDEF</name>
              <description>AXI Undefined Burst Length
This bit is read-only bit and indicates the complement (invert) value of Bit 16 (FB) in Register 0 (Bus Mode Register).
- When this bit is set to 1, the GMAC-AXI is allowed to perform any burst length equal to or below the maximum allowed burst length programmed in Bits[7:3].
- When this bit is set to 0, the GMAC-AXI is allowed to perform only fixed burst lengths as indicated by BLEN256, BLEN128, BLEN64, BLEN32, BLEN16, BLEN8, or BLEN4, or a burst length of 1.
If UNDEF is set and none of the BLEN bits is set, then GMAC-AXI is allowed to perform a burst length of 16.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_BUS_STATUS</name>
          <description>AHB or AXI Status Register</description>
          <addressOffset>0x102c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>AXIRDSTS</name>
              <description>AXI Master Read Channel Status
When high, it indicates that AXI master's read channel is active and transferring data.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AXWHSTS</name>
              <description>AXI Master Write Channel or AHB Master Status
When high, it indicates that AXI master's write channel is active and transferring data in the GMAC-AXI configuration. In the GMAC-AHB configuration,
 it indicates that the AHB master interface FSMs are in the non-idle state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_TX_DESC</name>
          <description>Current Host Transmit Descriptor Register</description>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTDESAPTR</name>
              <description>Host Transmit Descriptor Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_RX_DESC</name>
          <description>Current Host Receive Descriptor Register</description>
          <addressOffset>0x104c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRDESAPTR</name>
              <description>Host Receive Descriptor Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_TX_BUF</name>
          <description>Current Host Transmit Buffer Address Register</description>
          <addressOffset>0x1050</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURTBUFAPTR</name>
              <description>Host Transmit Buffer Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CURR_HOST_RX_BUF</name>
          <description>Current Host Receive Buffer Address Register</description>
          <addressOffset>0x1054</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CURRBUFAPTR</name>
              <description>Host Receive Buffer Address Pointer
Cleared on Reset. Pointer updated by the DMA during operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL0</name>
          <description>Control Register 0</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003F3F</resetMask>
          <fields>
            <field>
              <name>ENET0_RXCLK_DLY_SEL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_TXCLK_DLY_SEL</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL2</name>
          <description>Control  Register 1</description>
          <addressOffset>0x3008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x2008F400</resetMask>
          <fields>
            <field>
              <name>ENET0_LPI_IRQ_EN</name>
              <description>lowpower interrupt enable, for internal use only, user should use core registers for enable/disable interrupt</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_REFCLK_OE</name>
              <description>set to enable output 50MHz clock to rmii phy.
User should set it if use soc internal clock as refclk</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_PHY_INF_SEL</name>
              <description>PHY mode select
001RGMII; 100RMII;
should be set before config IOMUX, otherwise may cause glitch for RGMII</description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_FLOWCTRL</name>
              <description>flow control request</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENET0_RMII_TXCLK_SEL</name>
              <description>RMII mode output clock pad select
set to use txck as RMII refclk;
clr to use rxck as RMII refclk;  default 0(rxck)
refclk is always from pad, can use external clock from pad, or use internal clock output to pad then loopback.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USB0</name>
      <description>USB0</description>
      <groupName>USB</groupName>
      <baseAddress>0xf1120000</baseAddress>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x1a8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPTIMER0LD</name>
          <description>General Purpose Timer #0 Load Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTLD</name>
              <description>GPTLD
General Purpose Timer Load Value
These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'.
This value represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER0CTRL</name>
          <description>General Purpose Timer #0 Controller Register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC1FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTRUN</name>
              <description>GPTRUN
General Purpose Timer Run
GPTCNT bits are not effected when setting or clearing this bit.
0 - Stop counting
1 - Run</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTRST</name>
              <description>GPTRST
General Purpose Timer Reset
0 - No action
1 - Load counter value from GPTLD bits in n_GPTIMER0LD</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPTMODE</name>
              <description>GPTMODE
General Purpose Timer Mode
In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is
reset by software;
In repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the
counter value from GPTLD bits to start again.
0 - One Shot Mode
1 - Repeat Mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTCNT</name>
              <description>GPTCNT
General Purpose Timer Counter.
This field is the count value of the countdown timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER1LD</name>
          <description>General Purpose Timer #1 Load Register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTLD</name>
              <description>GPTLD
General Purpose Timer Load Value
These bit fields are loaded to GPTCNT bits when GPTRST bit is set '1b'.
This value represents the time in microseconds minus 1 for the timer duration.
Example: for a one millisecond timer, load 1000-1=999 or 0x0003E7.
NOTE: Max value is 0xFFFFFF or 16.777215 seconds.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIMER1CTRL</name>
          <description>General Purpose Timer #1 Controller Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC1FFFFFF</resetMask>
          <fields>
            <field>
              <name>GPTRUN</name>
              <description>GPTRUN
General Purpose Timer Run
GPTCNT bits are not effected when setting or clearing this bit.
0 - Stop counting
1 - Run</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTRST</name>
              <description>GPTRST
General Purpose Timer Reset
0 - No action
1 - Load counter value from GPTLD bits in USB_n_GPTIMER1LD</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPTMODE</name>
              <description>GPTMODE
General Purpose Timer Mode
In one shot mode, the timer will count down to zero, generate an interrupt, and stop until the counter is
reset by software. In repeat mode, the timer will count down to zero, generate an interrupt and
automatically reload the counter value from GPTLD bits to start again.
0 - One Shot Mode
1 - Repeat Mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPTCNT</name>
              <description>GPTCNT
General Purpose Timer Counter.
This field is the count value of the countdown timer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SBUSCFG</name>
          <description>System Bus Config Register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>AHBBRST</name>
              <description>AHBBRST
AHB master interface Burst configuration
These bits control AHB master transfer type sequence (or priority).
NOTE: This register overrides n_BURSTSIZE register when its value is not zero.
000 - Incremental burst of unspecified length only
001 - INCR4 burst, then single transfer
010 - INCR8 burst, INCR4 burst, then single transfer
011 - INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
100 - Reserved, don't use
101 - INCR4 burst, then incremental burst of unspecified length
110 - INCR8 burst, INCR4 burst, then incremental burst of unspecified length
111 - INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCMD</name>
          <description>USB Command Register</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00080000</resetValue>
          <resetMask>0x00FFFB7F</resetMask>
          <fields>
            <field>
              <name>ITC</name>
              <description>ITC
Interrupt Threshold Control -Read/Write.
The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts.
ITC contains the maximum interrupt interval measured in micro-frames. Valid values are
shown below.
Value Maximum Interrupt Interval
00000000 - Immediate (no threshold)
00000001 - 1 micro-frame
00000010 - 2 micro-frames
00000100 - 4 micro-frames
00001000 - 8 micro-frames
00010000 - 16 micro-frames
00100000 - 32 micro-frames
01000000 - 64 micro-frames</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_2</name>
              <description>FS_2
Frame List Size - (Read/Write or Read Only). [host mode only]
This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.
This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.
NOTE: This field is made up from USBCMD bits 15, 3 and 2.
Value Meaning
0b000 - 1024 elements (4096 bytes) Default value
0b001 - 512 elements (2048 bytes)
0b010 - 256 elements (1024 bytes)
0b011 - 128 elements (512 bytes)
0b100 - 64 elements (256 bytes)
0b101 - 32 elements (128 bytes)
0b110 - 16 elements (64 bytes)
0b111 - 8 elements (32 bytes)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATDTW</name>
              <description>ATDTW
Add dTD TripWire - Read/Write. [device mode only]
This bit is used as a semaphore to ensure proper addition of a new dTD to an active (primed) endpoint's
linked list. This bit is set and cleared by software.
This bit would also be cleared by hardware when state machine is hazard region for which adding a dTD
to a primed endpoint may go unrecognized.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUTW</name>
              <description>SUTW
Setup TripWire - Read/Write. [device mode only]
This bit is used as a semaphore to ensure that the setup data payload of 8 bytes is extracted from a QH by the DCD without being corrupted.
If the setup lockout mode is off (SLOM bit in USB core register n_USBMODE, see USBMODE ) then
there is a hazard when new setup data arrives while the DCD is copying the setup data payload
from the QH for a previous setup packet. This bit is set and cleared by software.
This bit would also be cleared by hardware when a hazard detected.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRM</name>
              <description>Asynchronous Schedule start- Write only host mode only
this bit is used to notify hostcontroller to start async schedule immediately.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ASPE</name>
              <description>ASPE
Asynchronous Schedule Park Mode Enable - Read/Write.
If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this bit defaults to a 1h and is R/W.
Otherwise the bit must be a zero and is RO. Software uses this bit to enable or disable Park mode.
When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.
NOTE: ASPE bit reset value: '0b' for OTG controller .</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASP</name>
              <description>ASP
Asynchronous Schedule Park Mode Count - Read/Write.
If the Asynchronous Park Capability bit in the HCCPARAMS register is a one, then this field defaults to 3h and is R/W. Otherwise it defaults to zero and is Read-Only.
It contains a count of the number of successive transactions the host controller is allowed to
execute from a high-speed queue head on the Asynchronous schedule before continuing traversal of the Asynchronous schedule.
Valid values are 1h to 3h. Software must not write a zero to this bit when Park Mode Enable is a one as this will result in undefined behavior.
This field is set to 3h in all controller core.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IAA</name>
              <description>IAA
Interrupt on Async Advance Doorbell - Read/Write.
This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. Software must write a 1 to this bit to ring the doorbell.
When the host controller has evicted all appropriate cached schedule states,
it sets the Interrupt on Async Advance status bit in the USBSTS register.
If the Interrupt on Sync Advance Enable bit in the USBINTR register is one, then the host controller will assert an interrupt at the next interrupt threshold.
The host controller sets this bit to zero after it has set the Interrupt on Sync Advance status bit in the USBSTS register to one.
Software should not write a one to this bit when the asynchronous  schedule is inactive. Doing so will yield undefined results.
This bit is only used in host mode. Writing a one to this bit when device mode is selected will have undefined results.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASE</name>
              <description>ASE
Asynchronous Schedule Enable - Read/Write. Default 0b.
This bit controls whether the host controller skips processing the Asynchronous Schedule.
Only the host controller uses this bit.
Values Meaning
0 - Do not process the Asynchronous Schedule.
1 - Use the ASYNCLISTADDR register to access the Asynchronous Schedule.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSE</name>
              <description>PSE
Periodic Schedule Enable- Read/Write. Default 0b.
This bit controls whether the host controller skips processing the Periodic Schedule.
Only the host controller uses this bit.
Values Meaning
0 - Do not process the Periodic Schedule
1 - Use the PERIODICLISTBASE register to access the Periodic Schedule.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FS_1</name>
              <description>FS_1
See description at bit 15</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST</name>
              <description>RST
Controller Reset (RESET) - Read/Write. Software uses this bit to reset the controller.
This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.
Host operation mode:
When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.
Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports.
Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.
Attempting to reset an actively running host controller will result in undefined behavior.
Device operation mode:
When software writes a one to this bit, the Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value.
Writing a one to this bit when the device is in the attached state is not recommended, because the effect on an attached host is undefined.
In order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the USBCMD Run/Stop bit should be set to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RS</name>
              <description>RS
Run/Stop (RS) - Read/Write. Default 0b. 1=Run. 0=Stop.
Host operation mode:
When set to '1b', the Controller proceeds with the execution of the schedule. The Controller continues execution as long as this bit is set to a one.
When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.
The HC Halted bit in the status register indicates when the Controller has finished the transaction and has entered the stopped state.
Software should not write a one to this field unless the controller is in the Halted state (that is, HCHalted in the USBSTS register is a one).
Device operation mode:
Writing a one to this bit will cause the controller to enable a pull-up on D+ and initiate an attach event.
This control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode.
Software should use this bit to prevent an attach event before the controller has been properly initialized. Writing a 0 to this will cause a detach event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBSTS</name>
          <description>USB Status Register</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030DF1FF</resetMask>
          <fields>
            <field>
              <name>TI1</name>
              <description>TI1
General Purpose Timer Interrupt 1(GPTINT1)--R/WC.
This bit is set when the counter in the GPTIMER1CTRL register transitions to zero, writing a one to this
bit will clear it.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TI0</name>
              <description>TI0
General Purpose Timer Interrupt 0(GPTINT0)--R/WC.
This bit is set when the counter in the GPTIMER0CTRL register transitions to zero, writing a one to this
bit clears it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPI</name>
              <description>USB Host Periodic Interrupt  RWC. Default = 0b.
This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction
where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule.
This bit is also set by the Host Controller when a short packet is detected and the packet is on the periodic schedule.
A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UAI</name>
              <description>USB Host Asynchronous Interrupt  RWC. Default = 0b.
This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction
where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule.
This bit is also set by the Host when a short packet is detected and the packet is on the asynchronous schedule.
A short packet is when the actual number of bytes received was less than expected.
This bit is not used by the device controller and will always be zero</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKI</name>
              <description>NAKI
NAK Interrupt Bit--RO.
This bit is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and
corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware
when all Enabled TX/RX Endpoint NAK bits are cleared.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AS</name>
              <description>AS
Asynchronous Schedule Status - Read Only.
This bit reports the current real status of the Asynchronous Schedule. When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.
The Host Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.
When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).
Only used in the host operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PS</name>
              <description>PS
Periodic Schedule Status - Read Only.
This bit reports the current real status of the Periodic Schedule. When set to zero the periodic schedule is disabled, and if set to one the status is enabled.
The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.
When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).
Only used in the host operation mode.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCL</name>
              <description>RCL
Reclamation - Read Only.
This is a read-only status bit used to detect an empty asynchronous schedule.
Only used in the host operation mode.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HCH</name>
              <description>HCH
HCHaIted - Read Only.
This bit is a zero whenever the Run/Stop bit is a one.
 The Controller sets this bit to one after it has stopped executing because of the Run/Stop bit being set to 0,
 either by software or by the Controller hardware (for example, an internal error).
Only used in the host operation mode.
Default value is '0b' for OTG core .
This is because OTG core is not operating as host in default. Please see CM bit in USB_n_USBMODE
register.
NOTE: HCH bit reset value: '0b' for OTG controller core .</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLI</name>
              <description>SLI
DCSuspend - R/WC.
When a controller enters a suspend state from an active state, this bit will be set to a one. The device controller clears the bit upon exiting from a suspend state.
Only used in device operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRI</name>
              <description>SRI
SOF Received - R/WC.
When the device controller detects a Start Of (micro) Frame, this bit will be set to a one.
When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected.
Therefore, this bit will be set roughly every 1ms in device FS mode and every 125ms in HS mode and will be synchronized to the actual SOF that is received.
Because the device controller is initialized to FS before connect, this bit will be set at an interval of 1ms during the prelude to connect and chirp.
In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.
Software writes a 1 to this bit to clear it.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URI</name>
              <description>URI
USB Reset Received - R/WC.
When the device controller detects a USB Reset and enters the default state, this bit will be set to a one.
Software can write a 1 to this bit to clear the USB Reset Received status bit.
Only used in device operation mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAI</name>
              <description>AAI
Interrupt on Async Advance - R/WC.
System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule
by writing a one to the Interrupt on Async Advance Doorbell bit in the n_USBCMD register. This status bit indicates the assertion of that interrupt source.
Only used in host operation mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEI</name>
              <description>System Error  RWC. Default = 0b.
In the BVCI implementation of the USBHS core, this bit is not used, and will always be cleared to '0b'.
In the AMBA implementation, this bit will be set to '1b' when an Error response is seen by the master interface (HRESP[1:0]=ERROR)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRI</name>
              <description>FRI
Frame List Rollover - R/WC.
The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to
zero. The exact value at which the rollover occurs depends on the frame list size. For example. If the
frame list size (as programmed in the Frame List Size field of the USB_n_USBCMD register) is 1024, the
Frame Index Register rolls over every time FRINDEX [13] toggles. Similarly, if the size is 512, the Host
Controller sets this bit to a one every time FHINDEX [12] toggles.
Only used in host operation mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCI</name>
              <description>PCI
Port Change Detect - R/WC.
The Host Controller sets this bit to a one when on any port a Connect Status occurs, a Port Enable/Disable Change occurs,
or the Force Port Resume bit is set as the result of a J-K transition on the suspended port.
The Device Controller sets this bit to a one when the port controller enters the full or high-speed operational state.
When the port controller exits the full or high-speed operation states due to Reset or Suspend events,
the notification mechanisms are the USB Reset Received bit and the DCSuspend bits Respectively.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UEI</name>
              <description>UEI
USB Error Interrupt (USBERRINT) - R/WC.
When completion of a USB transaction results in an error condition, this bit is set by the Host/Device Controller.
This bit is set along with the USBINT bit, if the TD on which the error interrupt occurred also had its interrupt on complete (IOC) bit set.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UI</name>
              <description>UI
USB Interrupt (USBINT) - R/WC.
This bit is set by the Host/Device Controller when the cause of an interrupt is a completion of a USB
transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set.
This bit is also set by the Host/Device Controller when a short packet is detected. A short packet is when
the actual number of bytes received was less than the expected number of bytes.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBINTR</name>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x030D01FF</resetMask>
          <fields>
            <field>
              <name>TIE1</name>
              <description>TIE1
General Purpose Timer #1 Interrupt Enable
When this bit is one and the TI1 bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIE0</name>
              <description>TIE0
General Purpose Timer #0 Interrupt Enable
When this bit is one and the TI0 bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPIE</name>
              <description>UPIE
USB Host Periodic Interrupt Enable
When this bit is one, and the UPI bit in the n_USBSTS register is one, host controller will issue an
interrupt at the next interrupt threshold.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UAIE</name>
              <description>UAIE
USB Host Asynchronous Interrupt Enable
When this bit is one, and the UAI bit in the n_USBSTS register is one, host controller will issue an
interrupt at the next interrupt threshold.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NAKE</name>
              <description>NAKE
NAK Interrupt Enable
When this bit is one and the NAKI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SLE</name>
              <description>SLE
Sleep Interrupt Enable
When this bit is one and the SLI bit in n_n_USBSTS register is a one the controller will issue an interrupt.
Only used in device operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRE</name>
              <description>SRE
SOF Received Interrupt Enable
When this bit is one and the SRI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>URE</name>
              <description>URE
USB Reset Interrupt Enable
When this bit is one and the URI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in device operation mode.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAE</name>
              <description>AAE
Async Advance Interrupt Enable
When this bit is one and the AAI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEE</name>
              <description>SEE
System Error Interrupt Enable
When this bit is one and the SEI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRE</name>
              <description>FRE
Frame List Rollover Interrupt Enable
When this bit is one and the FRI bit in n_USBSTS register is a one the controller will issue an interrupt.
Only used in host operation mode.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCE</name>
              <description>PCE
Port Change Detect Interrupt Enable
When this bit is one and the PCI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UEE</name>
              <description>UEE
USB Error Interrupt Enable
When this bit is one and the UEI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UE</name>
              <description>UE
USB Interrupt Enable
When this bit is one and the UI bit in n_USBSTS register is a one the controller will issue an interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRINDEX</name>
          <description>USB Frame Index Register</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>FRINDEX</name>
              <description>FRINDEX
Frame Index.
The value, in this register, increments at the end of each time frame (micro-frame). Bits [N: 3] are used for the Frame List current index.
This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.
The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.
USBCMD [Frame List Size] Number Elements N
In device mode the value is the current frame number of the last frame transmitted. It is not used as an index.
In either mode bits 2:0 indicate the current microframe.
The bit field values description below is represented as (Frame List Size) Number Elements N.
00000000000000 - (1024) 12
00000000000001 - (512) 11
00000000000010 - (256) 10
00000000000011 - (128) 9
00000000000100 - (64) 8
00000000000101 - (32) 7
00000000000110 - (16) 6
00000000000111 - (8) 5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEVICEADDR</name>
          <description>Device Address Register</description>
          <alternateGroup>UNION_154</alternateGroup>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF000000</resetMask>
          <fields>
            <field>
              <name>USBADR</name>
              <description>USBADR
Device Address.
These bits correspond to the USB device address</description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USBADRA</name>
              <description>USBADRA
Device Address Advance. Default=0.
When this bit is '0', any writes to USBADR are instantaneous.
 When this bit is written to a '1' at the same time or before USBADR is written, the write to the USBADR field is staged and held in a hidden register.
After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the holding register.
Hardware will automatically clear this bit on the following conditions:
1) IN is ACKed to endpoint 0. (USBADR is updated from staging register).
2) OUT/SETUP occur to endpoint 0. (USBADR is not updated).
3) Device Reset occurs (USBADR is reset to 0).
NOTE: After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field.
This mechanism will ensure this specification is met when the DCD can not write of the device address within 2ms from the SET_ADDRESS status phase.
If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase (before the prime of the status phase),
the USBADR will be programmed instantly at the correct time and meet the 2ms USB requirement.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERIODICLISTBASE</name>
          <description>Frame List Base Address Register</description>
          <alternateGroup>UNION_154</alternateGroup>
          <addressOffset>0x154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>BASEADR</name>
              <description>BASEADR
Base Address (Low).
These bits correspond to memory address signals [31:12], respectively.
Only used by the host controller.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNCLISTADDR</name>
          <description>Next Asynch. Address Register</description>
          <alternateGroup>UNION_158</alternateGroup>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFE0</resetMask>
          <fields>
            <field>
              <name>ASYBASE</name>
              <description>ASYBASE
Link Pointer Low (LPL).
These bits correspond to memory address signals [31:5], respectively. This field may only reference a
Queue Head (QH).
Only used by the host controller.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTLISTADDR</name>
          <description>Endpoint List Address Register</description>
          <alternateGroup>UNION_158</alternateGroup>
          <addressOffset>0x158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF800</resetMask>
          <fields>
            <field>
              <name>EPBASE</name>
              <description>EPBASE
Endpoint List Pointer(Low). These bits correspond to memory address signals [31:11], respectively.
This field will reference a list of up to 32 Queue Head (QH) (that is, one queue head per endpoint &amp; direction).</description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BURSTSIZE</name>
          <description>Programmable Burst Size Register</description>
          <addressOffset>0x160</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TXPBURST</name>
              <description>TXPBURST
Programmable TX Burst Size.
Default value is determined by TXBURST bits in n_HWTXBUF.
This register represents the maximum length of a the burst in 32-bit words while moving data from system
memory to the USB bus.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXPBURST</name>
              <description>RXPBURST
Programmable RX Burst Size.
Default value is determined by TXBURST bits in n_HWRXBUF.
This register represents the maximum length of a the burst in 32-bit words while moving data from the
USB bus to system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TXFILLTUNING</name>
          <description>TX FIFO Fill Tuning Register</description>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F1F7F</resetMask>
          <fields>
            <field>
              <name>TXFIFOTHRES</name>
              <description>TXFIFOTHRES
FIFO Burst Threshold. (Read/Write)
This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.
The minimum value is 2 and this value should be a low as possible to maximize USB performance.
A higher value can be used in systems with unpredictable latency and/or insufficient bandwidth
where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.
This value is ignored if the Stream Disable bit in USB_n_USBMODE register is set.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCHHEALTH</name>
              <description>TXSCHHEALTH
Scheduler Health Counter. (Read/Write To Clear)
Table continues on the next page
This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES
before running out of time to send the packet before the next Start-Of-Frame.
This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.
Writing to this register will clear the counter and this counter will max. at 31.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXSCHOH</name>
              <description>TXSCHOH
Scheduler Overhead. (Read/Write) [Default = 0]
This register adds an additional fixed offset to the schedule time estimator described above as Tff.
As an approximation, the value chosen for this register should limit the number of back-off events captured
in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.
Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization.
The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode.
The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode.
Default value is '08h' for OTG controller core .</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTNAK</name>
          <description>Endpoint NAK Register</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPTN</name>
              <description>EPTN
TX Endpoint NAK - R/WC.
Each TX endpoint has 1 bit in this field. The bit is set when the
device sends a NAK handshake on a received IN token for the corresponding endpoint.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPRN</name>
              <description>EPRN
RX Endpoint NAK - R/WC.
Each RX endpoint has 1 bit in this field. The bit is set when the
device sends a NAK handshake on a received OUT or PING token for the corresponding endpoint.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTNAKEN</name>
          <description>Endpoint NAK Enable Register</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPTNE</name>
              <description>EPTNE
TX Endpoint NAK Enable - R/W.
Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the
corresponding TX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EPRNE</name>
              <description>EPRNE
RX Endpoint NAK Enable - R/W.
Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the
corresponding RX Endpoint NAK bit is set, the NAK Interrupt bit is set.
Bit [N] - Endpoint #[N], N is 0-7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PORTSC1</name>
          <description>Port Status &amp; Control</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3DFF1FFF</resetMask>
          <fields>
            <field>
              <name>STS</name>
              <description>STS
Serial Transceiver Select
1 Serial Interface Engine is selected
0 Parallel Interface signals is selected
Serial Interface Engine can be used in combination with UTMI+/ULPI physical interface to provide FS/LS signaling instead of the parallel interface signals.
When this bit is set '1b', serial interface engine will be used instead of parallel interface signals.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTW</name>
              <description>PTW
Parallel Transceiver Width
This bit has no effect if serial interface engine is used.
0 - Select the 8-bit UTMI interface [60MHz]
1 - Select the 16-bit UTMI interface [30MHz]</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PSPD</name>
              <description>PSPD
Port Speed - Read Only.
This register field indicates the speed at which the port is operating.
00 - Full Speed
01 - Low Speed
10 - High Speed
11 - Undefined</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PFSC</name>
              <description>PFSC
Port Force Full Speed Connect - Read/Write. Default = 0b.
When this bit is set to '1b', the port will be forced to only connect at Full Speed, It disables the chirp
sequence that allows the port to identify itself as High Speed.
0 - Normal operation
1 - Forced to full speed</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHCD</name>
              <description>PHCD
PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write. Default = 0b.
When this bit is set to '1b', the PHY clock is disabled. Reading this bit will indicate the status of the PHY
clock.
NOTE: The PHY clock cannot be disabled if it is being used as the system clock.
In device mode, The PHY can be put into Low Power Suspend when the device is not running (USBCMD
Run/Stop=0b) or the host has signalled suspend (PORTSC1 SUSPEND=1b). PHY Low power suspend
will be cleared automatically when the host initials resume. Before forcing a resume from the device, the
device controller driver must clear this bit.
In host mode, the PHY can be put into Low Power Suspend when the downstream device has been put
into suspend mode or when no downstream device is connected. Low power suspend is completely
under the control of software.
0 - Enable PHY clock
1 - Disable PHY clock</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKOC</name>
              <description>WKOC
Wake on Over-current Enable (WKOC_E) - Read/Write. Default = 0b.
Writing this bit to a one enables the port to be sensitive to over-current conditions as wake-up events.
This field is zero if Port Power(PORTSC1) is zero.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKDC</name>
              <description>WKDC
Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write. Default=0b. Writing this bit to a one enables
the port to be sensitive to device disconnects as wake-up events.
This field is zero if Port Power(PORTSC1) is zero or in device mode.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WKCN</name>
              <description>WKCN
Wake on Connect Enable (WKCNNT_E) - Read/Write. Default=0b.
Writing this bit to a one enables the port to be sensitive to device connects as wake-up events.
This field is zero if Port Power(PORTSC1) is zero or in device mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PTC</name>
              <description>PTC
Port Test Control - Read/Write. Default = 0000b.
Refer to Port Test Mode for the operational model for using these test modes and the USB Specification Revision 2.0, Chapter 7 for details on each test mode.
The FORCE_ENABLE_FS and FORCE ENABLE_LS are extensions to the test mode support specified in the EHCI specification.
Writing the PTC field to any of the FORCE_ENABLE_{HS/FS/LS} values will force the port into the connected and enabled state at the selected speed.
Writing the PTC field back to TEST_MODE_DISABLE will allow the port state machines to progress normally from that point.
NOTE: Low speed operations are not supported as a peripheral device.
Any other value than zero indicates that the port is operating in test mode.
Value Specific Test
0000 - TEST_MODE_DISABLE
0001 - J_STATE
0010 - K_STATE
0011 - SE0 (host) / NAK (device)
0100 - Packet
0101 - FORCE_ENABLE_HS
0110 - FORCE_ENABLE_FS
0111 - FORCE_ENABLE_LS
1000-1111 - Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PP</name>
              <description>PP
Port Power (PP)-Read/Write or Read Only.
The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:
PPC
PP Operation
0
1b Read Only - Host controller does not have port power control switches. Each port is hard-wired to power.
1
1b/0b - Read/Write. OTG controller requires port power control switches. This bit represents the current setting of the switch (0=off, 1=on).
When power is not available on a port (that is, PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.
When an over-current condition is detected on a powered port and PPC is a one,
the PP bit in each affected port may be transitional by the host controller driver from a one to a zero (removing power from the port).
This feature is implemented in all controller cores (PPC = 1).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LS</name>
              <description>LS
Line Status-Read Only. These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal
lines.
In host mode, the use of linestate by the host controller driver is not necessary (unlike EHCI), because
the port controller state machine and the port routing manage the connection of LS and FS.
In device mode, the use of linestate by the device controller driver is not necessary.
The encoding of the bits are:
Bits [11:10] Meaning
00 - SE0
01 - K-state
10 - J-state
11 - Undefined</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HSP</name>
              <description>HSP
High-Speed Port - Read Only. Default = 0b.
When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the
host/device connected to the port is not in a high-speed mode.
NOTE: HSP is redundant with PSPD(bit 27, 26) but remained for compatibility.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PR</name>
              <description>PR
Port Reset - Read/Write or Read Only. Default = 0b.
In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. Default 0.
When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started.
This bit will automatically change to zero after the reset sequence is complete.
This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.
In Device Mode: This bit is a read only status bit. Device reset from the USB bus is also indicated in the USBSTS register.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSP</name>
              <description>SUSP
Suspend - Read/Write or Read Only. Default = 0b.
1=Port in suspend state. 0=Port not in suspend state.
In Host Mode: Read/Write.
Port Enabled Bit and Suspend bit of this register define the port states as follows:
Bits [Port Enabled, Suspend] Port State
0x Disable
10 Enable
11 Suspend
When in suspend state, downstream propagation of data is blocked on this port, except for port reset.
The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1.
In the suspend state, the port is sensitive to resume detection.
Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.
The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. The host controller ignores a write of zero to this bit.
If host software sets this bit to a one when the port is not enabled (that is, Port enabled bit is a zero) the results are undefined.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode: Read Only.
In device mode this bit is a read only status bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FPR</name>
              <description>FPR
Force Port Resume -Read/Write. 1= Resume detected/driven on port. 0=No resume (K-state) detected driven on port. Default = 0.
In Host Mode:
Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state.
When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.
This bit will automatically change to zero after the resume sequence is complete.
This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.
Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0.
The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one. This bit will remain a one until the port has switched to the high-speed idle.
Writing a zero has no effect because the port controller will time the resume operation, clear the bit the port control state switches to HS or FS idle.
This field is zero if Port Power(PORTSC1) is zero in host mode.
This bit is not-EHCI compatible.
In Device mode:
After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing.
The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state.
The bit will be cleared when the device returns to normal operation.
 Also, when this bit wil be cleared because a K-to-J transition detected, the Port Change Detect bit in the USBSTS register is also set to one.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCC</name>
              <description>OCC
Over-current Change-R/WC. Default=0.
This bit is set '1b' by hardware when there is a change to Over-current Active. Software can clear this bit by writing a one to this bit position.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCA</name>
              <description>OCA
Over-current Active-Read Only. Default 0.
This bit will automatically transition from one to zero when the over current condition is removed.
0 - This port does not have an over-current condition.
1 - This port currently has an over-current condition</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PEC</name>
              <description>PEC
Port Enable/Disable Change-R/WC. 1=Port enabled/disabled status has changed. 0=No change. Default = 0.
In Host Mode:
For the root hub, this bit is set to a one only when a port is disabled due to disconnect on the port or
due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification).
Software clears this by writing a one to it.
This field is zero if Port Power(PORTSC1) is zero.
In Device mode:
The device port is always enabled, so this bit is always '0b'.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE</name>
              <description>PE
Port Enabled/Disabled-Read/Write. 1=Enable. 0=Disable. Default 0.
In Host Mode:
Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field.
Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software.
Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.
When the port is disabled, (0b) downstream propagation of data is blocked except for reset.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
The device port is always enabled, so this bit is always '1b'.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSC</name>
              <description>CSC
Connect Status Change-R/WC. 1 =Change in Current Connect Status. 0=No change. Default 0.
In Host Mode:
Indicates a change has occurred in the port's Current Connect Status.
The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change.
For example, the insertion status changes twice before system software has cleared the changed condition,
hub hardware will be 'setting' an already-set bit (that is, the bit will remain set). Software clears this bit by writing a one to it.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
This bit is undefined in device controller mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CCS</name>
              <description>CCS
Current Connect Status-Read Only.
In Host Mode:
1=Device is present on port. 0=No device is present. Default = 0.
This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set.
This field is zero if Port Power(PORTSC1) is zero in host mode.
In Device Mode:
1=Attached. 0=Not Attached. Default=0.
A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register.
A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register.
It does not state the device being disconnected or Suspended.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OTGSC</name>
          <description>On-The-Go Status &amp; control Register</description>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x07070723</resetMask>
          <fields>
            <field>
              <name>ASVIE</name>
              <description>ASVIE
A Session Valid Interrupt Enable - Read/Write.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVVIE</name>
              <description>AVVIE
A VBus Valid Interrupt Enable - Read/Write.
Setting this bit enables the A VBus valid interrupt.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDIE</name>
              <description>IDIE
USB ID Interrupt Enable - Read/Write.
Setting this bit enables the USB ID interrupt.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASVIS</name>
              <description>ASVIS
A Session Valid Interrupt Status - Read/Write to Clear.
This bit is set when VBus has either risen above or fallen below the A session valid threshold.
Software must write a one to clear this bit.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVVIS</name>
              <description>AVVIS
A VBus Valid Interrupt Status - Read/Write to Clear.
This bit is set when VBus has either risen above or fallen below the VBus valid threshold on an A device.
Software must write a one to clear this bit.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDIS</name>
              <description>IDIS
USB ID Interrupt Status - Read/Write.
This bit is set when a change on the ID input has been detected.
Software must write a one to clear this bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASV</name>
              <description>ASV
A Session Valid - Read Only.
Indicates VBus is above the A session valid threshold.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AVV</name>
              <description>AVV
A VBus Valid - Read Only.
Indicates VBus is above the A VBus valid threshold.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ID</name>
              <description>ID
USB ID - Read Only.
0 = A device, 1 = B device</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDPU</name>
              <description>IDPU
ID Pullup - Read/Write
This bit provide control over the ID pull-up resistor; 0 = off, 1 = on [default]. When this bit is 0, the ID input
will not be sampled.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VC</name>
              <description>VC
VBUS Charge - Read/Write.
Setting this bit causes the VBus line to be charged. This is used for VBus pulsing during SRP.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VD</name>
              <description>VD
VBUS_Discharge - Read/Write.
Setting this bit causes VBus to discharge through a resistor.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBMODE</name>
          <description>USB Device Mode Register</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>SDIS</name>
              <description>SDIS
Stream Disable Mode. (0 - Inactive [default]; 1 - Active)
Device Mode: Setting to a '1' disables double priming on both RX and TX for low bandwidth systems.
This mode ensures that when the RX and TX buffers are sufficient to contain an entire packet that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems.
Note: In High Speed Mode, all packets received are responded to with a NYET handshake when stream disable is active.
Host Mode: Setting to a '1' ensures that overruns/underruns of the latency FIFO are eliminated for low bandwidth systems
where the RX and TX buffers are sufficient to contain the entire packet. Enabling stream disable also has the effect of ensuring the TX latency is filled to capacity before the packet is launched onto the USB.
NOTE: Time duration to pre-fill the FIFO becomes significant when stream disable is active. See TXFILLTUNING and TXTTFILLTUNING [MPH Only] to characterize the adjustments needed for
the scheduler when using this feature.
NOTE: The use of this feature substantially limits of the overall USB performance that can be achieved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLOM</name>
              <description>SLOM
Setup Lockout Mode. In device mode, this bit controls behavior of the setup lock mechanism. See Control Endpoint Operation Model .
0 - Setup Lockouts On (default);
1 - Setup Lockouts Off. DCD requires use of Setup Data Buffer Tripwire in USBCMD.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ES</name>
              <description>ES
Endian Select - Read/Write. This bit can change the byte alignment of the transfer buffers to match the
host microprocessor. The bit fields in the microprocessor interface and the data structures are unaffected
by the value of this bit because they are based upon the 32-bit word.
Bit Meaning
0 - Little Endian [Default]
1 - Big Endian</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CM</name>
              <description>CM
Controller Mode - R/WO. Controller mode is defaulted to the proper mode for host only and device only
implementations. For those designs that contain both host &amp; device capability, the controller defaults to
an idle state and needs to be initialized to the desired operating mode after reset. For combination host/
device controllers, this register can only be written once after reset. If it is necessary to switch modes,
software must reset the controller by writing to the RESET bit in the USBCMD register before
reprogramming this register.
For OTG controller core, reset value is '00b'.
00 - Idle [Default for combination host/device]
01 - Reserved
10 - Device Controller [Default for device only controller]
11 - Host Controller [Default for host only controller]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTSETUPSTAT</name>
          <description>Endpoint Setup Status Register</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>ENDPTSETUPSTAT</name>
              <description>ENDPTSETUPSTAT
Setup Endpoint Status. For every setup transaction that is received, a corresponding bit in this register is set to one.
Software must clear or acknowledge the setup transfer by writing a one to a respective bit after it has read the setup data from Queue head.
The response to a setup packet as in the order of operations and total response time is crucial to limit bus time outs while the setup lock out mechanism is engaged.
This register is only used in device mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTPRIME</name>
          <description>Endpoint Prime Register</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PETB</name>
              <description>PETB
Prime Endpoint Transmit Buffer - R/WS. For each endpoint a corresponding bit is used to request that a
buffer is prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction.
Software should write a one to the corresponding bit when posting a new transfer descriptor to an
endpoint queue head. Hardware automatically uses this bit to begin parsing for a new transfer descriptor
from the queue head and prepare a transmit buffer. Hardware clears this bit when the associated
endpoint(s) is (are) successfully primed.
NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD
is retired, and the dQH is updated.
PETB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERB</name>
              <description>PERB
Prime Endpoint Receive Buffer - R/WS. For each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a USB host initiates a USB OUT transaction.
Software should write a one to the corresponding bit whenever posting a new transfer descriptor to an endpoint queue head.
Hardware automatically uses this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer.
Hardware clears this bit when the associated endpoint(s) is (are) successfully primed.
NOTE: These bits are momentarily set by hardware during hardware re-priming operations when a dTD
is retired, and the dQH is updated.
PERB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTFLUSH</name>
          <description>Endpoint Flush Register</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FETB</name>
              <description>FETB
Flush Endpoint Transmit Buffer - R/WS. Writing one to a bit(s) in this register causes the associated endpoint(s) to clear any primed buffers.
If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.
Hardware clears this register after the endpoint flush operation is successful.
FETB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FERB</name>
              <description>FERB
Flush Endpoint Receive Buffer - R/WS. Writing one to a bit(s) causes the associated endpoint(s) to clear any primed buffers.
 If a packet is in progress for one of the associated endpoints, then that transfer continues until completion.
Hardware clears this register after the endpoint flush operation is successful.
FERB[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTSTAT</name>
          <description>Endpoint Status Register</description>
          <addressOffset>0x1b8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETBR</name>
              <description>ETBR
Endpoint Transmit Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective endpoint buffer.
This bit is set to one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register.
There is always a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready.
This delay time varies based upon the current USB traffic and the number of bits set in the ENDPRIME register.
Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.
NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations when a dTD is retired, and the dQH is updated.
ETBR[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERBR</name>
              <description>ERBR
Endpoint Receive Buffer Ready -- Read Only. One bit for each endpoint indicates status of the respective
endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a
corresponding bit in the ENDPRIME register. There is always a delay between setting a bit in the
ENDPRIME register and endpoint indicating ready. This delay time varies based upon the current USB
traffic and the number of bits set in the ENDPRIME register. Buffer ready is cleared by USB reset, by the
USB DMA system, or through the ENDPTFLUSH register.
NOTE: These bits are momentarily cleared by hardware during hardware endpoint re-priming operations
when a dTD is retired, and the dQH is updated.
ERBR[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENDPTCOMPLETE</name>
          <description>Endpoint Complete Register</description>
          <addressOffset>0x1bc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ETCE</name>
              <description>ETCE
Endpoint Transmit Complete Event - R/WC. Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status.
If the corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the USBINT . Writing one clears the corresponding bit in this register.
ETCE[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERCE</name>
              <description>ERCE
Endpoint Receive Complete Event - RW/C. Each bit indicates a received event (OUT/SETUP) occurred
and software should read the corresponding endpoint queue to determine the transfer status. If the
corresponding IOC bit is set in the Transfer Descriptor, then this bit is set simultaneously with the
USBINT . Writing one clears the corresponding bit in this register.
ERCE[N] - Endpoint #N, N is in 0..7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>ENDPTCTRL0,ENDPTCTRL1,ENDPTCTRL2,ENDPTCTRL3,ENDPTCTRL4,ENDPTCTRL5,ENDPTCTRL6,ENDPTCTRL7,ENDPTCTRL8,ENDPTCTRL9,ENDPTCTRL10,ENDPTCTRL11,ENDPTCTRL12,ENDPTCTRL13,ENDPTCTRL14,ENDPTCTRL15</dimIndex>
          <name>ENDPTCTRL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00CD00CD</resetMask>
          <fields>
            <field>
              <name>TXE</name>
              <description>TXE
TX Endpoint Enable
0 Disabled [Default]
1 Enabled
An Endpoint should be enabled only after it has been configured.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXR</name>
              <description>TXR
TX Data Toggle Reset (WS)
Write 1 - Reset PID Sequence
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order
to synchronize the data PID's between the Host and device.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TXT</name>
              <description>TXT
TX Endpoint Type - Read/Write
00 Control
01 Isochronous
10 Bulk
11 Interrupt</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXS</name>
              <description>TXS
TX Endpoint Stall - Read/Write
0 End Point OK
1 End Point Stalled
This bit will be cleared automatically upon receipt of a SETUP request if this Endpoint is configured
as a Control Endpoint and this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit is cleared.
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host.
This control will continue to STALL until this bit is either cleared by software or automatically cleared as above for control endpoints.
NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit.
In most systems, it is unlikely the DCD software will observe this delay. However, should the DCD observe that the stall bit is not set after writing a one to it then follow this procedure:
continually write this stall bit until it is set or until a new setup has been received by checking the associated endptsetupstat Bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXE</name>
              <description>RXE
RX Endpoint Enable
0 Disabled [Default]
1 Enabled
An Endpoint should be enabled only after it has been configured.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXR</name>
              <description>RXR
RX Data Toggle Reset (WS)
Write 1 - Reset PID Sequence
Whenever a configuration event is received for this Endpoint, software must write a one to this bit in order
to synchronize the data PID's between the host and device.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RXT</name>
              <description>RXT
RX Endpoint Type - Read/Write
00 Control
01 Isochronous
10 Bulk
11 Interrupt</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXS</name>
              <description>RXS
RX Endpoint Stall - Read/Write
0 End Point OK. [Default]
1 End Point Stalled
This bit is set automatically upon receipt of a SETUP request if this Endpoint is configured as a Control
Endpointand this bit will continue to be cleared by hardware until the associated ENDPTSETUPSTAT bit
is cleared.
Software can write a one to this bit to force the endpoint to return a STALL handshake to the Host. This
control will continue to STALL until this bit is either cleared by software or automatically cleared as above
for control endpoints.
NOTE: [CONTROL ENDPOINT TYPES ONLY]: there is a slight delay (50 clocks max) between the
ENDPTSETUPSTAT begin cleared and hardware continuing to clear this bit. In most systems, it
is unlikely the DCD software will observe this delay. However, should the DCD observe that the
stall bit is not set after writing a one to it then follow this procedure: continually write this stall bit
until it is set or until a new setup has been received by checking the associated endptsetupstat
Bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OTG_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x020B3F90</resetMask>
          <fields>
            <field>
              <name>OTG_WKDPDMCHG_EN</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTORESUME_EN</name>
              <description>No description available</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_VBUS_WAKEUP_EN</name>
              <description>No description available</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_ID_WAKEUP_EN</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_VBUS_SOURCE_SEL</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_UTMI_SUSPENDM_SW</name>
              <description>default 0 for naneng usbphy</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_UTMI_RESET_SW</name>
              <description>default 1 for naneng usbphy</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_WAKEUP_INT_ENABLE</name>
              <description>No description available</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_POWER_MASK</name>
              <description>No description available</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_OVER_CUR_POL</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OTG_OVER_CUR_DIS</name>
              <description>No description available</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SER_MODE_SUSPEND_EN</name>
              <description>for naneng usbphy, only switch to serial mode when suspend</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x02007007</resetMask>
          <fields>
            <field>
              <name>GPIO_ID_SEL_N</name>
              <description>No description available</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SESS_VALID_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_OVERRIDE</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SESS_VALID_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID_OVERRIDE_EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL1</name>
          <description>No description available</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00100002</resetMask>
          <fields>
            <field>
              <name>UTMI_CFG_RST_N</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_OTG_SUSPENDM</name>
              <description>OTG suspend, not utmi_suspendm</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TOP_STATUS</name>
          <description>No description available</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>WAKEUP_INT_STATUS</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_STATUS</name>
          <description>No description available</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x800000F5</resetMask>
          <fields>
            <field>
              <name>UTMI_CLK_VALID</name>
              <description>No description available</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINE_STATE</name>
              <description>No description available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_DISCONNECT</name>
              <description>No description available</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ID_DIG</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UTMI_SESS_VALID</name>
              <description>No description available</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBUS_VALID</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDXC0</name>
      <description>SDXC0</description>
      <groupName>SDXC</groupName>
      <baseAddress>0xf1130000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SDMASA</name>
          <description>No description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BLOCKCNT_SDMASA</name>
              <description>32-bit Block Count (SDMA System Address)
- SDMA System Address (Host Version 4 Enable = 0): This register contains the system memory address for an SDMA transfer in the 32-bit addressing mode.
When the Host Controller stops an SDMA transfer, this register points to the system address of the next contiguous data position.
It can be accessed only if no transaction is executing. Reading this register during data transfers may
return an invalid value.
- 32-bit Block Count (Host Version 4 Enable = 1): From the Host Controller Version 4.10 specification, this register is redefined as 32-bit Block Count.
The Host Controller decrements the block count of this register for every block transfer and the data transfer stops when the count reaches zero.
This register must be accessed when no transaction is executing. Reading this register during data transfers may return invalid value.
Following are the values for BLOCKCNT_SDMASA:
- 0xFFFF_FFFF: 4G - 1 Block
-
- 0x0000_0002: 2 Blocks
- 0x0000_0001: 1 Block
- 0x0000_0000: Stop Count
Note:
- For Host Version 4 Enable = 0, the Host driver does not program the system address in this register while operating in ADMA mode.
The system address must be programmed in the ADMA System Address register.
- For Host Version 4 Enable = 0, the Host driver programs a non-zero 32-bit block count value in this register when Auto CMD23 is enabled for non-DMA and ADMA modes.
Auto CMD23 cannot be used with SDMA.
- This register must be programmed with a non-zero value for data transfer if the 32-bit Block count register is used instead of the 16-bit Block count register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BLK_ATTR</name>
          <description>No description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00020210</resetValue>
          <resetMask>0xFFFF7FFF</resetMask>
          <fields>
            <field>
              <name>BLOCK_CNT</name>
              <description>16-bit Block Count
- If the Host Version 4 Enable bit is set 0 or the 16-bit Block Count register is set to non-zero, the 16-bit Block Count register is selected.
- If the Host Version 4 Enable bit is set 1 and the 16-bit Block Count register is set to zero, the 32-bit Block Count register is selected.
Following are the values for BLOCK_CNT:
- 0x0: Stop Count
- 0x1: 1 Block
- 0x2: 2 Blocks
- .
- 0xFFFF: 65535 Blocks
Note: For Host Version 4 Enable = 0, this register must be set to 0000h before programming the 32-bit block count register when Auto CMD23 is enabled for non-DMA and ADMA modes.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SDMA_BUF_BDARY</name>
              <description>SDMA Buffer Boundary
These bits specify the size of contiguous buffer in system memory.
The SDMA transfer waits at every boundary specified by these fields and the Host Controller generates the DMA interrupt to request the Host Driver to update the SDMA System Address register.
Values:
- 0x0 (BYTES_4K): 4K bytes SDMA Buffer Boundary
- 0x1 (BYTES_8K): 8K bytes SDMA Buffer Boundary
- 0x2 (BYTES_16K): 16K bytes SDMA Buffer Boundary
- 0x3 (BYTES_32K): 32K bytes SDMA Buffer Boundary
- 0x4 (BYTES_64K): 64K bytes SDMA Buffer Boundary
- 0x5 (BYTES_128K): 128K bytes SDMA Buffer Boundary
- 0x6 (BYTES_256K): 256K bytes SDMA Buffer Boundary
- 0x7 (BYTES_512K): 512K bytes SDMA Buffer Boundary</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XFER_BLOCK_SIZE</name>
              <description>Transfer Block Size
These bits specify the block size of data transfers. In case of memory, it is set to 512 bytes. It can be accessed only if no transaction is executing.
Read operations during transfers may return an invalid value, and write operations are ignored. Following are the values for XFER_BLOCK_SIZE:
- 0x1: 1 byte
- 0x2: 2 bytes
- 0x3: 3 bytes
- .
- 0x1FF: 511 byte
- 0x200: 512 byt es
- .
- 0x800: 2048 bytes
Note: This register must be programmed with a non-zero value for data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_ARG</name>
          <description>No description available</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ARGUMNET</name>
              <description>Command Argument
These bits specify the SD/eMMC command argument that is specified in bits 39-8 of the Command format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_XFER</name>
          <description>No description available</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFF01FF</resetMask>
          <fields>
            <field>
              <name>CMD_INDEX</name>
              <description>Command Index
These bits are set to the command number that is specified in bits 45-40 of the Command Format.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_TYPE</name>
              <description>Command Type
These bits indicate the command type.
Note: While issuing Abort CMD using CMD12/CMD52 or reset CMD using CMD0/CMD52, CMD_TYPE field shall be set to 0x3.
Values:
0x3 (ABORT_CMD): Abort
0x2 (RESUME_CMD): Resume
0x1 (SUSPEND_CMD): Suspend
0x0 (NORMAL_CMD): Normal</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_PRESENT_SEL</name>
              <description>Data Present Select
This bit is set to 1 to indicate that data is present and that the data is transferred using the DAT line. This bit is set to 0 in the following instances:
Command using the CMD line
Command with no data transfer but using busy signal on the DAT[0] line
Resume Command
Values:
0x0 (NO_DATA): No Data Present
0x1 (DATA): Data Present</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_IDX_CHK_ENABLE</name>
              <description>Command Index Check Enable
This bit enables the Host Controller to check the index field in the response to verify if it has the same value as the command index.
If the value is not the same, it is reported as a Command Index error.
Note:
Index Check enable must be set to 0 for the command with no response, R2 response, R3 response and R4 response.
For the tuning command, this bit must always be set to enable the index check.
Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_CRC_CHK_ENABLE</name>
              <description>Command CRC Check Enable
This bit enables the Host Controller to check the CRC field in the response. If an error is detected, it is reported as a Command CRC error.
Note:
CRC Check enable must be set to 0 for the command with no response, R3 response, and R4 response.
For the tuning command, this bit must always be set to 1 to enable the CRC check.
Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUB_CMD_FLAG</name>
              <description>Sub Command Flag
This bit distinguishes between a main command and a sub command.
Values:
0x0 (MAIN): Main Command
0x1 (SUB): Sub Command</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_TYPE_SELECT</name>
              <description>Response Type Select
This bit indicates the type of response expected from the card.
Values:
0x0 (NO_RESP): No Response
0x1 (RESP_LEN_136): Response Length 136
0x2 (RESP_LEN_48): Response Length 48
0x3 (RESP_LEN_48B): Response Length 48; Check Busy after response</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_INT_DISABLE</name>
              <description>Response Interrupt Disable
The Host Controller supports response check function to avoid overhead of response error check by the Host driver.
Response types of only R1 and R5 can be checked by the Controller.
If Host Driver checks the response error, set this bit to 0 and wait for Command Complete Interrupt and then check the response register.
If the Host Controller checks the response error, set this bit to 1 and set the Response Error Check Enable bit to 1.
The Command Complete Interrupt is disabled by this bit regardless of the Command Complete Signal Enable.
Note: During tuning (when the Execute Tuning bit in the Host Control2 register is set), the Command Complete Interrupt is not generated irrespective of the Response Interrupt Disable setting.
Values:
- 0x0 (ENABLED): Response Interrupt is enabled
- 0x1 (DISABLED): Response Interrupt is disabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_ERR_CHK_ENABLE</name>
              <description>Response Error Check Enable
The Host Controller supports response check function to avoid overhead of response error check by Host driver. Response types of only R1 and R5 can be checked by the Controller.
If the Host Controller checks the response error, set this bit to 1 and set Response Interrupt Disable to 1. If an error is detected, the Response Error interrupt is generated in the Error Interrupt Status register.
Note:
- Response error check must not be enabled for any response type other than R1 and R5.
- Response check must not be enabled for the tuning command.
Values:
- 0x0 (DISABLED): Response Error Check is disabled
- 0x1 (ENABLED): Response Error Check is enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_TYPE</name>
              <description>Response Type R1/R5
This bit selects either R1 or R5 as a response type when the Response Error Check is selected.
Error statuses checked in R1:
OUT_OF_RANGE
ADDRESS_ERROR
BLOCK_LEN_ERROR
WP_VIOLATION
CARD_IS_LOCKED
COM_CRC_ERROR
CARD_ECC_FAILED
CC_ERROR
ERROR
Response Flags checked in R5:
COM_CRC_ERROR
ERROR
FUNCTION_NUMBER
OUT_OF_RANGE
Values:
0x0 (RESP_R1): R1 (Memory)
0x1 (RESP_R5): R5 (SDIO)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MULTI_BLK_SEL</name>
              <description>Multi/Single Block Select
This bit is set when issuing multiple-block transfer commands using the DAT line. If this bit is set to 0, it is not necessary to set the Block Count register.
Values:
0x0 (SINGLE): Single Block
0x1 (MULTI): Multiple Block</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_XFER_DIR</name>
              <description>Data Transfer Direction Select
This bit defines the direction of DAT line data transfers.
This bit is set to 1 by the Host Driver to transfer data from the SD/eMMC card to the Host Controller and it is set to 0 for all other commands.
Values:
0x1 (READ): Read (Card to Host)
0x0 (WRITE): Write (Host to Card)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CMD_ENABLE</name>
              <description>Auto Command Enable
This field determines use of Auto Command functions.
Note: In SDIO, this field must be set as 00b (Auto Command Disabled).
Values:
0x0 (AUTO_CMD_DISABLED): Auto Command Disabled
0x1 (AUTO_CMD12_ENABLED): Auto CMD12 Enable
0x2 (AUTO_CMD23_ENABLED): Auto CMD23 Enable
0x3 (AUTO_CMD_AUTO_SEL): Auto CMD Auto Sel</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_COUNT_ENABLE</name>
              <description>Block Count Enable
This bit is used to enable the Block Count register, which is relevant for multiple block transfers.
If this bit is set to 0, the Block Count register is disabled, which is useful in executing an infinite transfer.
The Host Driver must set this bit to 0 when ADMA is used.
Values:
0x1 (ENABLED): Enable
0x0 (DISABLED): Disable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_ENABLE</name>
              <description>DMA Enable
This bit enables the DMA functionality. If this bit is set to 1, a DMA operation begins when the Host Driver writes to the Command register.
You can select one of the DMA modes by using DMA Select in the Host Control 1 register.
Values:
0x1 (ENABLED): DMA Data transfer
0x0 (DISABLED): No data transfer or Non-DMA data transfer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>RESP01,RESP23,RESP45,RESP67</dimIndex>
          <name>RESP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP01</name>
              <description>Command Response
These bits reflect 39-8 bits of SD/eMMC Response Field.
Note: For Auto CMD, the 32-bit response (bits 39-8 of the Response Field) is updated in the RESP[RESP67] register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUF_DATA</name>
          <description>No description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUF_DATA</name>
              <description>Buffer Data
These bits enable access to the Host Controller packet buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSTATE</name>
          <description>No description available</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x19FF0FFF</resetMask>
          <fields>
            <field>
              <name>SUB_CMD_STAT</name>
              <description>Sub Command Status
This bit is used to distinguish between a main command and a sub command status.
Values:
0x0 (FALSE): Main Command Status
0x1 (TRUE): Sub Command Status</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_ISSUE_ERR</name>
              <description>Command Not Issued by Error
This bit is set if a command cannot be issued after setting the command register due to an error except the Auto CMD12 error.
Values:
0x0 (FALSE): No error for issuing a command
0x1 (TRUE): Command cannot be issued</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_LINE_LVL</name>
              <description>Command-Line Signal Level
This bit is used to check the CMD line level to recover from errors and for debugging. These bits reflect the value of the sd_cmd_in signal.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_3_0</name>
              <description>DAT[3:0] Line Signal Level
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the sd_dat_in (lower nibble) signal.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PROTECT_SW_LVL</name>
              <description>Write Protect Switch Pin Level
This bit is supported only for memory and combo cards. This bit reflects the synchronized value of the card_write_prot signal.
Values:
0x0 (FALSE): Write protected
0x1 (TRUE): Write enabled</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_DETECT_PIN_LEVEL</name>
              <description>Card Detect Pin Level
This bit reflects the inverse synchronized value of the card_detect_n signal.
Values:
0x0 (FALSE): No card present
0x1 (TRUE): Card Present</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_STABLE</name>
              <description>Card Stable
This bit indicates the stability of the Card Detect Pin Level. A card is not detected if this bit is set to 1 and the value of the CARD_INSERTED bit is 0.
Values:
0x0 (FALSE): Reset or Debouncing
0x1 (TRUE): No Card or Inserted</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_INSERTED</name>
              <description>Card Inserted
This bit indicates whether a card has been inserted. The Host Controller debounces this signal so that Host Driver need not wait for it to stabilize.
Values:
0x0 (FALSE): Reset, Debouncing, or No card
0x1 (TRUE): Card Inserted</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_RD_ENABLE</name>
              <description>Buffer Read Enable
This bit is used for non-DMA transfers. This bit is set if valid data exists in the Host buffer.
Values:
0x0 (DISABLED): Read disable
0x1 (ENABLED): Read enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_WR_ENABLE</name>
              <description>Buffer Write Enable
This bit is used for non-DMA transfers. This bit is set if space is available for writing data.
Values:
0x0 (DISABLED): Write disable
0x1 (ENABLED): Write enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_XFER_ACTIVE</name>
              <description>Read Transfer Active
This bit indicates whether a read transfer is active for SD/eMMC mode.
Values:
0x0 (INACTIVE): No valid data
0x1 (ACTIVE): Transferring data</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_XFER_ACTIVE</name>
              <description>Write Transfer Active
This status indicates whether a write transfer is active for SD/eMMC mode.
Values:
0x0 (INACTIVE): No valid data
0x1 (ACTIVE): Transferring data</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_7_4</name>
              <description>DAT[7:4] Line Signal Level
This bit is used to check the DAT line level to recover from errors and for debugging. These bits reflect the value of the sd_dat_in (upper nibble) signal.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RE_TUNE_REQ</name>
              <description>Re-Tuning Request
SDXC does not generate retuning request. The software must maintain the Retuning timer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_LINE_ACTIVE</name>
              <description>DAT Line Active (
This bit indicates whether one of the DAT lines on the SD/eMMC bus is in use.
In the case of read transactions, this bit indicates whether a read transfer is executing on the SD/eMMC bus.
In the case of write transactions, this bit indicates whether a write transfer is executing on the SD/eMMC bus.
For a command with busy, this status indicates whether the command executing busy is executing on an SD or eMMC bus.
Values:
0x0 (INACTIVE): DAT Line Inactive
0x1 (ACTIVE): DAT Line Active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DAT_INHIBIT</name>
              <description>Command Inhibit (DAT)
This bit is generated if either DAT line active or Read transfer active is set to 1.
If this bit is set to 0, it indicates that the Host Controller can issue subsequent SD/eMMC commands.
Values:
0x0 (READY): Can issue command which used DAT line
0x1 (NOT_READY): Cannot issue command which used DAT line</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_INHIBIT</name>
              <description>Command Inhibit (CMD)
This bit indicates the following :
If this bit is set to 0, it indicates that the CMD line is not in use and the Host controller can issue an SD/eMMC command using the CMD line.
This bit is set when the command register is written. This bit is cleared when the command response is received.
This bit is not cleared by the response of auto CMD12/23 but cleared by the response of read/write command.
Values:
0x0 (READY): Host Controller is ready to issue a command
0x1 (NOT_READY): Host Controller is not ready to issue a command</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROT_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x070F0F3E</resetMask>
          <fields>
            <field>
              <name>CARD_REMOVAL</name>
              <description>Wakeup Event Enable on SD Card Removal
This bit enables wakeup event through Card Removal assertion in the Normal Interrupt Status register.
For the SDIO card, Wake Up Support (FN_WUS) in the Card Information Structure (CIS) register does not affect this bit.
Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INSERT</name>
              <description>Wakeup Event Enable on SD Card Insertion
This bit enables wakeup event through Card Insertion assertion in the Normal Interrupt Status register.
FN_WUS (Wake Up Support) in CIS does not affect this bit.
Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INT</name>
              <description>Wakeup Event Enable on Card Interrupt
This bit enables wakeup event through a Card Interrupt assertion in the Normal Interrupt Status register.
This bit can be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.
Values:
0x0 (DISABLED): Disable
0x1 (ENABLED): Enable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_AT_BGAP</name>
              <description>Interrupt At Block Gap
This bit is valid only in the 4-bit mode of an SDIO card and is used to select a sample point in the interrupt cycle.
Setting to 1 enables interrupt detection at the block gap for a multiple block transfer.
Values:
0x0 (DISABLE): Disabled
0x1 (ENABLE): Enabled</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_WAIT_CTRL</name>
              <description>Read Wait Control
This bit is used to enable the read wait protocol to stop read data using DAT[2] line if the card supports read wait.
Otherwise, the Host Controller has to stop the card clock to hold the read data. In UHS-II mode, Read Wait is disabled.
Values:
0x0 (DISABLE): Disable Read Wait Control
0x1 (ENABLE): Enable Read Wait Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUE_REQ</name>
              <description>Continue Request
This bit is used to restart the transaction, which was stopped using the Stop At Block Gap Request.
The Host Controller automatically clears this bit when the transaction restarts.
If stop at block gap request is set to 1, any write to this bit is ignored.
Values:
0x0 (NO_AFFECT): No Affect
0x1 (RESTART): Restart</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_BG_REQ</name>
              <description>Stop At Block Gap Request
This bit is used to stop executing read and write transactions at the next block gap for non-DMA, SDMA, and ADMA transfers.
Values:
0x0 (XFER): Transfer
0x1 (STOP): Stop</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_BUS_VOL_VDD1</name>
              <description>SD Bus Voltage Select for VDD1/eMMC Bus Voltage Select for VDD
These bits enable the Host Driver to select the voltage level for an SD/eMMC card.
Before setting this register, the Host Driver checks the Voltage Support bits in the Capabilities register.
If an unsupported voltage is selected, the Host System does not supply the SD Bus voltage.
The value set in this field is available on the SDXC output signal (sd_vdd1_sel), which is used by the voltage switching circuitry.
SD Bus Voltage Select options:
0x7 : 3.3V(Typical)
0x6 : 3.0V(Typical)
0x5 : 1.8V(Typical) for Embedded
0x4 : 0x0 - Reserved
eMMC Bus Voltage Select options:
0x7 : 3.3V(Typical)
0x6 : 1.8V(Typical)
0x5 : 1.2V(Typical)
0x4 : 0x0 - Reserved
Values:
0x7 (V_3_3): 3.3V (Typ.)
0x6 (V_3_0): 3.0V (Typ.)
0x5 (V_1_8): 1.8V (Typ.) for Embedded
0x4 (RSVD4): Reserved
0x3 (RSVD3): Reserved
0x2 (RSVD2): Reserved
0x1 (RSVD1): Reserved
0x0 (RSVD0): Reserved</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_BUS_PWR_VDD1</name>
              <description>SD Bus Power for VDD1
This bit enables VDD1 power of the card.
This setting is available on the sd_vdd1_on output of SDXC so that it can be used to control the VDD1 power supply of the card.
Before setting this bit, the SD Host Driver sets the SD Bus Voltage Select bit. If the Host Controller detects a No Card state, this bit is cleared.
In SD mode, if this bit is cleared, the Host Controller stops the SD Clock by clearing the SD_CLK_EN bit in the SYS_CTRL register.
Values:
0x0 (OFF): Power off
0x1 (ON): Power on</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_DAT_XFER</name>
              <description>Extended Data Transfer Width
This bit controls 8-bit bus width mode of embedded device.
Values:
0x1 (EIGHT_BIT): 8-bit Bus Width
0x0 (DEFAULT): Bus Width is selected by the Data Transfer Width</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_SEL</name>
              <description>DMA Select
This field is used to select the DMA type.
When Host Version 4 Enable is 1 in Host Control 2 register:
0x0 : SDMA is selected
0x1 : Reserved
0x2 : ADMA2 is selected
0x3 : ADMA2 or ADMA3 is selected
When Host Version 4 Enable is 0 in Host Control 2 register:
0x0 : SDMA is selected
0x1 : Reserved
0x2 : 32-bit Address ADMA2 is selected
0x3 : 64-bit Address ADMA2 is selected
Values:
0x0 (SDMA): SDMA is selected
0x1 (RSVD_BIT): Reserved
0x2 (ADMA2): ADMA2 is selected
0x3 (ADMA2_3): ADMA2 or ADMA3 is selected</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HIGH_SPEED_EN</name>
              <description>High Speed Enable
this bit is used to determine the selection of preset value for High Speed mode.
Before setting this bit, the Host Driver checks the High Speed Support in the Capabilities register.
Note: SDXC always outputs the sd_cmd_out and sd_dat_out lines at the rising edge of cclk_tx clock irrespective of this bit.
Values:
0x1 (HIGH_SPEED): High Speed mode
0x0 (NORMAL_SPEED): Normal Speed mode</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DAT_XFER_WIDTH</name>
              <description>Data Transfer Width
For SD/eMMC mode,this bit selects the data transfer width of the Host Controller.
The Host Driver sets it to match the data width of the SD/eMMC card. In UHS-II mode, this bit is irrelevant.
Values:
0x1 (FOUR_BIT): 4-bit mode
0x0 (ONE_BIT): 1-bit mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYS_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x070FFFEF</resetMask>
          <fields>
            <field>
              <name>SW_RST_DAT</name>
              <description>Software Reset For DAT line
This bit is used in SD/eMMC mode and it resets only a part of the data circuit and the DMA circuit is also reset.
The following registers and bits are cleared by this bit:
Buffer Data Port register
-Buffer is cleared and initialized.
Present state register
-Buffer Read Enable
-Buffer Write Enable
-Read Transfer Active
-Write Transfer Active
-DAT Line Active
-Command Inhibit (DAT)
Block Gap Control register
-Continue Request
-Stop At Block Gap Request
Normal Interrupt status register
-Buffer Read Ready
-Buffer Write Ready
-DMA Interrupt
-Block Gap Event
-Transfer Complete
In UHS-II mode, this bit shall be set to 0
Values:
0x0 (FALSE): Work
0x1 (TRUE): Reset</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST_CMD</name>
              <description>Software Reset For CMD line
This bit resets only a part of the command circuit to be able to issue a command.
It bit is also used to initialize a UHS-II command circuit.
This reset is effective only for a command issuing circuit (including response error statuses related to Command Inhibit (CMD) control) and does not affect the data transfer circuit.
Host Controller can continue data transfer even after this reset is executed while handling subcommand-response errors.
The following registers and bits are cleared by this bit:
Present State register : Command Inhibit (CMD) bit
Normal Interrupt Status register : Command Complete bit
Error Interrupt Status : Response error statuses related to Command Inhibit (CMD) bit
Values:
0x0 (FALSE): Work
0x1 (TRUE): Reset</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST_ALL</name>
              <description>Software Reset For All
This reset affects the entire Host Controller except for the card detection circuit.
During its initialization, the Host Driver sets this bit to 1 to reset the Host Controller.
All registers are reset except the capabilities register.
If this bit is set to 1, the Host Driver must issue reset command and reinitialize the card.
Values:
0x0 (FALSE): Work
0x1 (TRUE): Reset</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_CNT</name>
              <description>Data Timeout Counter Value.
This value determines the interval by which DAT line timeouts are detected.
The Timeout clock frequency is generated by dividing the base clock TMCLK value by this value.
When setting this register, prevent inadvertent timeout events by clearing the Data Timeout Error Status Enable (in the Error Interrupt Status Enable register).
The values for these bits are:
0xF : Reserved
0xE : TMCLK x 2^27
.........
0x1 : TMCLK x 2^14
0x0 : TMCLK x 2^13
Note: During a boot operating in an eMMC mode, an application must configure the boot data timeout value (approximately 1 sec) in this bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FREQ_SEL</name>
              <description>SDCLK/RCLK Frequency Select
These bits are used to select the frequency of the SDCLK signal.
These bits depend on setting of Preset Value Enable in the Host Control 2 register.
If Preset Value Enable = 0, these bits are set by the Host Driver.
If Preset Value Enable = 1, these bits are automatically set to a value specified in one of the Preset Value register.
The value is reflected on the lower 8-bit of the card_clk_freq_selsignal.
10-bit Divided Clock Mode:
0x3FF : 1/2046 Divided clock
..........
N : 1/2N Divided Clock
..........
0x002 : 1/4 Divided Clock
0x001 : 1/2 Divided Clock
0x000 : Base clock (10MHz - 255 MHz)
Programmable Clock Mode : Enables the Host System to select a fine grain SD clock frequency:
0x3FF : Base clock * M /1024
..........
N-1 : Base clock * M /N
..........
0x002 : Base clock * M /3
0x001 : Base clock * M /2
0x000 : Base clock * M</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPPER_FREQ_SEL</name>
              <description>These bits specify the upper 2 bits of 10-bit SDCLK/RCLK Frequency Select control.
The value is reflected on the upper 2 bits of the card_clk_freq_sel signal.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_GEN_SELECT</name>
              <description>Clock Generator Select
This bit is used to select the clock generator mode in SDCLK/RCLK Frequency Select.
If Preset Value Enable = 0, this bit is set by the Host Driver.
If Preset Value Enable = 1, this bit is automatically set to a value specified in one of the Preset Value registers.
The value is reflected on the card_clk_gen_sel signal.
Values:
0x0 (FALSE): Divided Clock Mode
0x1 (TRUE): Programmable Clock Mode</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_ENABLE</name>
              <description>PLL Enable
This bit is used to activate the PLL (applicable when Host Version 4 Enable = 1).
When Host Version 4 Enable = 0, INTERNAL_CLK_EN bit may be used to activate PLL. The value is reflected on the card_clk_en signal.
Note: If this bit is not used to to active the PLL when Host Version 4 Enable = 1, it is recommended to set this bit to '1' .
Values:
0x0 (FALSE): PLL is in low power mode
0x1 (TRUE): PLL is enabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SD_CLK_EN</name>
              <description>SD/eMMC Clock Enable
This bit stops the SDCLK or RCLK when set to 0.
The SDCLK/RCLK Frequency Select bit can be changed when this bit is set to 0.
The value is reflected on the clk2card_on pin.
Values:
0x0 (FALSE): Disable providing SDCLK/RCLK
0x1 (TRUE): Enable providing SDCLK/RCLK</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTERNAL_CLK_STABLE</name>
              <description>Internal Clock Stable
This bit enables the Host Driver to check the clock stability twice after the Internal Clock Enable bit is set and after the PLL Enable bit is set.
This bit reflects the synchronized value of the intclk_stable signal after the Internal Clock Enable bit is set to 1,
and also reflects the synchronized value of the card_clk_stable signal after the PLL Enable bit is set to 1.
Values:
0x0 (FALSE): Not Ready
0x1 (TRUE): Ready</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTERNAL_CLK_EN</name>
              <description>Internal Clock Enable
This bit is set to 0 when the Host Driver is not using the Host Controller or the Host Controller awaits a wakeup interrupt.
The Host Controller must stop its internal clock to enter a very low power state.
However, registers can still be read and written to. The value is reflected on the intclk_en signal.
Note: If this bit is not used to control the internal clock (base clock and master clock), it is recommended to set this bit to '1' .
Values:
0x0 (FALSE): Stop
0x1 (TRUE): Oscillate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STAT</name>
          <description>No description available</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFFF1FF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR</name>
              <description>Boot Acknowledgment Error
This bit is set when there is a timeout for boot acknowledgement or when detecting boot ack status having a value other than 010. This is applicable only when boot acknowledgement is expected in eMMC mode.
In SD/UHS-II mode, this bit is irrelevant.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_ERR</name>
              <description>Response Error
Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution.
If Response Error Check Enable is set to 1 in the Transfer Mode register, Host Controller Checks R1 or R5 response. If an error is detected in a response, this bit is set to 1.This is applicable in SD/eMMC mode.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TUNING_ERR</name>
              <description>Tuning Error
This bit is set when an unrecoverable error is detected in a tuning circuit except during the tuning procedure
(occurrence of an error during tuning procedure is indicated by Sampling Clock Select in the Host Control 2 register).
By detecting Tuning Error, Host Driver needs to abort a command executing and perform tuning.
To reset tuning circuit, Sampling Clock Select is set to 0 before executing tuning procedure.
The Tuning Error is higher priority than the other error interrupts generated during data transfer.
By detecting Tuning Error, the Host Driver must discard data transferred by a current read/write command and retry data transfer after the Host Controller retrieved from the tuning circuit error.
This is applicable in SD/eMMC mode.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMA_ERR</name>
              <description>ADMA Error
This bit is set when the Host Controller detects error during ADMA-based data transfer. The error could be due to following reasons:
Error response received from System bus (Master I/F)
ADMA3,ADMA2 Descriptors invalid
CQE Task or Transfer descriptors invalid
When the error occurs, the state of the ADMA is saved in the ADMA Error Status register.
In eMMC CQE mode:
The Host Controller generates this Interrupt when it detects an invalid descriptor data (Valid=0) at the ST_FDS state.
ADMA Error State in the ADMA Error Status indicates that an error has occurred in ST_FDS state.
The Host Driver may find that Valid bit is not set at the error descriptor.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CMD_ERR</name>
              <description>Auto CMD Error
This error status is used by Auto CMD12 and Auto CMD23 in SD/eMMC mode.
This bit is set when detecting that any of the bits D00 to D05 in Auto CMD Error Status register has changed from 0 to 1.
D07 is effective in case of Auto CMD12. Auto CMD Error Status register is valid while this bit is set to 1 and may be cleared by clearing of this bit.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CUR_LMT_ERR</name>
              <description>Current Limit Error
By setting the SD Bus Power bit in the Power Control register, the Host Controller is requested to supply power for the SD Bus.
If the Host Controller supports the Current Limit function, it can be protected from an illegal card by stopping power supply to the card in which case this bit indicates a failure status.
A reading of 1 for this bit means that the Host Controller is not supplying power to the SD card due to some failure.
A reading of 0 for this bit means that the Host Controller is supplying power and no error has occurred.
The Host Controller may require some sampling time to detect the current limit.
SDXC Host Controller does not support this function, this bit is always set to 0.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Power Fail</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_END_BIT_ERR</name>
              <description>Data End Bit Error
This error occurs in SD/eMMC mode either when detecting 0 at the end bit position of read data that uses the DAT line or at the end bit position of the CRC status.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_CRC_ERR</name>
              <description>Data CRC Error
This error occurs in SD/eMMC mode when detecting CRC error when transferring read data which uses the DAT line,
when detecting the Write CRC status having a value of other than 010 or when write CRC status timeout.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TOUT_ERR</name>
              <description>Data Timeout Error
This bit is set in SD/eMMC mode when detecting one of the following timeout conditions:
Busy timeout for R1b, R5b type
Busy timeout after Write CRC status
Write CRC Status timeout
Read Data timeout
Values:
0x0 (FALSE): No error
0x1 (TRUE): Time out</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_IDX_ERR</name>
              <description>Command Index Error
This bit is set if a Command Index error occurs in the command respons in SD/eMMC mode.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_END_BIT_ERR</name>
              <description>Command End Bit Error
This bit is set when detecting that the end bit of a command response is 0 in SD/eMMC mode.
Values:
0x0 (FALSE): No error
0x1 (TRUE): End Bit error generated</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_CRC_ERR</name>
              <description>Command CRC Error
Command CRC Error is generated in SD/eMMC mode for following two cases.
If a response is returned and the Command Timeout Error is set to 0 (indicating no timeout), this bit is set to 1 when detecting a CRC error in the command response.
The Host Controller detects a CMD line conflict by monitoring the CMD line when a command is issued.
If the Host Controller drives the CMD line to 1 level,
but detects 0 level on the CMD line at the next SD clock edge, then the Host Controller aborts the command (stop driving CMD line) and set this bit to 1.
The Command Timeout Error is also set to 1 to distinguish a CMD line conflict.
Values:
0x0 (FALSE): No error
0x1 (TRUE): CRC error generated</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_TOUT_ERR</name>
              <description>Command Timeout Error
In SD/eMMC Mode,this bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command.
If the Host Controller detects a CMD line conflict, along with Command CRC Error bit, this bit is set to 1, without waiting for 64 SD/eMMC card clock cycles.
Values:
0x0 (FALSE): No error
0x1 (TRUE): Time out</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INTERRUPT</name>
              <description>Error Interrupt
If any of the bits in the Error Interrupt Status register are set, then this bit is set.
Values:
0x0 (FALSE): No Error
0x1 (TRUE): Error</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CQE_EVENT</name>
              <description>Command Queuing Event
This status is set if Command Queuing/Crypto related event has occurred in eMMC/SD mode. Read CQHCI's CQIS/CRNQIS register for more details.
Values:
0x0 (FALSE): No Event
0x1 (TRUE): Command Queuing Event is detected</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FX_EVENT</name>
              <description>FX Event
This status is set when R[14] of response register is set to 1 and Response Type R1/R5 is set to 0 in Transfer Mode register. This interrupt is used with response check function.
Values:
0x0 (FALSE): No Event
0x1 (TRUE): FX Event is detected</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RE_TUNE_EVENT</name>
              <description>Re-tuning Event
This bit is set if the Re-Tuning Request changes from 0 to 1. Re-Tuning request is not supported.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_INTERRUPT</name>
              <description>Card Interrupt
This bit reflects the synchronized value of:
DAT[1] Interrupt Input for SD Mode
DAT[2] Interrupt Input for UHS-II Mode
Values:
0x0 (FALSE): No Card Interrupt
0x1 (TRUE): Generate Card Interrupt</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CARD_REMOVAL</name>
              <description>Card Removal
This bit is set if the Card Inserted in the Present State register changes from 1 to 0.
Values:
0x0 (FALSE): Card state stable or Debouncing
0x1 (TRUE): Card Removed</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INSERTION</name>
              <description>Card Insertion
This bit is set if the Card Inserted in the Present State register changes from 0 to 1.
Values:
0x0 (FALSE): Card state stable or Debouncing
0x1 (TRUE): Card Inserted</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_RD_READY</name>
              <description>Buffer Read Ready
This bit is set if the Buffer Read Enable changes from 0 to 1.
Values:
0x0 (FALSE): Not ready to read buffer
0x1 (TRUE): Ready to read buffer</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_WR_READY</name>
              <description>Buffer Write Ready
This bit is set if the Buffer Write Enable changes from 0 to 1.
Values:
0x0 (FALSE): Not ready to write buffer
0x1 (TRUE): Ready to write buffer</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_INTERRUPT</name>
              <description>DMA Interrupt
This bit is set if the Host Controller detects the SDMA Buffer Boundary during transfer.
In case of ADMA, by setting the Int field in the descriptor table, the Host controller generates this interrupt.
This interrupt is not generated after a Transfer Complete.
Values:
0x0 (FALSE): No DMA Interrupt
0x1 (TRUE): DMA Interrupt is generated</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BGAP_EVENT</name>
              <description>Block Gap Event
This bit is set when both read/write transaction is stopped at block gap due to a Stop at Block Gap Request.
Values:
0x0 (FALSE): No Block Gap Event
0x1 (TRUE): Transaction stopped at block gap</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XFER_COMPLETE</name>
              <description>Transfer Complete
This bit is set when a read/write transfer and a command with status busy is completed.
Values:
0x0 (FALSE): Not complete
0x1 (TRUE): Command execution is completed</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_COMPLETE</name>
              <description>Command Complete
In an SD/eMMC Mode, this bit is set when the end bit of a response except for Auto CMD12 and Auto CMD23.
This interrupt is not generated when the Response Interrupt Disable in Transfer Mode Register is set to 1.
Values:
0x0 (FALSE): No command complete
0x1 (TRUE): Command Complete</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STAT_EN</name>
          <description>No description available</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFF71FF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR_STAT_EN</name>
              <description>Boot Acknowledgment Error (eMMC Mode only)
Setting this bit to 1 enables setting of Boot Acknowledgment Error in Error Interrupt Status register (INT_STAT).
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_ERR_STAT_EN</name>
              <description>Response Error Status Enable (SD Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TUNING_ERR_STAT_EN</name>
              <description>Tuning Error Status Enable (UHS-I Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMA_ERR_STAT_EN</name>
              <description>ADMA Error Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CMD_ERR_STAT_EN</name>
              <description>Auto CMD Error Status Enable (SD/eMMC Mode only).
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CUR_LMT_ERR_STAT_EN</name>
              <description>Current Limit Error Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_END_BIT_ERR_STAT_EN</name>
              <description>Data End Bit Error Status Enable (SD/eMMC Mode only).
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_CRC_ERR_STAT_EN</name>
              <description>Data CRC Error Status Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TOUT_ERR_STAT_EN</name>
              <description>Data Timeout Error Status Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_IDX_ERR_STAT_EN</name>
              <description>Command Index Error Status Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_END_BIT_ERR_STAT_EN</name>
              <description>Command End Bit Error Status Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_CRC_ERR_STAT_EN</name>
              <description>Command CRC Error Status Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_TOUT_ERR_STAT_EN</name>
              <description>Command Timeout Error Status Enable (SD/eMMC Mode only).
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CQE_EVENT_STAT_EN</name>
              <description>CQE Event Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FX_EVENT_STAT_EN</name>
              <description>FX Event Status Enable
This bit is added from Version 4.10.
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RE_TUNE_EVENT_STAT_EN</name>
              <description>Re-Tuning Event (UHS-I only) Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INTERRUPT_STAT_EN</name>
              <description>Card Interrupt Status Enable
If this bit is set to 0, the Host Controller clears the interrupt request to the System.
The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1.
The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
By setting this bit to 0, interrupt input must be masked by implementation so that the interrupt input is not affected by external signal in any state (for example, floating).
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_REMOVAL_STAT_EN</name>
              <description>Card Removal Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INSERTION_STAT_EN</name>
              <description>Card Insertion Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_RD_READY_STAT_EN</name>
              <description>Buffer Read Ready Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_WR_READY_STAT_EN</name>
              <description>Buffer Write Ready Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_INTERRUPT_STAT_EN</name>
              <description>DMA Interrupt Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BGAP_EVENT_STAT_EN</name>
              <description>Block Gap Event Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XFER_COMPLETE_STAT_EN</name>
              <description>Transfer Complete Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_COMPLETE_STAT_EN</name>
              <description>Command Complete Status Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SIGNAL_EN</name>
          <description>No description available</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFF71FF</resetMask>
          <fields>
            <field>
              <name>BOOT_ACK_ERR_SIGNAL_EN</name>
              <description>Boot Acknowledgment Error (eMMC Mode only).
Setting this bit to 1 enables generating interrupt signal when Boot Acknowledgment Error in Error Interrupt Status register is set.
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RESP_ERR_SIGNAL_EN</name>
              <description>Response Error Signal Enable (SD Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TUNING_ERR_SIGNAL_EN</name>
              <description>Tuning Error Signal Enable (UHS-I Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMA_ERR_SIGNAL_EN</name>
              <description>ADMA Error Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CMD_ERR_SIGNAL_EN</name>
              <description>Auto CMD Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CUR_LMT_ERR_SIGNAL_EN</name>
              <description>Current Limit Error Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_END_BIT_ERR_SIGNAL_EN</name>
              <description>Data End Bit Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_CRC_ERR_SIGNAL_EN</name>
              <description>Data CRC Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TOUT_ERR_SIGNAL_EN</name>
              <description>Data Timeout Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_IDX_ERR_SIGNAL_EN</name>
              <description>Command Index Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): No error
0x1 (TRUE): Error</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_END_BIT_ERR_SIGNAL_EN</name>
              <description>Command End Bit Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_CRC_ERR_SIGNAL_EN</name>
              <description>Command CRC Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_TOUT_ERR_SIGNAL_EN</name>
              <description>Command Timeout Error Signal Enable (SD/eMMC Mode only)
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CQE_EVENT_SIGNAL_EN</name>
              <description>Command Queuing Engine Event Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FX_EVENT_SIGNAL_EN</name>
              <description>FX Event Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RE_TUNE_EVENT_SIGNAL_EN</name>
              <description>Re-Tuning Event (UHS-I only) Signal Enable.
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INTERRUPT_SIGNAL_EN</name>
              <description>Card Interrupt Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_REMOVAL_SIGNAL_EN</name>
              <description>Card Removal Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_INSERTION_SIGNAL_EN</name>
              <description>Card Insertion Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_RD_READY_SIGNAL_EN</name>
              <description>Buffer Read Ready Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_WR_READY_SIGNAL_EN</name>
              <description>Buffer Write Ready Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_INTERRUPT_SIGNAL_EN</name>
              <description>DMA Interrupt Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BGAP_EVENT_SIGNAL_EN</name>
              <description>Block Gap Event Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XFER_COMPLETE_SIGNAL_EN</name>
              <description>Transfer Complete Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_COMPLETE_SIGNAL_EN</name>
              <description>Command Complete Signal Enable
Values:
0x0 (FALSE): Masked
0x1 (TRUE): Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AC_HOST_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xDCCF00BF</resetMask>
          <fields>
            <field>
              <name>PRESET_VAL_ENABLE</name>
              <description>Preset Value Enable
This bit enables automatic selection of SDCLK frequency and Driver strength Preset Value registers.
When Preset Value Enable is set, SDCLK frequency generation (Frequency Select and Clock Generator Select) and the driver strength selection are performed by the controller.
These values are selected from set of Preset Value registers based on selected speed mode.
Values:
0x0 (FALSE): SDCLK and Driver Strength are controlled by Host Driver
0x1 (TRUE): Automatic Selection by Preset Value are Enabled</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNC_INT_ENABLE</name>
              <description>Asynchronous Interrupt Enable
This bit can be set if a card supports asynchronous interrupts and Asynchronous Interrupt Support is set to 1 in the Capabilities register.
Values:
0x0 (FALSE): Disabled
0x1 (TRUE): Enabled</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HOST_VER4_ENABLE</name>
              <description>Host Version 4 Enable
This bit selects either Version 3.00 compatible mode or Version 4 mode.
Functions of following fields are modified for Host Version 4 mode:
SDMA Address: SDMA uses ADMA System Address (05Fh-058h) instead of SDMA System Address register (003h-000h)
ADMA2/ADMA3 selection: ADMA3 is selected by DMA select in Host Control 1 register
64-bit ADMA Descriptor Size: 128-bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 1
Selection of 32-bit/64-bit System Addressing: Either 32-bit or 64-bit system addressing is selected by 64-bit Addressing bit in this register
32-bit Block Count: SDMA System Address register (003h-000h) is modified to 32-bit Block Count register
Note: It is recommended not to program ADMA3 Integrated Descriptor Address registers,
UHS-II registers and Command Queuing registers (if applicable) while operating in Host version less than 4 mode (Host Version 4 Enable = 0).
Values:
0x0 (FALSE): Version 3.00 compatible mode
0x1 (TRUE): Version 4 mode</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD23_ENABLE</name>
              <description>CMD23 Enable
If the card supports CMD23, this bit is set to 1. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 data transfer.
Values:
0x0 (FALSE): Auto CMD23 is disabled
0x1 (TRUE): Auto CMD23 is enabled</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMA2_LEN_MODE</name>
              <description>ADMA2 Length Mode
This bit selects ADMA2 Length mode to be either 16-bit or 26-bit.
Values:
0x0 (FALSE): 16-bit Data Length Mode
0x1 (TRUE): 26-bit Data Length Mode</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_CLK_SEL</name>
              <description>Sampling Clock Select
This bit is used by the Host Controller to select the sampling clock in SD/eMMC mode to receive CMD and DAT.
This bit is set by the tuning procedure and is valid after the completion of tuning (when Execute Tuning is cleared).
Setting this bit to 1 means that tuning is completed successfully and setting this bit to 0 means that tuning has failed.
The value is reflected on the sample_cclk_sel pin.
Values:
0x0 (FALSE): Fixed clock is used to sample data
0x1 (TRUE): Tuned clock is used to sample data</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EXEC_TUNING</name>
              <description>Execute Tuning
This bit is set to 1 to start the tuning procedure in UHS-I/eMMC speed modes and this bit is automatically cleared when tuning procedure is completed.
Values:
0x0 (FALSE): Not Tuned or Tuning completed
0x1 (TRUE): Execute Tuning</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIGNALING_EN</name>
              <description>1.8V Signaling Enable
This bit controls voltage regulator for I/O cell in UHS-I/eMMC speed modes.
Setting this bit from 0 to 1 starts changing the signal voltage from 3.3V to 1.8V.
Host Controller clears this bit if switching to 1.8 signaling fails. The value is reflected on the uhs1_swvolt_en pin.
Note: This bit must be set for all UHS-I speed modes (SDR12/SDR25/SDR50/SDR104/DDR50).
Values:
0x0 (V_3_3): 3.3V Signalling
0x1 (V_1_8): 1.8V Signalling</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UHS_MODE_SEL</name>
              <description>UHS Mode/eMMC Speed Mode Select
These bits are used to select UHS mode in the SD mode of operation. In eMMC mode, these bits are used to select eMMC Speed mode.
UHS Mode (SD/UHS-II mode only):
0x0 (SDR12): SDR12/Legacy
0x1 (SDR25): SDR25/High Speed SDR
0x2 (SDR50): SDR50
0x3 (SDR104): SDR104/HS200
0x4 (DDR50): DDR50/High Speed DDR
0x5 (RSVD5): Reserved
0x6 (RSVD6): Reserved
0x7 (UHS2): UHS-II/HS400
eMMC Speed Mode (eMMC mode only):
0x0: Legacy
0x1: High Speed SDR
0x2: Reserved
0x3: HS200
0x4: High Speed DDR
0x5: Reserved
0x6: Reserved
0x7: HS400</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_NOT_ISSUED_AUTO_CMD12</name>
              <description>Command Not Issued By Auto CMD12 Error
If this bit is set to 1, CMD_wo_DAT is not executed due to an Auto CMD12 Error (D04-D01) in this register.
This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.
Values:
0x1 (TRUE): Not Issued
0x0 (FALSE): No Error</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_CMD_RESP_ERR</name>
              <description>Auto CMD Response Error
This bit is set when Response Error Check Enable in the Transfer Mode register is set to 1 and an error is detected in R1 response of either Auto CMD12 or CMD13.
This status is ignored if any bit between D00 to D04 is set to 1.
Values:
0x1 (TRUE): Error
0x0 (FALSE): No Error</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_CMD_IDX_ERR</name>
              <description>Auto CMD Index Error
This bit is set if the command index error occurs in response to a command.
Values:
0x1 (TRUE): Error
0x0 (FALSE): No Error</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_CMD_EBIT_ERR</name>
              <description>Auto CMD End Bit Error
This bit is set when detecting that the end bit of command response is 0.
Values:
0x1 (TRUE): End Bit Error Generated
0x0 (FALSE): No Error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_CMD_CRC_ERR</name>
              <description>Auto CMD CRC Error
This bit is set when detecting a CRC error in the command response.
Values:
0x1 (TRUE): CRC Error Generated
0x0 (FALSE): No Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_CMD_TOUT_ERR</name>
              <description>Auto CMD Timeout Error
This bit is set if no response is returned with 64 SDCLK cycles from the end bit of the command.
If this bit is set to 1, error status bits (D04-D01) are meaningless.
Values:
0x1 (TRUE): Time out
0x0 (FALSE): No Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AUTO_CMD12_NOT_EXEC</name>
              <description>Auto CMD12 Not Executed
If multiple memory block data transfer is not started due to a command error, this bit is not set because it is not necessary to issue an Auto CMD12.
Setting this bit to 1 means that the Host Controller cannot issue Auto CMD12 to stop multiple memory block data transfer, due to some error.
 If this bit is set to 1, error status bits (D04-D01) is meaningless.
This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.
Values:
0x1 (TRUE): Not Executed
0x0 (FALSE): Executed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAPABILITIES1</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xE7EFFFBF</resetMask>
          <fields>
            <field>
              <name>SLOT_TYPE_R</name>
              <description>Slot Type
These bits indicate usage of a slot by a specific Host System.
Values:
0x0 (REMOVABLE_SLOT): Removable Card Slot
0x1 (EMBEDDED_SLOT): Embedded Slot for one Device
0x2 (SHARED_SLOT): Shared Bus Slot (SD mode)
0x3 (UHS2_EMBEDDED_SLOT): UHS-II Multiple Embedded Devices</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ASYNC_INT_SUPPORT</name>
              <description>Asynchronous Interrupt Support (SD Mode only)
Values:
0x0 (FALSE): Asynchronous Interrupt Not Supported
0x1 (TRUE): Asynchronous Interrupt Supported</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VOLT_18</name>
              <description>Voltage Support for 1.8V
Values:
0x0 (FALSE): 1.8V Not Supported
0x1 (TRUE): 1.8V Supported</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VOLT_30</name>
              <description>Voltage Support for SD 3.0V or Embedded 1.2V
Values:
0x0 (FALSE): SD 3.0V or Embedded 1.2V Not Supported
0x1 (TRUE): SD 3.0V or Embedded Supported</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VOLT_33</name>
              <description>Voltage Support for 3.3V
Values:
0x0 (FALSE): 3.3V Not Supported
0x1 (TRUE): 3.3V Supported</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SUS_RES_SUPPORT</name>
              <description>Suspense/Resume Support
This bit indicates whether the Host Controller supports Suspend/Resume functionality.
If this bit is 0, the Host Driver does not issue either Suspend or Resume commands because the Suspend and Resume mechanism is not supported.
Values:
0x0 (FALSE): Not Supported
0x1 (TRUE): Supported</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SDMA_SUPPORT</name>
              <description>SDMA Support
This bit indicates whether the Host Controller is capable of using SDMA to transfer data between the system memory and the Host Controller directly.
Values:
0x0 (FALSE): SDMA not Supported
0x1 (TRUE): SDMA Supported</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HIGH_SPEED_SUPPORT</name>
              <description>High Speed Support
This bit indicates whether the Host Controller and the Host System supports High Speed mode and they can supply the SD Clock frequency from 25 MHz to 50 MHz.
Values:
0x0 (FALSE): High Speed not Supported
0x1 (TRUE): High Speed Supported</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADMA2_SUPPORT</name>
              <description>ADMA2 Support
This bit indicates whether the Host Controller is capable of using ADMA2.
Values:
0x0 (FALSE): ADMA2 not Supported
0x1 (TRUE): ADMA2 Supported</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMBEDDED_8_BIT</name>
              <description>8-bit Support for Embedded Device
This bit indicates whether the Host Controller is capable of using an 8-bit bus width mode. This bit is not effective when the Slot Type is set to 10b.
Values:
0x0 (FALSE): 8-bit Bus Width not Supported
0x1 (TRUE): 8-bit Bus Width Supported</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_BLK_LEN</name>
              <description>Maximum Block Length
This bit indicates the maximum block size that the Host driver can read and write to the buffer in the Host Controller.
The buffer transfers this block size without wait cycles. The transfer block length is always 512 bytes for the SD Memory irrespective of this bit
Values:
0x0 (ZERO): 512 Byte
0x1 (ONE): 1024 Byte
0x2 (TWO): 2048 Byte
0x3 (THREE): Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_CLK_FREQ</name>
              <description>Base Clock Frequency for SD clock
These bits indicate the base (maximum) clock frequency for the SD Clock. The definition of these bits depend on the Host Controller Version.
6-Bit Base Clock Frequency: This mode is supported by the Host Controller version 1.00 and 2.00.
The upper 2 bits are not effective and are always 0. The unit values are 1 MHz. The supported clock range is 10 MHz to 63 MHz.
-0x00 : Get information through another method
-0x01 : 1 MHz
-0x02 : 2 MHz
-.............
-0x3F : 63 MHz
-0x40-0xFF : Not Supported
8-Bit Base Clock Frequency: This mode is supported by the Host Controller version 3.00. The unit values are 1 MHz. The supported clock range is 10 MHz to 255 MHz.
-0x00 : Get information through another method
-0x01 : 1 MHz
-0x02 : 2 MHz
-............
-0xFF : 255 MHz
If the frequency is 16.5 MHz, the larger value is set to 0001001b (17 MHz) because the Host Driver uses this value to calculate the clock divider value and it does not exceed the upper limit of the SD Clock frequency.
If these bits are all 0, the Host system has to get information using a different method.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_CLK_UNIT</name>
              <description>Timeout Clock Unit
This bit shows the unit of base clock frequency used to detect Data TImeout Error.
Values:
0x0 (KHZ): KHz
0x1 (MHZ): MHz</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_CLK_FREQ</name>
              <description>Timeout Clock Frequency
This bit shows the base clock frequency used to detect Data Timeout Error. The Timeout Clock unit defines the unit of timeout clock frequency. It can be KHz or MHz.
0x00 : Get information through another method
0x01 : 1KHz / 1MHz
0x02 : 2KHz / 2MHz
0x03 : 3KHz / 3MHz
 ...........
0x3F : 63KHz / 63MHz</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAPABILITIES2</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x18FFEF7F</resetMask>
          <fields>
            <field>
              <name>VDD2_18V_SUPPORT</name>
              <description>1.8V VDD2 Support
This bit indicates support of VDD2 for the Host System.
0x0 (FALSE): 1.8V VDD2 is not Supported
0x1 (TRUE): 1.8V VDD2 is Supported</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADMA3_SUPPORT</name>
              <description>ADMA3 Support
This bit indicates whether the Host Controller is capable of using ADMA3.
Values:
0x0 (FALSE): ADMA3 not Supported
0x1 (TRUE): ADMA3 Supported</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_MUL</name>
              <description>Clock Multiplier
These bits indicate the clock multiplier of the programmable clock generator. Setting these bits to 0 means that the Host Controller does not support a programmable clock generator.
0x0: Clock Multiplier is not Supported
0x1: Clock Multiplier M = 2
0x2: Clock Multiplier M = 3
 .........
0xFF: Clock Multiplier M = 256</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RE_TUNING_MODES</name>
              <description>Re-Tuning Modes (UHS-I only)
These bits select the re-tuning method and limit the maximum data length.
Values:
0x0 (MODE1): Timer
0x1 (MODE2): Timer and Re-Tuning Request (Not supported)
0x2 (MODE3): Auto Re-Tuning (for transfer)
0x3 (RSVD_MODE): Reserved</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>USE_TUNING_SDR50</name>
              <description>Use Tuning for SDR50 (UHS-I only)
Values:
0x0 (ZERO): SDR50 does not require tuning
0x1 (ONE): SDR50 requires tuning</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RETUNE_CNT</name>
              <description>Timer Count for Re-Tuning (UHS-I only)
0x0: Re-Tuning Timer disabled
0x1: 1 seconds
0x2: 2 seconds
0x3: 4 seconds
 ........
0xB: 1024 seconds
0xC: Reserved
0xD: Reserved
0xE: Reserved
0xF: Get information from other source</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DRV_TYPED</name>
              <description>Driver Type D Support (UHS-I only)
This bit indicates support of Driver Type D for 1.8 Signaling.
Values:
0x0 (FALSE): Driver Type D is not supported
0x1 (TRUE): Driver Type D is supported</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DRV_TYPEC</name>
              <description>Driver Type C Support (UHS-I only)
This bit indicates support of Driver Type C for 1.8 Signaling.
Values:
0x0 (FALSE): Driver Type C is not supported
0x1 (TRUE): Driver Type C is supported</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DRV_TYPEA</name>
              <description>Driver Type A Support (UHS-I only)
This bit indicates support of Driver Type A for 1.8 Signaling.
Values:
0x0 (FALSE): Driver Type A is not supported
0x1 (TRUE): Driver Type A is supported</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UHS2_SUPPORT</name>
              <description>UHS-II Support (UHS-II only)
This bit indicates whether Host Controller supports UHS-II.
Values:
0x0 (FALSE): UHS-II is not supported
0x1 (TRUE): UHS-II is supported</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DDR50_SUPPORT</name>
              <description>DDR50 Support (UHS-I only)
Values:
0x0 (FALSE): DDR50 is not supported
0x1 (TRUE): DDR50 is supported</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SDR104_SUPPORT</name>
              <description>SDR104 Support (UHS-I only)
This bit mentions that SDR104 requires tuning.
Values:
0x0 (FALSE): SDR104 is not supported
0x1 (TRUE): SDR104 is supported</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SDR50_SUPPORT</name>
              <description>SDR50 Support (UHS-I only)
This bit indicates that SDR50 is supported. The bit 13 (USE_TUNING_SDR50) indicates whether SDR50 requires tuning or not.
Values:
0x0 (FALSE): SDR50 is not supported
0x1 (TRUE): SDR50 is supported</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CURR_CAPABILITIES1</name>
          <description>No description available</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>MAX_CUR_18V</name>
              <description>Maximum Current for 1.8V
This bit specifies the Maximum Current for 1.8V VDD1 power supply for the card.
0: Get information through another method
1: 4mA
2: 8mA
3: 13mA
.......
255: 1020mA</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_CUR_30V</name>
              <description>Maximum Current for 3.0V
This bit specifies the Maximum Current for 3.0V VDD1 power supply for the card.
0: Get information through another method
1: 4mA
2: 8mA
3: 13mA
.......
255: 1020mA</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MAX_CUR_33V</name>
              <description>Maximum Current for 3.3V
This bit specifies the Maximum Current for 3.3V VDD1 power supply for the card.
0: Get information through another method
1: 4mA
2: 8mA
3: 13mA
.......
255: 1020mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CURR_CAPABILITIES2</name>
          <description>No description available</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>MAX_CUR_VDD2_18V</name>
              <description>Maximum Current for 1.8V VDD2
This bit specifies the Maximum Current for 1.8V VDD2 power supply for the UHS-II card.
0: Get information through another method
1: 4mA
2: 8mA
3: 13mA
.......
255: 1020mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FORCE_EVENT</name>
          <description>No description available</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1FFF00BF</resetMask>
          <fields>
            <field>
              <name>FORCE_BOOT_ACK_ERR</name>
              <description>Force Event for Boot Ack error
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Boot ack Error Status is set</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_RESP_ERR</name>
              <description>Force Event for Response Error (SD Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Response Error Status is set</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_TUNING_ERR</name>
              <description>Force Event for Tuning Error (UHS-I Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Tuning Error Status is set</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_ADMA_ERR</name>
              <description>Force Event for ADMA Error
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): ADMA Error Status is set</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_ERR</name>
              <description>Force Event for Auto CMD Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Auto CMD Error Status is set</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_CUR_LMT_ERR</name>
              <description>Force Event for Current Limit Error
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Current Limit Error Status is set</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_DATA_END_BIT_ERR</name>
              <description>Force Event for Data End Bit Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Data End Bit Error Status is set</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_DATA_CRC_ERR</name>
              <description>Force Event for Data CRC Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Data CRC Error Status is set</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_DATA_TOUT_ERR</name>
              <description>Force Event for Data Timeout Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Data Timeout Error Status is set</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_CMD_IDX_ERR</name>
              <description>Force Event for Command Index Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command Index Error Status is set</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_CMD_END_BIT_ERR</name>
              <description>Force Event for Command End Bit Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command End Bit Error Status is set</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_CMD_CRC_ERR</name>
              <description>Force Event for Command CRC Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command CRC Error Status is set</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_CMD_TOUT_ERR</name>
              <description>Force Event for Command Timeout Error (SD/eMMC Mode only)
Values:
0x0 (FALSE): Not Affected
0x1 (TRUE): Command Timeout Error Status is set</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</name>
              <description>Force Event for Command Not Issued By Auto CMD12 Error
Values:
0x1 (TRUE): Command Not Issued By Auto CMD12 Error Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_RESP_ERR</name>
              <description>Force Event for Auto CMD Response Error
Values:
0x1 (TRUE): Auto CMD Response Error Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_IDX_ERR</name>
              <description>Force Event for Auto CMD Index Error
Values:
0x1 (TRUE): Auto CMD Index Error Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_EBIT_ERR</name>
              <description>Force Event for Auto CMD End Bit Error
Values:
0x1 (TRUE): Auto CMD End Bit Error Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_CRC_ERR</name>
              <description>Force Event for Auto CMD CRC Error
Values:
0x1 (TRUE): Auto CMD CRC Error Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD_TOUT_ERR</name>
              <description>Force Event for Auto CMD Timeout Error
Values:
0x1 (TRUE): Auto CMD Timeout Error Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCE_AUTO_CMD12_NOT_EXEC</name>
              <description>Force Event for Auto CMD12 Not Executed
Values:
0x1 (TRUE): Auto CMD12 Not Executed Status is set
0x0 (FALSE): Not Affected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADMA_ERR_STAT</name>
          <description>No description available</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>ADMA_LEN_ERR</name>
              <description>ADMA Length Mismatch Error States
This error occurs in the following instances:
While the Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length
When the total data length cannot be divided by the block length
Values:
0x0 (NO_ERR): No Error
0x1 (ERROR): Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ADMA_ERR_STATES</name>
              <description>ADMA Error States
These bits indicate the state of ADMA when an error occurs during ADMA data transfer.
Values:
0x0 (ST_STOP): Stop DMA - SYS_ADR register points to a location next to the error descriptor
0x1 (ST_FDS): Fetch Descriptor - SYS_ADR register points to the error descriptor
0x2 (UNUSED): Never set this state
0x3 (ST_TFR): Transfer Data - SYS_ADR register points to a location next to the error descriptor</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADMA_SYS_ADDR</name>
          <description>No description available</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMA_SA</name>
              <description>ADMA System Address
These bits indicate the lower 32 bits of the ADMA system address.
SDMA: If Host Version 4 Enable is set to 1, this register stores the system address of the data location
ADMA2: This register stores the byte address of the executing command of the descriptor table
ADMA3: This register is set by ADMA3. ADMA2 increments the address of this register that points to the next line, every time a Descriptor line is fetched.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>9</dim>
          <dimIncrement>0x2</dimIncrement>
          <dimIndex>INIT,DS,HS,SDR12,SDR25,SDR50,SDR104,DDR50,rsv8,rsv9,UHS2</dimIndex>
          <name>PRESET[%s]</name>
          <description>no description available</description>
          <addressOffset>0x60</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x07FF</resetMask>
          <fields>
            <field>
              <name>CLK_GEN_SEL_VAL</name>
              <description>Clock Generator Select Value
This bit is effective when the Host Controller supports a programmable clock generator.
Values:
0x0 (FALSE): Host Controller Ver2.0 Compatible Clock Generator
0x1 (PROG): Programmable Clock Generator</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FREQ_SEL_VAL</name>
              <description>SDCLK/RCLK Frequency Select Value
10-bit preset value to be set in SDCLK/RCLK Frequency Select field of the Clock Control register described by a Host System.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADMA_ID_ADDR</name>
          <description>No description available</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADMA_ID_ADDR</name>
              <description>ADMA Integrated Descriptor Address
These bits indicate the lower 32-bit of the ADMA Integrated Descriptor address.
The start address of Integrated Descriptor is set to these register bits.
The ADMA3 fetches one Descriptor Address and increments these bits to indicate the next Descriptor address.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>P_EMBEDDED_CNTRL</name>
          <description>No description available</description>
          <addressOffset>0xe6</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x0FFF</resetMask>
          <fields>
            <field>
              <name>REG_OFFSET_ADDR</name>
              <description>Offset Address of Embedded Control register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>P_VENDOR_SPECIFIC_AREA</name>
          <description>No description available</description>
          <addressOffset>0xe8</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x0FFF</resetMask>
          <fields>
            <field>
              <name>REG_OFFSET_ADDR</name>
              <description>Base offset Address for Vendor-Specific registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>P_VENDOR2_SPECIFIC_AREA</name>
          <description>No description available</description>
          <addressOffset>0xea</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>REG_OFFSET_ADDR</name>
              <description>Base offset Address for Command Queuing registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOT_INTR_STATUS</name>
          <description>No description available</description>
          <addressOffset>0xfc</addressOffset>
          <size>16</size>
          <resetValue>0x0000</resetValue>
          <resetMask>0x00FF</resetMask>
          <fields>
            <field>
              <name>INTR_SLOT</name>
              <description>Interrupt signal for each Slot
These status bits indicate the logical OR of Interrupt signal and Wakeup signal for each slot.
A maximum of 8 slots can be defined. If one interrupt signal is associated with multiple slots, the Host Driver can identify the interrupt that is generated by reading these bits.
 By a power on reset or by setting Software Reset For All bit, the interrupt signals are de-asserted and this status reads 00h.
Bit 00: Slot 1
Bit 01: Slot 2
Bit 02: Slot 3
..........
..........
Bit 07: Slot 8
Note: MSHC Host Controller support single card slot. This register shall always return 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQVER</name>
          <description>No description available</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>EMMC_VER_MAHOR</name>
              <description>This bit indicates the eMMC major version (1st digit left of decimal point) in BCD format.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMMC_VER_MINOR</name>
              <description>This bit indicates the eMMC minor version (1st digit right of decimal point) in BCD format.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EMMC_VER_SUFFIX</name>
              <description>This bit indicates the eMMC version suffix (2nd digit right of decimal point) in BCD format.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQCAP</name>
          <description>No description available</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1000F3FF</resetMask>
          <fields>
            <field>
              <name>CRYPTO_SUPPORT</name>
              <description>Crypto Support
This bit indicates whether the Host Controller supports cryptographic operations.
Values:
0x0 (FALSE): Crypto not Supported
0x1 (TRUE): Crypto Supported</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITCFMUL</name>
              <description>Internal Timer Clock Frequency Multiplier (ITCFMUL)
This field indicates the frequency of the clock used for interrupt coalescing timer and for determining the SQS
polling period. See ITCFVAL definition for details. Values 0x5 to 0xF are reserved.
Values:
0x0 (CLK_1KHz): 1KHz clock
0x1 (CLK_10KHz): 10KHz clock
0x2 (CLK_100KHz): 100KHz clock
0x3 (CLK_1MHz): 1MHz clock
0x4 (CLK_10MHz): 10MHz clock</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ITCFVAL</name>
              <description>Internal Timer Clock Frequency Value (ITCFVAL)
This field scales the frequency of the timer clock provided by ITCFMUL. The Final clock frequency of actual timer clock is calculated as ITCFVAL* ITCFMUL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQCFG</name>
          <description>No description available</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001101</resetMask>
          <fields>
            <field>
              <name>DCMD_EN</name>
              <description>This bit indicates to the hardware whether the Task
Descriptor in slot #31 of the TDL is a data transfer descriptor or a direct-command descriptor. CQE uses this bit when a task is issued in slot #31, to determine how to decode the Task Descriptor.
Values:
0x1 (SLOT31_DCMD_ENABLE): Task descriptor in slot #31 is a DCMD Task Descriptor
0x0 (SLOT31_DCMD_DISABLE): Task descriptor in slot #31 is a data Transfer Task Descriptor</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TASK_DESC_SIZE</name>
              <description>Bit Value Description
This bit indicates the size of task descriptor used in host memory. This bit can only be configured when Command Queuing Enable bit is 0 (command queuing is disabled).
Values:
0x1 (TASK_DESC_128b): Task descriptor size is 128 bits
0x0 (TASK_DESC_64b): Task descriptor size is 64 bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CQ_EN</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQCTL</name>
          <description>No description available</description>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000101</resetMask>
          <fields>
            <field>
              <name>CLR_ALL_TASKS</name>
              <description>Clear all tasks
This bit can only be written when the controller is halted. This bit does not clear tasks in the device. The software has to use the CMDQ_TASK_MGMT command to clear device's queue.
Values:
0x1 (CLEAR_ALL_TASKS): Clears all the tasks in the controller
0x0 (NO_EFFECT): Programming 0 has no effect</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HALT</name>
              <description>Halt request and resume
Values:
0x1 (HALT_CQE): Software writes 1 to this bit when it wants to acquire software control over the eMMC bus and to disable CQE from issuing command on the bus.
For example, issuing a Discard Task command (CMDQ_TASK_MGMT).
When the software writes 1, CQE completes the ongoing task (if any in progress).
After the task is completed and the CQE is in idle state, CQE does not issue new commands and indicates to the software by setting this bit to 1.
The software can poll on this bit until it is set to 1 and only then send  commands on the eMMC bus.
0x0 (RESUME_CQE): Software writes 0 to this bit to exit from the halt state and resume CQE activity</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQIS</name>
          <description>No description available</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>TCL</name>
              <description>Task cleared interrupt
This status bit is asserted (if CQISE.TCL_STE=1) when a task clear operation is completed by CQE.
The completed task clear operation is either an individual task clear (by writing CQTCLR) or clearing of all tasks (by writing CQCTL).
A value of 1 clears this status bit.
Values:
0x1 (SET): TCL Interrupt is set
0x0 (NOTSET): TCL Interrupt is not set</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RED</name>
              <description>Response error detected interrupt
This status bit is asserted (if CQISE.RED_STE=1) when a response is received with an error bit set in the device status
field. Configure the CQRMEM register to identify device status bit fields that may trigger an interrupt and that are masked.
A value of 1 clears this status bit.
Values:
0x1 (SET): RED Interrupt is set
0x0 (NOTSET): RED Interrupt is not set</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCC</name>
              <description>Task complete interrupt
This status bit is asserted (if CQISE.TCC_STE=1) when at least one of the following conditions are met:
A task is completed and the INT bit is set in its Task Descriptor
Interrupt caused by Interrupt Coalescing logic due to timeout
Interrupt Coalescing logic reached the configured threshold
A value of 1 clears this status bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HAC</name>
              <description>Halt complete interrupt
This status bit is asserted (only if CQISE.HAC_STE=1) when halt bit in the CQCTL register transitions from 0 to 1 indicating that  the host controller has completed its current ongoing task and has entered halt state.
A value of 1 clears this status bit.
Values:
0x1 (SET): HAC Interrupt is set
0x0 (NOTSET): HAC Interrupt is not set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQISE</name>
          <description>No description available</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>TCL_STE</name>
              <description>Task cleared interrupt status enable
Values:
0x1 (INT_STS_ENABLE): CQIS.TCL is set when its interrupt condition is active
0x0 (INT_STS_DISABLE): CQIS.TCL is disabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RED_STE</name>
              <description>Response error detected interrupt status enable
Values:
0x1 (INT_STS_ENABLE): CQIS.RED is set when its interrupt condition is active
0x0 (INT_STS_DISABLE): CQIS.RED is disabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCC_STE</name>
              <description>Task complete interrupt status enable
Values:
0x1 (INT_STS_ENABLE): CQIS.TCC is set when its interrupt condition is active
0x0 (INT_STS_DISABLE): CQIS.TCC is disabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HAC_STE</name>
              <description>Halt complete interrupt status enable
Values:
0x1 (INT_STS_ENABLE): CQIS.HAC is set when its interrupt condition is active
0x0 (INT_STS_DISABLE): CQIS.HAC is disabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQISGE</name>
          <description>No description available</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>TCL_SGE</name>
              <description>Task cleared interrupt signal enable
Values:
0x1 (INT_SIG_ENABLE): CQIS.TCL interrupt signal generation is active
0x0 (INT_SIG_DISABLE): CQIS.TCL interrupt signal generation is disabled</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RED_SGE</name>
              <description>Response error detected interrupt signal enable
Values:
0x1 (INT_SIG_ENABLE): CQIS.RED interrupt signal generation is active
0x0 (INT_SIG_DISABLE): CQIS.RED interrupt signal generation is disabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCC_SGE</name>
              <description>Task complete interrupt signal enable
Values:
0x1 (INT_SIG_ENABLE): CQIS.TCC interrupt signal generation is active
0x0 (INT_SIG_DISABLE): CQIS.TCC interrupt signal generation is disabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HAC_SGE</name>
              <description>Halt complete interrupt signal enable
Values:
0x1 (INT_SIG_ENABLE): CQIS.HAC interrupt signal generation is active
0x0 (INT_SIG_DISABLE): CQIS.HAC interrupt signal generation is disabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQIC</name>
          <description>No description available</description>
          <addressOffset>0x19c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80119FFF</resetMask>
          <fields>
            <field>
              <name>INTC_EN</name>
              <description>Interrupt Coalescing Enable Bit
Values:
0x1 (ENABLE_INT_COALESCING): Interrupt coalescing mechanism is active. Interrupts are counted and timed, and coalesced interrupts are generated
0x0 (DISABLE_INT_COALESCING): Interrupt coalescing mechanism is disabled (Default)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTC_STAT</name>
              <description>Interrupt Coalescing Status Bit
This bit indicates to the software whether any tasks (with INT=0) have completed and counted towards interrupt
coalescing (that is, this is set if and only if INTC counter &gt; 0).
Values:
0x1 (INTC_ATLEAST1_COMP): At least one INT0 task completion has been counted (INTC counter &gt; 0)
0x0 (INTC_NO_TASK_COMP): INT0 Task completions have not occurred since last counter reset (INTC counter == 0)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTC_RST</name>
              <description>Counter and Timer Reset
When host driver writes 1, the interrupt coalescing timer and counter are reset.
Values:
0x1 (ASSERT_INTC_RESET): Interrupt coalescing timer and counter are reset
0x0 (NO_EFFECT): No Effect</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>INTC_TH_WEN</name>
              <description>Interrupt Coalescing Counter Threshold Write Enable
When software writes 1 to this bit, the value INTC_TH is updated with the contents written on the same cycle.
Values:
0x1 (WEN_SET): Sets INTC_TH_WEN
0x0 (WEN_CLR): Clears INTC_TH_WEN</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>INTC_TH</name>
              <description>Interrupt Coalescing Counter Threshold filed
Software uses this field to configure the number of task completions (only tasks with INT=0 in the Task Descriptor), which are required in order to generate an interrupt.
Counter Operation: As data transfer tasks with INT=0 complete, they are counted by CQE.
The counter is reset by software during the interrupt service routine.
The counter stops counting when it reaches the value configured in INTC_TH, and generates interrupt.
0x0: Interrupt coalescing feature disabled
0x1: Interrupt coalescing interrupt generated after 1 task when INT=0 completes
0x2: Interrupt coalescing interrupt generated after 2 tasks when INT=0 completes
........
0x1f: Interrupt coalescing interrupt generated after 31 tasks when INT=0 completes
To write to this field, the INTC_TH_WEN bit must be set during the same write operation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TOUT_VAL_WEN</name>
              <description>When software writes 1 to this bit, the value TOUT_VAL is updated with the contents written on the same cycle.
Values:
0x1 (WEN_SET): Sets TOUT_VAL_WEN
0x0 (WEN_CLR): clears TOUT_VAL_WEN</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TOUT_VAL</name>
              <description>Interrupt Coalescing Timeout Value
Software uses this field to configure the maximum time allowed between the completion of a task on the bus and the generation of an interrupt.
Timer Operation: The timer is reset by software during the interrupt service routine.
It starts running when the first data transfer task with INT=0 is completed, after the timer was reset.
When the timer reaches the value configured in ICTOVAL field, it  generates an interrupt and stops.
The timer's unit is equal to 1024 clock periods of the clock whose frequency is specified in the Internal Timer Clock Frequency field CQCAP register.
0x0: Timer is disabled. Timeout-based interrupt is not generated
0x1: Timeout on 01x1024 cycles of timer clock frequency
0x2: Timeout on 02x1024 cycles of timer clock frequency
........
0x7f: Timeout on 127x1024 cycles of timer clock frequency
In order to write to this field, the TOUT_VAL_WEN bit must
be set at the same write operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQTDLBA</name>
          <description>No description available</description>
          <addressOffset>0x1a0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDLBA</name>
              <description>This register stores the LSB bits (31:0) of the byte address of the head of the Task Descriptor List in system memory.
The size of the task descriptor list is 32 * (Task Descriptor size + Transfer Descriptor size) as configured by the host driver.
This address is set on 1 KB boundary. The lower 10 bits of this register are set to 0 by the software and are ignored by CQE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQTDBR</name>
          <description>No description available</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBR</name>
              <description>The software configures TDLBA and TDLBAU, and enable
CQE in CQCFG before using this register.
Writing 1 to bit n of this register triggers CQE to start processing the task encoded in slot n of the TDL.
Writing 0 by the software does not have any impact on the hardware, and does not change the value of the register bit.
CQE always processes tasks according to the order submitted to the list by CQTDBR write transactions.
CQE processes Data Transfer tasks by reading the Task Descriptor and sending QUEUED_TASK_PARAMS (CMD44) and QUEUED_TASK_ADDRESS (CMD45) commands to
the device. CQE processes DCMD tasks (in slot #31, when enabled) by reading the Task Descriptor, and generating the command encoded by its index and argument.
The corresponding bit is cleared to 0 by CQE in one of the following events:
A task execution is completed (with success or error).
The task is cleared using CQTCLR register.
All tasks are cleared using CQCTL register.
CQE is disabled using CQCFG register.
Software may initiate multiple tasks at the same time (batch submission) by writing 1 to multiple bits of this register in the same transaction.
In the case of batch submission, CQE processes the tasks in order of the task index, starting with the lowest index.
If one or more tasks in the batch are marked with QBR, the ordering of execution is based on said processing order.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQTCN</name>
          <description>No description available</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCN</name>
              <description>Task Completion Notification
Each of the 32 bits are bit mapped to the 32 tasks.
Bit-N(1): Task-N has completed execution (with success or errors)
Bit-N(0): Task-N has not completed, could be pending or not submitted.
On task completion, software may read this register to know tasks that have completed. After reading this register,
software may clear the relevant bit fields by writing 1 to the corresponding bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQDQS</name>
          <description>No description available</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DQS</name>
              <description>Device Queue Status
Each of the 32 bits are bit mapped to the 32 tasks.
Bit-N(1): Device has marked task N as ready for execution
Bit-N(0): Task-N is not ready for execution. This task could be pending in device or not submitted.
Host controller updates this register with response of the Device Queue Status command.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQDPT</name>
          <description>No description available</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DPT</name>
              <description>Device-Pending Tasks
Each of the 32 bits are bit mapped to the 32 tasks.
Bit-N(1): Task-N has been successfully queued into the device and is awaiting execution
Bit-N(0): Task-N is not yet queued.
Bit n of this register is set if and only if QUEUED_TASK_PARAMS (CMD44) and QUEUED_TASK_ADDRESS (CMD45) were sent for this specific task and if this task has not been executed.
The controller sets this bit after receiving a successful response for CMD45. CQE clears this bit after the task has completed execution.
Software reads this register in the task-discard procedure to determine if the task is queued in the device</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQTCLR</name>
          <description>No description available</description>
          <addressOffset>0x1b8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCLR</name>
              <description>Writing 1 to bit n of this register orders CQE to clear a task that the software has previously issued.
This bit can only be written when CQE is in Halt state as indicated in CQCFG register Halt bit.
When software writes 1 to a bit in this register, CQE updates the value to 1, and starts clearing the data structures related to the task.
CQE clears the bit fields (sets a value of 0) in CQTCLR and in CQTDBR once the clear operation is complete.
Software must poll on the CQTCLR until it is  leared to verify that a clear operation was done.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQSSC1</name>
          <description>No description available</description>
          <addressOffset>0x1c0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>SQSCMD_BLK_CNT</name>
              <description>This field indicates when SQS CMD is sent while data transfer is in progress.
A value of 'n' indicates that CQE sends status command on the CMD line, during the transfer of data block BLOCK_CNTn, on the data lines, where BLOCK_CNT is the number of blocks in the current transaction.
0x0: SEND_QUEUE_STATUS (CMD13) command is not sent during the transaction. Instead, it is sent only when the data lines are idle.
0x1: SEND_QUEUE_STATUS command is to be sent during the last block of the transaction.
0x2: SEND_QUEUE_STATUS command when last 2 blocks are pending.
0x3: SEND_QUEUE_STATUS command when last 3 blocks are pending.
........
0xf: SEND_QUEUE_STATUS command when last 15 blocks are pending.
Should be programmed only when CQCFG.CQ_EN is 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SQSCMD_IDLE_TMR</name>
              <description>This field configures the polling period to be used when using periodic SEND_QUEUE_STATUS (CMD13) polling.
Periodic polling is used when tasks are pending in the device, but no data transfer is in progress.
When a SEND_QUEUE_STATUS response indicates that no task is ready for execution, CQE counts the configured time until it issues the next SEND_QUEUE_STATUS.
Timer units are clock periods of the clock whose frequency is specified in the Internal Timer Clock Frequency field CQCAP register.
The minimum value is 0001h (1 clock period) and the maximum value is FFFFh (65535 clock periods).
For example, a CQCAP field value of 0 indicates a 19.2 MHz clock frequency (period = 52.08 ns).
If the setting in CQSSC1.CIT is 1000h, the calculated polling period is 4096*52.08 ns= 213.33 us.
Should be programmed only when CQCFG.CQ_EN is '0'</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQSSC2</name>
          <description>No description available</description>
          <addressOffset>0x1c4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>SQSCMD_RCA</name>
              <description>This field provides CQE with the contents of the 16-bit RCA field in SEND_QUEUE_STATUS (CMD13) command argument.
CQE copies this field to bits 31:16 of the argument when transmitting SEND_ QUEUE_STATUS (CMD13) command.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQCRDCT</name>
          <description>No description available</description>
          <addressOffset>0x1c8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCMD_RESP</name>
              <description>This register contains the response of the command generated by the last direct command (DCMD) task that was sent.
Contents of this register are valid only after bit 31 of CQTDBR register is cleared by the controller.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQRMEM</name>
          <description>No description available</description>
          <addressOffset>0x1d0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESP_ERR_MASK</name>
              <description>The bits of this field are bit mapped to the device response.
This bit is used as an interrupt mask on the device status filed that is received in R1/R1b responses.
1: When a R1/R1b response is received, with a bit i in the device status set, a RED interrupt is generated.
0: When a R1/R1b response is received, bit i in the device status is ignored.
The reset value of this register is set to trigger an interrupt on all "Error" type bits in the device status.
Note: Responses to CMD13 (SQS) encode the QSR so that they are ignored by this logic.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQTERRI</name>
          <description>No description available</description>
          <addressOffset>0x1d4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F3F9F3F</resetMask>
          <fields>
            <field>
              <name>TRANS_ERR_TASKID</name>
              <description>This field captures the ID of the task that was executed and whose data transfer has errors.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRANS_ERR_CMD_INDX</name>
              <description>This field captures the index of the command that was executed and whose data transfer has errors.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_ERR_FIELDS_VALID</name>
              <description>This bit is updated when an error is detected while a command transaction was in progress.
Values:
0x1 (SET): Response-related error is detected. Check contents of RESP_ERR_TASKID and RESP_ERR_CMD_INDX fields
0x0 (NOT_SET): Ignore contents of RESP_ERR_TASKID and RESP_ERR_CMD_INDX</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_ERR_TASKID</name>
              <description>This field captures the ID of the task which was executed on the command line when the error occurred.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESP_ERR_CMD_INDX</name>
              <description>This field captures the index of the command that was executed on the command line when the error occurred</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQCRI</name>
          <description>No description available</description>
          <addressOffset>0x1d8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000003F</resetMask>
          <fields>
            <field>
              <name>CMD_RESP_INDX</name>
              <description>Last Command Response index
This field stores the index of the last received command response. Controller updates the value every time a command response is received</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CQCRA</name>
          <description>No description available</description>
          <addressOffset>0x1dc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD_RESP_ARG</name>
              <description>Last Command Response argument
This field stores the argument of the last received command response. Controller updates the value every time a command response is received.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSHC_VER_ID</name>
          <description>No description available</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VER_ID</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MSHC_VER_TYPE</name>
          <description>No description available</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VER_TYPE</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMMC_BOOT_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x52c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xF181070F</resetMask>
          <fields>
            <field>
              <name>BOOT_TOUT_CNT</name>
              <description>Boot Ack Timeout Counter Value.
This value determines the interval by which boot ack timeout (50 ms) is detected when boot ack is expected during boot operation.
0xF : Reserved
0xE : TMCLK x 2^27
 ............
0x1 : TMCLK x 2^14
0x0 : TMCLK x 2^13</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOT_ACK_ENABLE</name>
              <description>Boot Acknowledge Enable
When this bit set, SDXC checks for boot acknowledge start pattern of 0-1-0 during boot operation. This bit is applicable for both mandatory and alternate boot mode.
Values:
0x1 (TRUE): Boot Ack enable
0x0 (FALSE): Boot Ack disable</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALIDATE_BOOT</name>
              <description>Validate Mandatory Boot Enable bit
This bit is used to validate the MAN_BOOT_EN bit.
Values:
0x1 (TRUE): Validate Mandatory boot enable bit
0x0 (FALSE): Ignore Mandatory boot Enable bit</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>MAN_BOOT_EN</name>
              <description>Mandatory Boot Enable
This bit is used to initiate the mandatory boot operation. The application sets this bit along with VALIDATE_BOOT bit.
Writing 0 is ignored. The SDXC clears this bit after the boot transfer is completed or terminated.
Values:
0x1 (MAN_BOOT_EN): Mandatory boot enable
0x0 (MAN_BOOT_DIS): Mandatory boot disable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CQE_PREFETCH_DISABLE</name>
              <description>Enable or Disable CQE's PREFETCH feature
This field allows Software to disable CQE's data prefetch feature when set to 1.
Values:
0x0 (PREFETCH_ENABLE): CQE can Prefetch data for sucessive WRITE transfers and pipeline sucessive READ transfers
0x1 (PREFETCH_DISABLE): Prefetch for WRITE and Pipeline for READ are disabled</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CQE_ALGO_SEL</name>
              <description>Scheduler algorithm selected for execution
This bit selects the Algorithm used for selecting one of the many ready tasks for execution.
Values:
0x0 (PRI_REORDER_PLUS_FCFS): Priority based reordering with FCFS to resolve equal priority tasks
0x1 (FCFS_ONLY): First come First serve, in the order of DBR rings</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENH_STROBE_ENABLE</name>
              <description>Enhanced Strobe Enable
This bit instructs SDXC to sample the CMD line using data strobe for HS400 mode.
Values:
0x1 (ENH_STB_FOR_CMD): CMD line is sampled using data strobe for HS400 mode
0x0 (NO_STB_FOR_CMD): CMD line is sampled using cclk_rx for HS400 mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMC_RST_N_OE</name>
              <description>Output Enable control for EMMC Device Reset signal PAD
control.
This field drived sd_rst_n_oe output of SDXC
Values:
0x1 (ENABLE): sd_rst_n_oe is 1
0x0 (DISABLE): sd_rst_n_oe is 0</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMMC_RST_N</name>
              <description>EMMC Device Reset signal control.
This register field controls the sd_rst_n output of SDXC
Values:
0x1 (RST_DEASSERT): Reset to eMMC device is deasserted
0x0 (RST_ASSERT): Reset to eMMC device asserted (active low)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE_DATA_CRC_CHK</name>
              <description>Disable Data CRC Check
This bit controls masking of CRC16 error for Card Write in eMMC mode.
This is useful in bus testing (CMD19) for an eMMC device. In bus testing, an eMMC card does not send CRC status for a block,
which may generate CRC error. This CRC error can be masked using this bit during bus testing.
Values:
0x1 (DISABLE): DATA CRC check is disabled
0x0 (ENABLE): DATA CRC check is enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_IS_EMMC</name>
              <description>eMMC Card present
This bit indicates the type of card connected. An application program this bit based on the card connected to SDXC.
Values:
0x1 (EMMC_CARD): Card connected to SDXC is an eMMC card
0x0 (NON_EMMC_CARD): Card connected to SDXCis a non-eMMC card</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUTO_TUNING_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x540</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x7F1F0F1F</resetMask>
          <fields>
            <field>
              <name>SWIN_TH_VAL</name>
              <description>Sampling window threshold value setting
The maximum value that can be set here depends on the length of delayline used for tuning. A delayLine with 32 taps
can use values from 0x0 to 0x1F.
This field is valid only when SWIN_TH_EN is '1'. Should be programmed only when SAMPLE_CLK_SEL is '0'
0x0 : Threshold values is 0x1, windows of length 1 tap and above can be selected as sampling window.
0x1 : Threshold values is 0x2, windows of length 2 taps and above can be selected as sampling window.
0x2 : Threshold values is 0x1, windows of length 3 taps and above can be selected as sampling window.
........
0x1F : Threshold values is 0x1, windows of length 32 taps and above can be selected as sampling window.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POST_CHANGE_DLY</name>
              <description>Time taken for phase switching and stable clock output.
Specifies the maximum time (in terms of cclk cycles) that the delay line can take to switch its output phase after a change in tuning_cclk_sel or autotuning_cclk_sel.
Values:
0x0 (LATENCY_LT_1): Less than 1-cycle latency
0x1 (LATENCY_LT_2): Less than 2-cycle latency
0x2 (LATENCY_LT_3): Less than 3-cycle latency
0x3 (LATENCY_LT_4): Less than 4-cycle latency</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_CHANGE_DLY</name>
              <description>Maximum Latency specification between cclk_tx and cclk_rx.
Values:
0x0 (LATENCY_LT_1): Less than 1-cycle latency
0x1 (LATENCY_LT_2): Less than 2-cycle latency
0x2 (LATENCY_LT_3): Less than 3-cycle latency
0x3 (LATENCY_LT_4): Less than 4-cycle latency</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TUNE_CLK_STOP_EN</name>
              <description>Clock stopping control for Tuning and auto-tuning circuit.
When enabled, clock gate control output of SDXC (clk2card_on) is pulled low before changing phase select codes on tuning_cclk_sel and autotuning_cclk_sel.
This effectively stops the Device/Card clock, cclk_rx and also drift_cclk_rx. Changing phase code when clocks are stopped ensures glitch free phase switching.
 Set this bit to 0 if the PHY or delayline can guarantee glitch free switching.
Values:
0x1 (ENABLE_CLK_STOPPING): Clocks stopped during phase code change
0x0 (DISABLE_CLK_STOPPING): Clocks not stopped. PHY ensures glitch free phase switching</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WIN_EDGE_SEL</name>
              <description>This field sets the phase for Left and Right edges for drift monitoring. [Left edge offset + Right edge offset] must not be less than total taps of delayLine.
0x0: User selection disabled. Tuning calculated edges are used.
0x1: Right edge Phase is center + 2 stages, Left edge Phase is center - 2 stages.
0x2: Right edge Phase is center + 3 stages, Left edge Phase is center - 3 stagess
...
0xF: Right edge Phase is center + 16 stages, Left edge Phase is center - 16 stages.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_TUNE_EN</name>
              <description>This fields enables software-managed tuning flow.
Values:
0x1 (SW_TUNING_ENABLE): Software-managed tuning enabled. AUTO_TUNING_STAT.CENTER_PH_CODE Field is now writable.
0x0 (SW_TUNING_DISABLE): Software-managed tuning disabled</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RPT_TUNE_ERR</name>
              <description>Framing errors are not generated when executing tuning.
This debug bit allows users to report these errors.
Values:
0x1 (DEBUG_ERRORS): Debug mode for reporting framing errors
0x0 (ERRORS_DISABLED): Default mode where as per SDXC no errors are reported.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SWIN_TH_EN</name>
              <description>Sampling window Threshold enable
Selects the tuning mode
Field should be programmed only when SAMPLE_CLK_SEL is '0'
Values:
0x1 (THRESHOLD_MODE): Tuning engine selects the first complete sampling window that meets the threshold
set by SWIN_TH_VAL field
0x0 (LARGEST_WIN_MODE): Tuning engine sweeps all taps and settles at the largest window</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CI_SEL</name>
              <description>Selects the interval when the corrected center phase select code can be driven on tuning_cclk_sel output.
Values:
0x0 (WHEN_IN_BLK_GAP): Driven in block gap interval
0x1 (WHEN_IN_IDLE): Driven at the end of the transfer</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AT_EN</name>
              <description>Setting this bit enables Auto tuning engine. This bit is enabled by default when core is configured with mode3 retuning support.
Clear this bit to 0 when core is configured to have Mode3 re-tuning but SW wishes to disable mode3 retuning.
This field should be programmed only when SYS_CTRL.SD_CLK_EN is 0.
Values:
0x1 (AT_ENABLE): AutoTuning is enabled
0x0 (AT_DISABLE): AutoTuning is disabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AUTO_TUNING_STAT</name>
          <description>No description available</description>
          <addressOffset>0x544</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>L_EDGE_PH_CODE</name>
              <description>Left Edge Phase code. Reading this field returns the phase code value used by Auto-tuning engine to sample data on Left edge of sampling window.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>R_EDGE_PH_CODE</name>
              <description>Right Edge Phase code. Reading this field returns the phase code value used by Auto-tuning engine to sample data on Right edge of sampling window.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTER_PH_CODE</name>
              <description>Centered Phase code. Reading this field returns the current value on tuning_cclk_sel output. Setting AUTO_TUNING_CTRL.SW_TUNE_EN enables software to write to this field and its contents are reflected on tuning_cclk_sel</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CTRL0</name>
          <description>No description available</description>
          <addressOffset>0x3000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x10020FFF</resetMask>
          <fields>
            <field>
              <name>CARDCLK_INV_EN</name>
              <description>set to invert card_clk, for slow speed card to meet 5ns setup timing.
May cause glitch on clock, should be set before enable clk(in core cfg)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAD_CLK_SEL_B</name>
              <description>set to use internal clock directly, may have timing issue;
clr to use clock loopback from pad.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FREQ_SEL_SW_EN</name>
              <description>set to use FREQ_SEL_SW as card clock divider;
clear to use core logic as clock divider.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMCLK_EN</name>
              <description>set to force enable tmclk;
clear to  use core signal intclk_en to control it</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FREQ_SEL_SW</name>
              <description>software card clock divider, it will be used only when FREQ_SEL_SW_EN is set</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CTRL1</name>
          <description>No description available</description>
          <addressOffset>0x3004</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xB3F3F000</resetMask>
          <fields>
            <field>
              <name>CARD_ACTIVE</name>
              <description>SW write 1 to start card clock delay counter(delay time is configed by CARD_ACTIVE_PERIOD_SEL).
When counter finished, this bit will be cleared by hardware.
Write 1 when this bit is 1 will cause unknown result(actually no use except write at exact finish time)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARD_ACTIVE_PERIOD_SEL</name>
              <description>card clock delay config.
00 for 100 cycle; 01 for 74 cycle; 10 for 128 cycle; 11 for 256 cycle</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CARDCLK_DLYSEL</name>
              <description>for card clock DLL, default 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_DLYSEL</name>
              <description>for strobe DLL, default 7taps(1ns)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SDXC0">
      <name>SDXC1</name>
      <description>SDXC1</description>
      <groupName>SDXC</groupName>
      <baseAddress>0xf1134000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DDRCTL</name>
      <description>DDRCTL</description>
      <groupName>DDRCTL</groupName>
      <baseAddress>0xf3010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xf34</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MSTR</name>
          <description>Description: Master Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x03040001</resetValue>
          <resetMask>0x0F0FB601</resetMask>
          <fields>
            <field>
              <name>ACTIVE_RANKS</name>
              <description>Description: Only present for multi-rank configurations. Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.
1 - populated
0 - unpopulated
LSB is the lowest rank number.
For 2 ranks following combinations are legal:
01 - One rank
11 - Two ranks
Others - Reserved.
For 4 ranks following combinations are legal:
0001 - One rank
0011 - Two ranks
1111 - Four ranks
Value After Reset: "(MEMC_NUM_RANKS==4) ? 0xF
:((MEMC_NUM_RANKS==2) ? 0x3 : 0x1)"
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BURST_RDWR</name>
              <description>Description: SDRAM burst length used:
0001 - Burst length of 2 (only supported for mDDR)
0010 - Burst length of 4
0100 - Burst length of 8
1000 - Burst length of 16 (only supported for mDDR and LPDDR2)
All other values are reserved.
This controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLL_OFF_MODE</name>
              <description>Description: Set to 1 when uMCTL2 and DRAM has to be put in DLL-off mode for low frequency operation.
Set to 0 to put uMCTL2 and DRAM in DLL-on mode for normal frequency operation.
Value After Reset: 0x0
Exists: MEMC_DDR3_OR_4==1</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_BUS_WIDTH</name>
              <description>Description: Selects proportion of DQ bus width that is used by the SDRAM
00 - Full DQ bus width to SDRAM
01 - Half DQ bus width to SDRAM
10 - Quarter DQ bus width to SDRAM
11 - Reserved.
Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width).
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_2T_TIMING_MODE</name>
              <description>Description: If 1, then uMCTL2 uses 2T timing. Otherwise, uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command
Note: 2T timing is not supported in LPDDR2/LPDDR3 mode Note: 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set
Note: 2T timing is not supported in DDR4 geardown mode.
Value After Reset: 0x0
Exists: MEMC_CMD_RTN2IDLE==0</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BURSTCHOP</name>
              <description>Description: When set, enable burst-chop in DDR3/DDR4. This is only supported in full bus width mode (MSTR.data_bus_width = 00). If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), burst chop is not supported, and this bit must be set to '0'
Value After Reset: 0x0
Exists: MEMC_DDR3==1 || MEMC_DDR4==1</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR3</name>
              <description>Description: Select DDR3 SDRAM
1 - DDR3 SDRAM device in use
0 - non-DDR3 SDRAM device in use Only present in designs that support DDR3.
Value After Reset: "(MEMC_DDR3_EN==1) ? 0x1 : 0x0"
Exists: MEMC_DDR3==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <description>Description: Operating Mode Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000037</resetMask>
          <fields>
            <field>
              <name>SELFREF_TYPE</name>
              <description>Description: Flags if Self Refresh is entered and if it was under Automatic Self Refresh control only or not.
00 - SDRAM is not in Self Refresh
11 - SDRAM is in Self Refresh and Self Refresh was caused by Automatic Self Refresh only
10 - SDRAM is in Self Refresh and Self Refresh was not caused solely under Automatic Self Refresh control. It could have been caused by Hardware Low Power Interface and/or Software (reg_ddrc_selfref_sw).
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OPERATING_MODE</name>
              <description>Description: Operating mode. This is 3-bits wide in configurations with mDDR/LPDDR2/LPDDR3/DDR4 support and 2-bits in all other configurations.
non-mDDR/LPDDR2/LPDDR3 and non-DDR4 designs:
00 - Init
01 - Normal
10 - Power-down
11 - Self refresh
mDDR/LPDDR2/LPDDR3 or DDR4 designs:
000 - Init
001 - Normal
010 - Power-down
011 - Self refresh
1XX - Deep power-down / Maximum Power Saving Mode
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MRCTRL0</name>
          <description>Description: Mode Register Read/Write Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0x8000F0F0</resetMask>
          <fields>
            <field>
              <name>MR_WR</name>
              <description>Description: Setting this register bit to 1 triggers a mode register read or write operation. When the MR operation is complete, the uMCTL2 automatically clears this bit. The other register fields of this register must be written in a separate APB transaction, before setting this mr_wr bit. It is recommended NOT to set this signal if in Init, Deep power- down or MPSM operating modes.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR_ADDR</name>
              <description>Description: Address of the mode register that is to be written to.
0000 - MR0
0001 - MR1
0010 - MR2
0011 - MR3
0100 - MR4
0101 - MR5
0110 - MR6
0111 - MR7
Don't Care for LPDDR2/LPDDR3 (see MRCTRL1.mr_data for mode register addressing in LPDDR2/LPDDR3)
This signal is also used for writing to control words of RDIMMs. In that case, it corresponds to the bank address bits sent to the RDIMM
In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the bit[3] as well as the bit[2:0] must be set to an appropriate value which is considered both the Address Mirroring of UDIMMs/RDIMMs and the Output Inversion of RDIMMs.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MR_RANK</name>
              <description>Description: Controls which rank is accessed by MRCTRL0.mr_wr. Normally, it is desired to access all ranks, so all bits should be set to 1. However, for multi-rank UDIMMs/RDIMMs which implement address mirroring, it may be necessary to access ranks individually.
Examples (assume uMCTL2 is configured for 4 ranks):
0x1 - select rank 0 only
0x2 - select rank 1 only
0x5 - select ranks 0 and 2
0xA - select ranks 1 and 3
0xF - select ranks 0, 1, 2 and 3
Value After Reset: "(MEMC_NUM_RANKS==4) ? 0xF
:((MEMC_NUM_RANKS==2) ? 0x3 : 0x1)"
Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MRCTRL1</name>
          <description>Description: Mode Register Read/Write Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>MR_DATA</name>
              <description>Description: Mode register write data for all non- LPDDR2/non-LPDDR3 modes.
For LPDDR2/LPDDR3, MRCTRL1[15:0] are interpreted as [15:8] MR Address and [7:0] MR data for writes, don't care for reads. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MRSTAT</name>
          <description>Description: Mode Register Read/Write Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>MR_WR_BUSY</name>
              <description>Description: The SoC core may initiate a MR write operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the MRW/MRR request. It goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.
0 - Indicates that the SoC core can initiate a mode register write operation
1 - Indicates that mode register write operation is in progress
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWRCTL</name>
          <description>Description: Low Power Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000002B</resetMask>
          <fields>
            <field>
              <name>SELFREF_SW</name>
              <description>Description: A value of 1 to this register causes system to move to Self Refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to Self Refresh.
1 - Software Entry to Self Refresh
0 - Software Exit from Self Refresh
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DFI_DRAM_CLK_DISABLE</name>
              <description>Description: Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.
If set to 0, dfi_dram_clk_disable is never asserted. Assertion of dfi_dram_clk_disable is as follows:
In DDR2/DDR3, can only be asserted in Self Refresh. In DDR4, can be asserted in following:
in Self Refresh.
in Maximum Power Saving Mode
In mDDR/LPDDR2/LPDDR3, can be asserted in following:
in Self Refresh
in Power Down
in Deep Power Down
during Normal operation (Clock Stop)
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWERDOWN_EN</name>
              <description>Description: If true then the uMCTL2 goes into power-down after a programmable number of cycles "maximum idle clocks before power down" (PWRTMG.powerdown_to_x32).
This register bit may be re-programmed during the course of normal operation.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SELFREF_EN</name>
              <description>Description: If true then the uMCTL2 puts the SDRAM into Self Refresh after a programmable number of cycles "maximum idle clocks before Self Refresh (PWRTMG.selfref_to_x32)". This register bit may be re- programmed during the course of normal operation.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWRTMG</name>
          <description>Description: Low Power Timing Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00400010</resetValue>
          <resetMask>0x00FF001F</resetMask>
          <fields>
            <field>
              <name>SELFREF_TO_X32</name>
              <description>Description: After this many clocks of NOP or deselect the uMCTL2 automatically puts the SDRAM into Self Refresh. This must be enabled in the PWRCTL.selfref_en.
Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.
Value After Reset: 0x40
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWERDOWN_TO_X32</name>
              <description>Description: After this many clocks of NOP or deselect the uMCTL2 automatically puts the SDRAM into power-down. This must be enabled in the PWRCTL.powerdown_en.
Unit: Multiples of 32 clocks FOR PERFORMANCE ONLY.
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HWLPCTL</name>
          <description>Description: Hardware Low Power Control Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000003</resetValue>
          <resetMask>0x0FFF0003</resetMask>
          <fields>
            <field>
              <name>HW_LP_IDLE_X32</name>
              <description>Description: Hardware idle period. The cactive_ddrc output is driven low if the system is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM operating_mode. The hardware idle function is disabled when hw_lp_idle_x32=0.
Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HW_LP_EXIT_IDLE_EN</name>
              <description>Description: When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used to exit from the automatic clock stop, automatic power down or automatic self-refresh modes. Note, it will not cause exit of Self-Refresh that was caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HW_LP_EN</name>
              <description>Description: Enable for Hardware Low Power Interface.
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RFSHCTL0</name>
          <description>Description: Refresh Control Register 0</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00210000</resetValue>
          <resetMask>0x00F1F1F0</resetMask>
          <fields>
            <field>
              <name>REFRESH_MARGIN</name>
              <description>Description: Threshold value in number of clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom_x32. Note that, in LPDDR2/LPDDR3, internally used t_rfc_nom_x32 may be equal to RFSHTMG.t_rfc_nom_x32&gt;&gt;2 if derating is enabled (DERATEEN.derate_enable=1). Otherwise, internally used t_rfc_nom_x32 will be equal to RFSHTMG.t_rfc_nom_x32.
Unit: Multiples of 32 clocks. Value After Reset: 0x2 Exists: Always</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REFRESH_TO_X32</name>
              <description>Description: If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, but it has not expired (RFSHCTL0.refresh_burst+1) times yet, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful, but before it is absolutely required. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2.
FOR PERFORMANCE ONLY.
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>12</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REFRESH_BURST</name>
              <description>Description: The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.
0 - single refresh
1 - burst-of-2 refresh
7 - burst-of-8 refresh
For information on burst refresh feature refer to section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf.
For DDR2/3, the refresh is always per-rank and not per- bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granuarity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY- initiated update is complete.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RFSHCTL1</name>
          <description>Description: Refresh Control Register 1</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FFF0FFF</resetMask>
          <fields>
            <field>
              <name>REFRESH_TIMER1_START_VALUE_X32</name>
              <description>Description: Refresh timer start for rank 1 (only present in multi-rank configurations). This is useful in staggering the refreshes to multiple ranks to help traffic to proceed. This is explained in Refresh Controls section of architecture chapter.
Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.
Value After Reset: 0x0
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REFRESH_TIMER0_START_VALUE_X32</name>
              <description>Description: Refresh timer start for rank 0 (only present in multi-rank configurations). This is useful in staggering the refreshes to multiple ranks to help traffic to proceed. This is explained in Refresh Controls section of architecture chapter.
Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.
Value After Reset: 0x0
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RFSHCTL3</name>
          <description>Description: Refresh Control Register 0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>REFRESH_UPDATE_LEVEL</name>
              <description>Description: Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated.
The value is automatically updated when exiting soft reset, so it does not need to be toggled initially.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_AUTO_REFRESH</name>
              <description>Description: When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC core must generate refreshes using the registers reg_ddrc_rank0_refresh, reg_ddrc_rank1_refresh, reg_ddrc_rank2_refresh and reg_ddrc_rank3_refresh.
When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2.
If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto- refresh is not supported, and this bit must be set to '0'.
This register field is changeable on the fly.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RFSHTMG</name>
          <description>Description: Refresh Timing Register</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x0062008C</resetValue>
          <resetMask>0x0FFF01FF</resetMask>
          <fields>
            <field>
              <name>T_RFC_NOM_X32</name>
              <description>Description: tREFI: Average time interval between refreshes per rank (specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2 and LPDDR3).
For LPDDR2/LPDDR3:
if using all-bank refreshes (RFSHCTL0.per_bank_refresh
= 0), this register should be set to tREFIab
if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), this register should be set to tREFIpb
For configurations with MEMC_FREQ_RATIO=2, program this to (tREFI/2), no rounding up.
In DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register.
Note that RFSHTMG.t_rfc_nom_x32 * 32 must be greater than RFSHTMG.t_rfc_min. Unit: Multiples of 32 clocks.
Value After Reset: 0x62
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_RFC_MIN</name>
              <description>Description: tRFC (min): Minimum time from refresh to refresh or activate.
For LPDDR2/LPDDR3:
if using all-bank refreshes (RFSHCTL0.per_bank_refresh
= 0), this register should be set to tRFCab
if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), this register should be set to tRFCpb
For configurations with MEMC_FREQ_RATIO=2, program this to tRFC(min)/2 and round up to next integer value.
In DDR4 mode, tRFC(min) value is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used.
Unit: Clocks.
Value After Reset: 0x8c
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECCUADDR0</name>
          <description>Description: ECC Uncorrected Error Address Register 0</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0303FFFF</resetMask>
          <fields>
            <field>
              <name>ECC_UNCORR_RANK</name>
              <description>Description: Rank number of a read resulting in an uncorrected ECC error
Value After Reset: 0x0
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_UNCORR_ROW</name>
              <description>Description: Page/row number of a read resulting in an uncorrected ECC error. This is 18-bits wide in configurations with DDR4 support and 16-bits in all other configurations.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRCPARCTL0</name>
          <description>Description: CRC Parity Control Register0</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>DFI_ALERT_ERR_CNT_CLR</name>
              <description>Description: DFI alert error count clear. Clear bit for DFI alert error counter. Asserting this bit will clear the DFI alert error counter, CRCPARSTAT.dfi_alert_err_cnt. When the clear operation is complete, the uMCTL2 automatically clears this bit.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_ALERT_ERR_INT_CLR</name>
              <description>Description: Interrupt clear bit for DFI alert error. If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_int will be cleared. When the clear operation is complete, the uMCTL2 automatically clears this bit.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_ALERT_ERR_INT_EN</name>
              <description>Description: Interrupt enable bit for DFI alert error. If this bit is set, any parity/CRC error detected on the dfi_alert_n input will result in an interrupt being set on CRCPARSTAT.dfi_alert_err_int.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRCPARSTAT</name>
          <description>Description: CRC Parity Status Register</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0001FFFF</resetMask>
          <fields>
            <field>
              <name>DFI_ALERT_ERR_INT</name>
              <description>Description: DFI alert error interrupt.
If a parity/CRC error is detected on dfi_alert_n, and the interrupt is enabled by CRCPARCTL0.dfi_alert_err_int_en, this interrupt bit will be set. It will remain set until cleared by CRCPARCTL0.dfi_alert_err_int_clr
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DFI_ALERT_ERR_CNT</name>
              <description>Description: DFI alert error count.
If a parity/CRC error is detected on dfi_alert_n, this counter be incremented. This is independent of the setting of CRCPARCTL0.dfi_alert_err_int_en. It will saturate at 0xFFFF, and can be cleared by asserting CRCPARCTL0.dfi_alert_err_cnt_clr.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT0</name>
          <description>Description: SDRAM Initialization Register 0</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x0002004E</resetValue>
          <resetMask>0xC3FF03FF</resetMask>
          <fields>
            <field>
              <name>SKIP_DRAM_INIT</name>
              <description>Description: If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed
00 - SDRAM Initialization routine is run after power-up
01 - SDRAM Initialization routine is skipped after power- up. Controller starts up in Normal Mode
11 - SDRAM Initialization routine is skipped after power- up. Controller starts up in Self-refresh Mode
10 - SDRAM Initialization routine is run after power-up.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POST_CKE_X1024</name>
              <description>Description: Cycles to wait after driving CKE high to start the SDRAM initialization sequence.
Unit: 1024 clocks.
DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds.
LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us.
For configurations with MEMC_FREQ_RATIO=2, program this to JEDEC spec value divided by 2, and round it up to next integer value.
Value After Reset: 0x2
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_CKE_X1024</name>
              <description>Description: Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence.
Unit: 1024 clock cycles.
DDR2 specifications typically require this to be programmed for a delay of &gt;= 200 us.
LPDDR2/LPDDR3: tINIT1 of 100 ns (min)
For configurations with MEMC_FREQ_RATIO=2, program this to JEDEC spec value divided by 2, and round it up to next integer value.
Value After Reset: 0x4e
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT1</name>
          <description>Description: SDRAM Initialization Register 1</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF7F0F</resetMask>
          <fields>
            <field>
              <name>DRAM_RSTN_X1024</name>
              <description>Description: Number of cycles to assert SDRAM reset signal during init sequence.
This is only present for designs supporting DDR3/DDR4 devices. For use with a Synopsys DDR PHY, this should be set to a minimum of 1
Value After Reset: 0x0
Exists: MEMC_DDR3==1 || MEMC_DDR4==1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FINAL_WAIT_X32</name>
              <description>Description: Cycles to wait after completing the SDRAM initialization sequence before starting the dynamic scheduler.
Unit: Counts of a global timer that pulses every 32 clock cycles.
There is no known specific requirement for this; it may be set to zero.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_OCD_X32</name>
              <description>Description: Wait period before driving the OCD complete command to SDRAM.
Unit: Counts of a global timer that pulses every 32 clock cycles.
There is no known specific requirement for this; it may be set to zero.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT3</name>
          <description>Description: SDRAM Initialization Register 3</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000510</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MR</name>
              <description>Description: DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately.
DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register.
LPDDR2/LPDDR3 - Value to write to MR1 register
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMR</name>
              <description>Description: DDR2: Value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately.
DDR3/DDR4: Value to write to MR1 register Set bit 7 to 0. If PHY-evaluation mode training is enabled, this bit is set appropriately by the uMCTL2 during write leveling.
mDDR: Value to write to EMR register. LPDDR2/LPDDR3 - Value to write to MR2 register Value After Reset: 0x510
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT4</name>
          <description>Description: SDRAM Initialization Register 4</description>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EMR2</name>
              <description>Description: DDR2: Value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register LPDDR2/LPDDR3: Value to write to MR3 register mDDR: Unused
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EMR3</name>
              <description>Description: DDR2: Value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register mDDR/LPDDR2/LPDDR3: Unused
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT5</name>
          <description>Description: SDRAM Initialization Register 5</description>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <resetValue>0x00100000</resetValue>
          <resetMask>0x00FF0000</resetMask>
          <fields>
            <field>
              <name>DEV_ZQINIT_X32</name>
              <description>Description: ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3.
Unit: 32 clock cycles.
DDR3 typically requires 512 clocks. DDR4 requires 1024 clocks.
LPDDR2/LPDDR3 requires 1 us.
Value After Reset: 0x10
Exists: MEMC_DDR3==1 || MEMC_DDR4 == 1 || MEMC_LPDDR2==1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIMMCTL</name>
          <description>Description: DIMM Control Register</description>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>DIMM_ADDR_MIRR_EN</name>
              <description>Description: Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank DDR4 RDIMM implementations).
Some UDIMMs and DDR4 RDIMMs implement address mirroring for odd ranks, which means that the following address, bank address and bank group bits are swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13),
(BG0, BG1) for the DDR4. Setting this bit ensures that, for mode register accesses during the automatic initialization routine, these bits are swapped within the uMCTL2 to compensate for this UDIMM/RDIMM swapping. In addition to the automatic initialization routine, in case of DDR4 UDIMM/RDIMM, they are swapped during the automatic MRS access to enable/disable of a particular DDR4 feature.
Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses.
This is not supported for mDDR, LPDDR2 or LPDDR3 SDRAMs.
Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to 1.
1 - For odd ranks, implement address mirroring for MRS commands to during initialization and for any automatic DDR4 MRS commands (to be used if UDIMM/RDIMM implements address mirroring)
0 - Do not implement address mirroring
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIMM_STAGGER_CS_EN</name>
              <description>Description: Staggering enable for multi-rank accesses (for multi-rank UDIMM and RDIMM implementations only). This is not supported for DDR4, mDDR, LPDDR2 or LPDDR3 SDRAMs.
1 - Stagger accesses to even and odd ranks
0 - Do not stagger accesses
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANKCTL</name>
          <description>Description: Rank Control Register</description>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <resetValue>0x0000066F</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>DIFF_RANK_WR_GAP</name>
              <description>Description: Only present for multi-rank configurations. Indicates the number of clocks of gap in data responses when performing consecutive writes to different ranks.
This is used to switch the delays in the PHY to match the rank requirements.
The value programmed in this register takes care of the ODT switch off timing requirement when switching ranks during writes.
For configurations with MEMC_FREQ_RATIO=2, program this to (N/2) and round it up to the next integer value. N is value required by PHY, in terms of PHY clocks.
Value After Reset: 0x6
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFF_RANK_RD_GAP</name>
              <description>Description: Only present for multi-rank configurations. Indicates the number of clocks of gap in data responses when performing consecutive reads to different ranks.
This is used to switch the delays in the PHY to match the rank requirements.
The value programmed in this register takes care of the ODT switch off timing requirement when switching ranks during reads.
For configurations with MEMC_FREQ_RATIO=2, program this to (N/2) and round it up to the next integer value. N is value required by PHY, in terms of PHY clocks.
Value After Reset: 0x6
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_RANK_RD</name>
              <description>Description: Only present for multi-rank configurations. Background: Reads to the same rank can be performed back-to-back. Reads to different ranks require additional gap
dictated by the register RANKCTL.diff_rank_rd_gap. This is
to avoid possible data bus contention as well as to give PHY enough time to switch the delay when changing ranks. The uMCTL2 arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is scheduled, there are few clock cycles (determined by the value on diff_rank_rd_gap register) in which only reads from the same rank are eligible to be scheduled. This prevents reads from other ranks from having fair access to the data bus.
This parameter represents the maximum number of reads that can be scheduled consecutively to the same rank. After this number is reached, a delay equal to RANKCTL.diff_rank_rd_gap is inserted by the scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers increase bandwidth utilization, lower numbers increase fairness.
This feature can be DISABLED by setting this register to 0. When set to 0, the Controller will stay on the same rank as long as commands are available for it.
Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF.
Feature limitation: max_rank_rd feature works as described only in the mode in which one command at the DDRC input results in one DFI command at the output. An example of this mode is: BL8 hardware configuration (MEMC_BURST_LENGTH=8) and Full bus width mode (MSTR.data_bus_width=2'b00) and BL8 mode of operation (MSTR.burst_rdwr=4'b0100). In modes where single HIF command results in multiple DFI commands (eg: Half Bus Width, BL4 etc.), the same rank commands would be serviced for as long as they are available, which is equivalent to this feature being disabled.
FOR PERFORMANCE ONLY.
Value After Reset: 0xf
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG0</name>
          <description>Description: SDRAM Timing Register 0</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x0F101B0F</resetValue>
          <resetMask>0x7F3F7F3F</resetMask>
          <fields>
            <field>
              <name>WR2PRE</name>
              <description>Description: Minimum time between write and precharge to same bank.
Unit: Clocks
Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies where:
WL = write latency
BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present.
tWR = Write recovery time. This comes directly from the SDRAM specification.
Add one extra cycle for LPDDR2/LPDDR3 for this parameter. For configurations with MEMC_FREQ_RATIO=2, 1T mode, divide the above value by 2. No rounding up.
For configurations with MEMC_FREQ_RATIO=2, 2T mode, divide the above value by 2 and add 1. No rounding up.
Value After Reset: 0xf
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_FAW</name>
              <description>Description: tFAW Valid only when 8 or more banks(or banks x bank groups) are present.
In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles.
For configurations with MEMC_FREQ_RATIO=2, program this to (tFAW/2) and round up to next integer value.
In a 4-bank design, set this register to 0x1 independent of the MEMC_FREQ_RATIO configuration.
Unit: Clocks
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_RAS_MAX</name>
              <description>Description: tRAS(max): Maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open
Minimum value of this register is 1. Zero is invalid.
For configurations with MEMC_FREQ_RATIO=2, program this to (tRAS(max)-1)/2. No rounding up.
Unit: Multiples of 1024 clocks. Value After Reset: 0x1b Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_RAS_MIN</name>
              <description>Description: tRAS(min): Minimum time between activate and precharge to the same bank.
For configurations with MEMC_FREQ_RATIO=2, 1T mode, program this to tRAS(min)/2. No rounding up.
For configurations with MEMC_FREQ_RATIO=2, 2T mode, program this to (tRAS(min)/2 + 1). No rounding up of the division operation.
Unit: Clocks
Value After Reset: 0xf
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG1</name>
          <description>Description: SDRAM Timing Register 1</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00080414</resetValue>
          <resetMask>0x001F1F7F</resetMask>
          <fields>
            <field>
              <name>T_XP</name>
              <description>Description: tXP: Minimum time after power-down exit to any operation. For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].
If C/A parity for DDR4 is used, set to (tXP+PL) instead. For configurations with MEMC_FREQ_RATIO=2, program this to (tXP/2) and round it up to the next integer value.
Units: Clocks
Value After Reset: 0x8
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD2PRE</name>
              <description>Description: tRTP: Minimum time from read to precharge of same bank.
DDR2: tAL + BL/2 + max(tRTP, 2) - 2
DDR3: tAL + max (tRTP, 4)
DDR4: Max of following two equations:	tAL + max (tRTP, 4) or,	RL + BL/2 - tRP.
mDDR: BL/2
LPDDR2: Depends on if it's LPDDR2-S2 or LPDDR2-S4: LPDDR2-S2: BL/2 + tRTP - 1.	LPDDR2-S4: BL/2 + max(tRTP,2) - 2.
LPDDR3: BL/2 + max(tRTP,4) - 4
For configurations with MEMC_FREQ_RATIO=2, 1T mode, divide the above value by 2. No rounding up.
For configurations with MEMC_FREQ_RATIO=2, 2T mode, divide the above value by 2 and add 1. No rounding up of division operation.
Unit: Clocks.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_RC</name>
              <description>Description: tRC: Minimum time between activates to same bank.
For configurations with MEMC_FREQ_RATIO=2, program this to (tRC/2) and round up to next integer value.
Unit: Clocks.
Value After Reset: 0x14
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG2</name>
          <description>Description: SDRAM Timing Register 2</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x0000060D</resetValue>
          <resetMask>0x00001F3F</resetMask>
          <fields>
            <field>
              <name>RD2WR</name>
              <description>Description: DDR2/3/mDDR: RL + BL/2 + 2 - WL DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL
LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL.
Minimum time from read command to write command. Include time for bus turnaround and all per-bank, per-rank, and global constraints.
Unit: Clocks. Where:
WL = write latency
BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM
RL = read latency = CAS latency
WR_PREAMBLE = write preamble. This is unique to DDR4.
For configurations with MEMC_FREQ_RATIO=2, divide the value calculated using the above equation by 2, and round it up to next integer.
Value After Reset: 0x6
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR2RD</name>
              <description>Description: DDR4: WL + BL/2 + tWTR_L Others: WL + BL/2 + tWTR
In DDR4, minimum time from write command to read command for same bank group. In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints.
Unit: Clocks. Where:
WL = write latency
BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM
tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification.
tWTR = internal write to read command delay. This comes directly from the SDRAM specification.
Add one extra cycle for LPDDR2/LPDDR3 operation.
For configurations with MEMC_FREQ_RATIO=2, divide the value calculated using the above equation by 2, and round it up to next integer.
Value After Reset: 0xd
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG3</name>
          <description>Description: SDRAM Timing Register 3</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x0000400C</resetValue>
          <resetMask>0x0003F3FF</resetMask>
          <fields>
            <field>
              <name>T_MRD</name>
              <description>Description: tMRD: Cycles between load mode commands. If MEMC_DDR3_OR_4 = 0, this parameter is also used to define the cycles between load mode command and following non-load mode command.
For configurations with MEMC_FREQ_RATIO=2, program this to (tMRD/2) and round it up to the next integer value.
If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_MOD</name>
              <description>Description: tMOD: Present if MEMC_DDR3_OR_4 = 1. Cycles between load mode command and following non-load mode command. This is required to be programmed even when a design that supports DDR3/4 is running in DDR2 mode.
If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead
Set to tMOD if MEMC_FREQ_RATIO=1, or tMOD/2 (rounded up to next integer) if MEMC_FREQ_RATIO=2. Note that if using RDIMM, depending on the PHY, it may be necessary to use a value of tMOD + 1 or (tMOD + 1)/2 to compensate for the extra cycle of latency applied to mode register writes by the RDIMM chip
Value After Reset: "(MEMC_DDR3_EN==1 || MEMC_DDR4_EN==1 ) ? 0xc : 0x0"
Exists: MEMC_DDR3==1 || MEMC_DDR4==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG4</name>
          <description>Description: SDRAM Timing Register 4</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x05040405</resetValue>
          <resetMask>0x1F070F1F</resetMask>
          <fields>
            <field>
              <name>T_RCD</name>
              <description>Description: tRCD - tAL: Minimum time from activate to read or write command to same bank.
For configurations with MEMC_FREQ_RATIO=2, program this to ((tRCD - tAL)/2) and round it up to the next integer value.
Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 in configurations with MEMC_FREQ_RATIO=2.
Unit: Clocks.
Value After Reset: 0x5
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CCD</name>
              <description>Description: DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads
or two writes.
For configurations with MEMC_FREQ_RATIO=2, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value.
Unit: clocks.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_RRD</name>
              <description>Description: DDR4: tRRD_L: Minimum time between activates from bank "a" to bank "b" for same bank group. Others: tRRD: Minimum time between activates from bank
"a" to bank "b"
For configurations with MEMC_FREQ_RATIO=2, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value.
Unit: Clocks.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_RP</name>
              <description>Description: tRP: Minimum time from precharge to activate of same bank.
For configurations with MEMC_FREQ_RATIO=2, program this to (tRP/2 + 1). No round up of the fraction.
Unit: Clocks.
Value After Reset: 0x5
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG5</name>
          <description>Description: SDRAM Timing Register 5</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x05050403</resetValue>
          <resetMask>0x0F0F3F1F</resetMask>
          <fields>
            <field>
              <name>T_CKSRX</name>
              <description>Description: This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.
Recommended settings:
mDDR: 1
LPDDR2: 2
LPDDR3: 2
DDR2: 1
DDR3: tCKSRX
DDR4: tCKSRX
For configurations with MEMC_FREQ_RATIO=2, program this to recommended value divided by two and round it up to next integer.
Value After Reset: 0x5
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CKSRE</name>
              <description>Description: This is the time after Self Refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.
Recommended settings:
mDDR: 0
LPDDR2: 2
LPDDR3: 2
DDR2: 1
DDR3: max (10 ns, 5 tCK)
DDR4: max (10 ns, 5 tCK)
For configurations with MEMC_FREQ_RATIO=2, program this to recommended value divided by two and round it up to next integer.
Value After Reset: 0x5
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CKESR</name>
              <description>Description: Minimum CKE low width for Self refresh entry to exit timing im memory clock cycles.
Recommended settings:
mDDR: tRFC
LPDDR2: tCKESR
LPDDR3: tCKESR
DDR2: tCKE
DDR3: tCKE + 1
DDR4: tCKE + 1
For configurations with MEMC_FREQ_RATIO=2, program this to recommended value divided by two and round it up to next integer.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CKE</name>
              <description>Description: Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.
LPDDR2/LPDDR3 mode: Set this to the larger of tCKE or tCKESR
Non-LPDDR2/non-LPDDR3 designs: Set this to tCKE value.
For configurations with MEMC_FREQ_RATIO=2, program this to (value described above)/2 and round it up to the next integer value.
Unit: Clocks.
Value After Reset: 0x3
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DRAMTMG8</name>
          <description>Description: SDRAM Timing Register 8</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x00004405</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>T_XS_DLL_X32</name>
              <description>Description: tXSDLL: Exit Self Refresh to commands requiring a locked DLL.
For configurations with MEMC_FREQ_RATIO=2, program this to the above value divided by 2 and round up to next integer value.
Unit: Multiples of 32 clocks.
Note: In LPDDR2/LPDDR3/Mobile DDR mode, t_xs_x32 and t_xs_dll_x32 must be set the same values derived from tXSR.
Value After Reset: 0x44
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_XS_X32</name>
              <description>Description: tXS: Exit Self Refresh to commands not requiring a locked DLL.
For configurations with MEMC_FREQ_RATIO=2, program this to the above value divided by 2 and round up to next integer value.
Unit: Multiples of 32 clocks.
Note: In LPDDR2/LPDDR3/Mobile DDR mode, t_xs_x32 and t_xs_dll_x32 must be set the same values derived from tXSR.
Value After Reset: 0x5
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ZQCTL0</name>
          <description>Description: ZQ Control Register 0</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <resetValue>0x02000040</resetValue>
          <resetMask>0xE3FF03FF</resetMask>
          <fields>
            <field>
              <name>DIS_AUTO_ZQ</name>
              <description>Description:
1 - Disable uMCTL2 generation of ZQCS command. Register reg_ddrc_zq_calib_short can be used instead to control ZQ calibration commands.
0 - Internally generate ZQCS commands based on ZQCTL1.t_zq_short_interval_x1024.
This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3 devices.
Value After Reset: 0x0
Exists: MEMC_DDR3==1 || MEMC_DDR4==1 || MEMC_LPDDR2==1</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_SRX_ZQCL</name>
              <description>Description:
1 - Disable issuing of ZQCL command at Self-Refresh exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 mode.
0 - Enable issuing of ZQCL command at Self-Refresh exit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 mode.
This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3 devices.
Value After Reset: 0x0
Exists: MEMC_DDR3==1 || MEMC_DDR4==1 || MEMC_LPDDR2==1</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZQ_RESISTOR_SHARED</name>
              <description>Description:
1 - Denotes that ZQ resistor is shared between ranks. Means ZQinit/ZQCL/ZQCS commands are sent to one rank at a time with tZQinit/tZQCL/tZQCS timing met between commands so that commands to different ranks do not overlap.
0 - ZQ resistor is not shared.
This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3 devices.
Value After Reset: 0x0
Exists: MEMC_DDR3==1 || MEMC_DDR4==1 || MEMC_LPDDR2==1</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_ZQ_LONG_NOP</name>
              <description>Description: tZQoper for DDR3/DDR4, tZQCL for LPDDR2/LPDDR3: Number of cycles of NOP required after a ZQCL (ZQ calibration long) command is issued to SDRAM.
For configurations with MEMC_FREQ_RATIO=2: DDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value.
LPDDR2/LPDDR3: program this to tZQCL/2 and round it up to the next integer value.
Unit: Clock cycles.
This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3 devices.
Value After Reset: 0x200
Exists: MEMC_DDR3==1 || MEMC_DDR4==1 || MEMC_LPDDR2==1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_ZQ_SHORT_NOP</name>
              <description>Description: tZQCS: Number of cycles of NOP required after a ZQCS (ZQ calibration short) command is issued to SDRAM.
For configurations with MEMC_FREQ_RATIO=2, program this to tZQCS/2 and round it up to the next integer value. Unit: Clock cycles.
This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3 devices.
Value After Reset: 0x40
Exists: MEMC_DDR3==1 || MEMC_DDR4==1 || MEMC_LPDDR2==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ZQCTL1</name>
          <description>Description: ZQ Control Register 1</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>T_ZQ_SHORT_INTERVAL_X1024</name>
              <description>Description: Average interval to wait between automatically issuing ZQCS (ZQ calibration short) commands to DDR3/DDR4/LPDDR2/LPDDR3 devices.
Meaningless, if ZQCTL0.dis_auto_zq=1. Unit: 1024 clock cycles.
This is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3 devices.
Value After Reset: 0x100
Exists: MEMC_DDR3==1 || MEMC_DDR4==1 || MEMC_LPDDR2==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ZQSTAT</name>
          <description>Description: ZQ Status Register</description>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>ZQ_RESET_BUSY</name>
              <description>Description: SoC core may initiate a ZQ Reset operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQ Reset request. It goes low when the ZQ Reset command is issued to the SDRAM and the associated NOP period is over. It is recommended not to perform ZQ Reset commands when this signal is high.
0 - Indicates that the SoC core can initiate a ZQ Reset operation
1 - Indicates that ZQ Reset operation is in progress
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFITMG0</name>
          <description>Description: DFI Timing Register 0</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <resetValue>0x07020002</resetValue>
          <resetMask>0x1FBFBF3F</resetMask>
          <fields>
            <field>
              <name>DFI_T_CTRL_DELAY</name>
              <description>Description: Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM, depending on the PHY, it may be necessary to increment this parameter by 1. This is to compensate for the extra cycle of latency through the RDIMM
Value After Reset: 0x7
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_RDDATA_USE_SDR</name>
              <description>Description: Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR or SDR values Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of SDR or HDR clock cycles:
0 in terms of HDR clock cycles
1 in terms of SDR clock cycles
Refer to PHY specification for correct value.
Value After Reset: 0x0
Exists: MEMC_FREQ_RATIO==2</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_T_RDDATA_EN</name>
              <description>Description: Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value.
This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM, it may be necessary to use the value (CL + 1) in the calculation of trddata_en. This is to compensate for the extra cycle of latency through the RDIMM.
Unit: Clocks
Value After Reset: 0x2
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_WRDATA_USE_SDR</name>
              <description>Description: Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR or SDR values Selects whether value in DFITMG0.dfi_tphy_wrlat is in terms of SDR or HDR clock cycles Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of SDR or HDR clock cycles
0 in terms of HDR clock cycles
1 in terms of SDR clock cycles
Refer to PHY specification for correct value.
Value After Reset: 0x0
Exists: MEMC_FREQ_RATIO==2</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_TPHY_WRDATA</name>
              <description>Description: Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal. This corresponds to the DFI timing parameter tphy_wrdata. Refer to PHY specification for correct value. Note, max supported value is 8.
Unit: Clocks
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_TPHY_WRLAT</name>
              <description>Description: Write latency
Number of clocks from the write command to write data enable (dfi_wrdata_en). This corresponds to the DFI timing parameter tphy_wrlat. The minimum supported value is as follows:
0 for configurations with MEMC_WL0 = 1
1 for configurations with MEMC_WL0 = 0
Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM, it may be necessary to use the value (CL + 1) in the calculation of tphy_wrlat. This is to compensate for the extra cycle of latency through the RDIMM.
Value After Reset: 0x2
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFITMG1</name>
          <description>Description: DFI Timing Register 1</description>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <resetValue>0x00000404</resetValue>
          <resetMask>0x001F0F0F</resetMask>
          <fields>
            <field>
              <name>DFI_T_WRDATA_DELAY</name>
              <description>Description: Specifies the number of DFI clocks between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus. This corresponds to the DFI timing parameter twrdata_delay. Refer to PHY specification for correct value. For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM). Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_sdr=1, add 1 to the value.
Unit: Clocks
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_T_DRAM_CLK_DISABLE</name>
              <description>Description: Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY- DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_T_DRAM_CLK_ENABLE</name>
              <description>Description: Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFILPCFG0</name>
          <description>Description: DFI Low Power Configuration Register 0</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <resetValue>0x07000000</resetValue>
          <resetMask>0x0F00F1F1</resetMask>
          <fields>
            <field>
              <name>DFI_TLP_RESP</name>
              <description>Description: Setting for DFI's tlp_resp time.
Same value is used for both Power Down, Self Refresh, Deep Power Down and Maximum Power Saving modes. DFI 2.1 specification onwards, recommends using a fixed
value of 7 always.
Value After Reset: 0x7
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_LP_WAKEUP_SR</name>
              <description>Description: Value to drive on dfi_lp_wakeup signal when Self Refresh mode is entered.
Determines the DFI's tlp_wakeup time:
0x0 - 16 cycles
0x1 - 32 cycles
0x2 - 64 cycles
0x3 - 128 cycles
0x4 - 256 cycles
0x5 - 512 cycles
0x6 - 1024 cycles
0x7 - 2048 cycles
0x8 - 4096 cycles
0x9 - 8192 cycles
0xA - 16384 cycles
0xB - 32768 cycles
0xC - 65536 cycles
0xD - 131072 cycles
0xE - 262144 cycles
0xF - Unlimited Value After Reset: 0x0 Exists: Always</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_LP_EN_SR</name>
              <description>Description: Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.
0 - Disabled
1 - Enabled
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_LP_WAKEUP_PD</name>
              <description>Description: Value to drive on dfi_lp_wakeup signal when Power Down mode is entered.
Determines the DFI's tlp_wakeup time:
0x0 - 16 cycles
0x1 - 32 cycles
0x2 - 64 cycles
0x3 - 128 cycles
0x4 - 256 cycles
0x5 - 512 cycles
0x6 - 1024 cycles
0x7 - 2048 cycles
0x8 - 4096 cycles
0x9 - 8192 cycles
0xA - 16384 cycles
0xB - 32768 cycles
0xC - 65536 cycles
0xD - 131072 cycles
0xE - 262144 cycles
0xF - Unlimited Value After Reset: 0x0 Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_LP_EN_PD</name>
              <description>Description: Enables DFI Low Power interface handshaking during Power Down Entry/Exit.
0 - Disabled
1 - Enabled
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFIUPD0</name>
          <description>Description: DFI Update Register 0</description>
          <addressOffset>0x1a0</addressOffset>
          <size>32</size>
          <resetValue>0x00400003</resetValue>
          <resetMask>0x83FF03FF</resetMask>
          <fields>
            <field>
              <name>DIS_AUTO_CTRLUPD</name>
              <description>Description: When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The core must issue the dfi_ctrlupd_req signal using register reg_ddrc_ctrlupd. This register field is changeable on the fly.
When '0', uMCTL2 issues dfi_ctrlupd_req periodically.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_T_CTRLUP_MAX</name>
              <description>Description: Specifies the maximum number of clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40.
Unit: Clocks
Value After Reset: 0x40
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_T_CTRLUP_MIN</name>
              <description>Description: Specifies the minimum number of clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time. If the PHY does not respond, the uMCTL2 will de-assert dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x3.
Unit: Clocks
Value After Reset: 0x3
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFIUPD1</name>
          <description>Description: DFI Update Register 1</description>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00FF00FF</resetMask>
          <fields>
            <field>
              <name>DFI_T_CTRLUPD_INTERVAL_MIN_X1024</name>
              <description>Description: This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle.
Unit: 1024 clocks Value After Reset: 0x0
 Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_T_CTRLUPD_INTERVAL_MAX_X1024</name>
              <description>Description: This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors.
Updates are required to maintain calibration over PVT, but frequent updates may impact performance.
Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024.
Unit: 1024 clocks Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFIUPD2</name>
          <description>Description: DFI Update Register 2</description>
          <addressOffset>0x1a8</addressOffset>
          <size>32</size>
          <resetValue>0x80100010</resetValue>
          <resetMask>0x8FFF0FFF</resetMask>
          <fields>
            <field>
              <name>DFI_PHYUPD_EN</name>
              <description>Description: Enables the support for acknowledging PHY- initiated updates:
0 - Disabled
1 - Enabled
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_PHYUPD_TYPE1</name>
              <description>Description: Specifies the maximum number of DFI clock cycles that the dfi_phyupd_req signal may remain asserted after the assertion of the dfi_phyupd_ack signal for dfi_phyupd_type = 2'b01. The dfi_phyupd_req signal may de-assert at any cycle after the assertion of the dfi_phyupd_ack signal.
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_PHYUPD_TYPE0</name>
              <description>Description: Specifies the maximum number of DFI clock cycles that the dfi_phyupd_req signal may remain asserted after the assertion of the dfi_phyupd_ack signal for dfi_phyupd_type = 2'b00. The dfi_phyupd_req signal may de-assert at any cycle after the assertion of the dfi_phyupd_ack signal.
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFIUPD3</name>
          <description>Description: DFI Update Register 3</description>
          <addressOffset>0x1ac</addressOffset>
          <size>32</size>
          <resetValue>0x00100010</resetValue>
          <resetMask>0x0FFF0FFF</resetMask>
          <fields>
            <field>
              <name>DFI_PHYUPD_TYPE3</name>
              <description>Description: Specifies the maximum number of DFI clock cycles that the dfi_phyupd_req signal may remain asserted after the assertion of the dfi_phyupd_ack signal for dfi_phyupd_type = 2'b11. The dfi_phyupd_req signal may de-assert at any cycle after the assertion of the dfi_phyupd_ack signal.
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_PHYUPD_TYPE2</name>
              <description>Description: Specifies the maximum number of DFI clock cycles that the dfi_phyupd_req signal may remain asserted after the assertion of the dfi_phyupd_ack signal for dfi_phyupd_type = 2'b10. The dfi_phyupd_req signal may de-assert at any cycle after the assertion of the dfi_phyupd_ack signal.
Value After Reset: 0x10
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFIMISC</name>
          <description>Description: DFI Miscellaneous Control Register</description>
          <addressOffset>0x1b0</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>DFI_INIT_COMPLETE_EN</name>
              <description>Description: PHY initialization complete enable signal. When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFITMG2</name>
          <description>Description: DFI Timing Register 2</description>
          <addressOffset>0x1b4</addressOffset>
          <size>32</size>
          <resetValue>0x00000202</resetValue>
          <resetMask>0x00003F3F</resetMask>
          <fields>
            <field>
              <name>DFI_TPHY_RDCSLAT</name>
              <description>Description: Number of clocks between when a read command is sent on the DFI control interface and when the associated dfi_rddata_cs_n signal is asserted. This corresponds to the DFI timing parameter tphy_rdcslat. Refer to PHY specification for correct value.
Value After Reset: 0x2
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DFI_TPHY_WRCSLAT</name>
              <description>Description: Number of clocks between when a write command is sent on the DFI control interface and when the associated dfi_wrdata_cs_n signal is asserted. This corresponds to the DFI timing parameter tphy_wrcslat. The minimum supported value is as follows:
0 for configurations with MEMC_WL0 = 1
1 for configurations with MEMC_WL0 = 0 Refer to PHY specification for correct value. Value After Reset: 0x2
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP0</name>
          <description>Description: Address Map Register 0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_CS_BIT0</name>
              <description>Description: Selects the HIF address bit used as rank address bit 0.
Valid Range: 0 to 27, and 31
Internal Base: 6
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 31, rank address bit 0 is set to 0.
Value After Reset: 0x0
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP1</name>
          <description>Description: Address Map Register 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x001F1F1F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_BANK_B2</name>
              <description>Description: Selects the HIF address bit used as bank address bit 2.
Valid Range: 0 to 29 and 31
Internal Base: 4
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 31, bank address bit 2 is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_BANK_B1</name>
              <description>Description: Selects the HIF address bits used as bank address bit 1.
Valid Range: 0 to 30
Internal Base: 3
The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_BANK_B0</name>
              <description>Description: Selects the HIF address bits used as bank address bit 0.
Valid Range: 0 to 30
Internal Base: 2
The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP2</name>
          <description>Description: Address Map Register 2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F0F0F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_COL_B5</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 5 (if MEMC_BURST_LENGTH = 4) or 6 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 6 (if MEMC_BURST_LENGTH = 4) or 7 (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 7 (if MEMC_BURST_LENGTH = 4) or 8 (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7, and 15
Internal Base: 5
The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B4</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 4 (if MEMC_BURST_LENGTH = 4) or 5 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 5 (if MEMC_BURST_LENGTH = 4) or 6 (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 6 (if MEMC_BURST_LENGTH = 4) or 7 (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7, and 15
Internal Base: 4
The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B3</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 3 (if MEMC_BURST_LENGTH = 4) or 4 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 4 (if MEMC_BURST_LENGTH = 4) or 5 (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 5 (if MEMC_BURST_LENGTH = 4) or 6 (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7
Internal Base: 3
The selected HIF address bit is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B2</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 2 (if MEMC_BURST_LENGTH = 4) or 3 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 3 (if MEMC_BURST_LENGTH = 4) or 4 (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 4 (if MEMC_BURST_LENGTH = 4) or 5 (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7
Internal Base: 2
The selected HIF address bit is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP3</name>
          <description>Description: Address Map Register 3</description>
          <addressOffset>0x20c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F0F0F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_COL_B9</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 9 (if MEMC_BURST_LENGTH = 4) or 11 (10 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 8)
Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 4) or 13 (11 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 8).
(Column address bit 11 in LPDDR2/LPDDR3 mode) Quarter bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode) (if
MEMC_BURST_LENGTH = 4) or UNUSED (if
MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7, and 15
Internal Base: 9
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, this column address bit is set to 0.
Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.
In LPDDR2/LPDDR3, there is a dedicated bit for auto- precharge in the CA bus and hence column bit 10 is used. Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B8</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 8 (if MEMC_BURST_LENGTH = 4) or 9 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 9 (if MEMC_BURST_LENGTH = 4) or 11 (10 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 4) or 13 (11 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7, and 15
Internal Base: 8
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, this column address bit is set to 0.
Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.
In LPDDR2/LPDDR3, there is a dedicated bit for auto- precharge in the CA bus and hence column bit 10 is used. Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B7</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 7 (if MEMC_BURST_LENGTH = 4) or 8 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 8 (if MEMC_BURST_LENGTH = 4) or 9 (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 9 (if MEMC_BURST_LENGTH = 4) or 11 (10 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7, and 15
Internal Base: 7
The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.
Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge and hence no source address bit can be mapped to column address bit 10.
In LPDDR2/LPDDR3, there is a dedicated bit for auto- precharge in the CA bus and hence column bit 10 is used. Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B6</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 6 (if MEMC_BURST_LENGTH = 4) or 7 (if
MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 7 (if MEMC_BURST_LENGTH = 4) or 8 (if MEMC_BURST_LENGTH = 8).
Quarter bus width mode: Selects the HIF address bit used as column address bit 8 (if MEMC_BURST_LENGTH = 4) or 9 (if MEMC_BURST_LENGTH = 8).
Valid Range: 0 to 7, and 15
Internal Base: 6
The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP4</name>
          <description>Description: Address Map Register 4</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000F0F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_COL_B11</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 4) or UNUSED (if MEMC_BURST_LENGTH = 8).
Half bus width mode: Unused. To make it unused, this should be tied to 4'hF.
Quarter bus width mode: Unused. To make it unused, this must be tied to 4'hF.
Valid Range: 0 to 7, and 15
Internal Base: 11
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, this column address bit is set to 0.
Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.
In LPDDR2/LPDDR3, there is a dedicated bit for auto- precharge in the CA bus and hence column bit 10 is used. Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_COL_B10</name>
              <description>Description: Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 4) or 13 (11 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 8).
Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode) (if MEMC_BURST_LENGTH = 4) or UNUSED (if MEMC_BURST_LENGTH = 8)
Quarter bus width mode: UNUSED. To make it unused, this must be tied to 4'hF.
Valid Range: 0 to 7, and 15
Internal Base: 10
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, this column address bit is set to 0.
Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10.
In LPDDR2/LPDDR3, there is a dedicated bit for auto- precharge in the CA bus and hence column bit 10 is used. Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP5</name>
          <description>Description: Address Map Register 5</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F0F0F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_ROW_B11</name>
              <description>Description: Selects the HIF address bit used as row address bit 11.
Valid Range: 0 to 11, and 15
Internal Base: 17
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, row address bit 11 is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_ROW_B2_10</name>
              <description>Description: Selects the HIF address bits used as row address bits 2 to 10.
Valid Range: 0 to 11
Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc increasing to 16 (for row
address bit 10)
The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_ROW_B1</name>
              <description>Description: Selects the HIF address bits used as row address bit 1.
Valid Range: 0 to 11
Internal Base: 7
The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_ROW_B0</name>
              <description>Description: Selects the HIF address bits used as row address bit 0.
Valid Range: 0 to 11
Internal Base: 6
The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDRMAP6</name>
          <description>Description: Address Map Register 6</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0F0F0F0F</resetMask>
          <fields>
            <field>
              <name>ADDRMAP_ROW_B15</name>
              <description>Description: Selects the HIF address bit used as row address bit 15.
Valid Range: 0 to 11, and 15
Internal Base: 21
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, row address bit 15 is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_ROW_B14</name>
              <description>Description: Selects the HIF address bit used as row address bit 14.
Valid Range: 0 to 11, and 15
Internal Base: 20
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, row address bit 14 is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_ROW_B13</name>
              <description>Description: Selects the HIF address bit used as row address bit 13.
Valid Range: 0 to 11, and 15
Internal Base: 19
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, row address bit 13 is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDRMAP_ROW_B12</name>
              <description>Description: Selects the HIF address bit used as row address bit 12.
Valid Range: 0 to 11, and 15
Internal Base: 18
The selected HIF address bit is determined by adding the internal base to the value of this field.
If set to 15, row address bit 12 is set to 0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ODTCFG</name>
          <description>Description: ODT Configuration Register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <resetValue>0x04000400</resetValue>
          <resetMask>0x0F1F0F7C</resetMask>
          <fields>
            <field>
              <name>WR_ODT_HOLD</name>
              <description>Description: Cycles to hold ODT for a write command. The minimum supported value is 2. DDR2/DDR3/DDR4
BL8 - 0x6
BL4 - 0x4
LPDDR3 - RU(tDQSSmax/tCK) + 4
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_ODT_DELAY</name>
              <description>Description: The delay, in clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. ODT is used only in DDR2, DDR3, DDR4 and LPDDR3 designs.
Recommended values:
DDR2
If (CWL + AL &lt; 3), then 0.
If (CWL + AL &gt;= 3), then (CWL + AL - 3) DDR3 - 0
DDR4 - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)
LPDDR3 - (CWL - RU(tODToffmax/tCK))
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_ODT_HOLD</name>
              <description>Description: Cycles to hold ODT for a read command. The minimum supported value is 2. Recommended values: DDR2/DDR3
BL8 - 0x6
BL4 - 0x4
DDR4 - 0x6, but needs to be reduced to 0x5 in CAL mode to avoid overlap of read and write ODT LPDDR3 - RU(tDQSCKmax/tCK) + 4 + 1
Value After Reset: 0x4
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_ODT_DELAY</name>
              <description>Description: The delay, in clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. ODT is used only in DDR2, DDR3, DDR4 and LPDDR3 designs.
Recommended values:
DDR2
If (CL + AL &lt; 4), then 0.
If (CL + AL &gt;= 4), then (CL + AL - 4) DDR3
(CL - CWL) DDR4
If CAL mode is enabled, CL - CWL + DFITMG1.dfi_t_cmd_lat
If CAL mode is not enabled, CL - CWL -1, or 0 if CL - CWL &lt; 1
LPDDR3, MEMC_FREQ_RATIO=2
CL - RU(tODToffmax/tCK)) Value After Reset: 0x0 Exists: Always</description>
              <bitOffset>2</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ODTMAP</name>
          <description>Description: ODT/Rank Map Register</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <resetValue>0x00002211</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>RANK1_RD_ODT</name>
              <description>Description: Indicates which remote ODTs must be turned on during a read from rank 1.
Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here.
Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.
For each rank, set its bit to 1 to enable its ODT.
Present only in configurations that have 2 or more ranks Value After Reset: "(MEMC_NUM_RANKS&gt;1) ? 0x2 : 0x0" Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANK1_WR_ODT</name>
              <description>Description: Indicates which remote ODTs must be turned on during a write to rank 1.
Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here.
Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.
For each rank, set its bit to 1 to enable its ODT.
Present only in configurations that have 2 or more ranks Value After Reset: "(MEMC_NUM_RANKS&gt;1) ? 0x2 : 0x0" Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANK0_RD_ODT</name>
              <description>Description: Indicates which remote ODTs must be turned on during a read from rank 0.
Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here.
Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.
For each rank, set its bit to 1 to enable its ODT.
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANK0_WR_ODT</name>
              <description>Description: Indicates which remote ODTs must be turned on during a write to rank 0.
Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here.
Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.
For each rank, set its bit to 1 to enable its ODT.
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCHED</name>
          <description>Description: Scheduler Control Register</description>
          <addressOffset>0x250</addressOffset>
          <size>32</size>
          <resetValue>0x00000805</resetValue>
          <resetMask>0x7FFF3F07</resetMask>
          <fields>
            <field>
              <name>RDWR_IDLE_GAP</name>
              <description>Description: When the preferred transaction store is empty for these many clock cycles, switch to the alternate transaction store if it is non-empty.
The read transaction store (both high and low priority) is the default preferred transaction store and the write transaction store is the alternative store.
When prefer write over read is set this is reversed.
0x0 is a legal value for this register. When set to 0x0, the transaction store switching will happen immediately when the switching conditions become true.
FOR PERFORMANCE ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GO2CRITICAL_HYSTERESIS</name>
              <description>Description: UNUSED Value After Reset: 0x0 Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPR_NUM_ENTRIES</name>
              <description>Description: Number of entries in the low priority transaction store is this value + 1.
(MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries available for the high priority transaction store.
Setting this to maximum value allocates all entries to low priority transaction store.
Setting this to 0 allocates 1 entry to low priority transaction store and the rest to high priority transaction store.
Note: In ECC configurations, the numbers of write and low priority read credits issued is one less than in the non-ECC case. One entry each is reserved in the write and low- priority read CAMs for storing the RMW requests arising out of single bit error correction RMW operation.
Value After Reset: "MEMC_NO_OF_ENTRY/2"
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PAGECLOSE</name>
              <description>Description: If true, bank is kept open only until there are page hit transactions available in the CAM to that bank. The last read or write command in the CAM with a bank and page hit will be executed with auto-precharge if SCHED1.pageclose_timer=0. Even if this register set to 1 and SCHED1.pageclose_timer is set to 0, explicit precharge (and not auto-precharge) may be issued in some cases where there is a mode switch between Write and Read or between LPR and HPR. The Read and Write commands that are executed as part of the ECC scrub requests are also executed without auto-precharge. If false, the bank remains open until there is a need to close it (to open a different page, or for page timeout or refresh timeout) - also known as open page policy. The open page policy can be overridden by setting the per-command-autopre bit on the HIF interface (co_ih_rxcmd_autopre).
The pageclose feature provids a midway between Open and Close page policies.
FOR PERFORMANCE ONLY.
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PREFER_WRITE</name>
              <description>Description: If set then the bank selector prefers writes over reads.
FOR DEBUG ONLY.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_LOW_PRI_N</name>
              <description>Description: Active low signal. When asserted ('0'), all incoming transactions are forced to low priority. This implies that all High Priority Read (HPR) and Variable Priority Read commands (VPR) will be treated as Low Priority Read (LPR) commands. On the write side, all Variable Priority Write (VPW) commands will be treated as Normal Priority Write (NPW) commands. Forcing the incoming transactions to low priority implicitly turns off Bypass path for read commands.
FOR PERFORMANCE ONLY.
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCHED1</name>
          <description>Description: Scheduler Control Register 1</description>
          <addressOffset>0x254</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>PAGECLOSE_TIMER</name>
              <description>Description: This field works in conjunction with SCHED.pageclose. It only has meaning if SCHED.pageclose==1.
If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read or write command in the CAM with a bank and page hit. Note, sometimes an explicit precharge is scheduled instead of the auto-precharge. See SCHED.pageclose for details of when this may happen.
If SCHED.pageclose==1 and pageclose_timer&gt;0, then an auto-precharge is not scheduled for last read or write command in the CAM with a bank and page hit. Instead, a timer is started, with pageclose_timer as the initial value. There is a timer on a per bank basis. The timer decrements unless the next read or write in the CAM to a bank is a page hit. It gets reset to pageclose_timer value if the next read or write in the CAM to a bank is a page hit. Once the timer has reached zero, an explcit precharge will be attempted to be scheduled.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERFHPR1</name>
          <description>Description: High Priority Read CAM Register 1</description>
          <addressOffset>0x25c</addressOffset>
          <size>32</size>
          <resetValue>0x0F000001</resetValue>
          <resetMask>0xFF00FFFF</resetMask>
          <fields>
            <field>
              <name>HPR_XACT_RUN_LENGTH</name>
              <description>Description: Number of transactions that are serviced once the HPR queue goes critical is the smaller of:
This number
Number of transactions available Unit: Transaction.
FOR PERFORMANCE ONLY.
Value After Reset: 0xf
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HPR_MAX_STARVE</name>
              <description>Description: Number of clocks that the HPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies.
Unit: Clock cycles.
FOR PERFORMANCE ONLY.
Value After Reset: 0x1
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERFLPR1</name>
          <description>Description: Low Priority Read CAM Register 1</description>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <resetValue>0x0F00007F</resetValue>
          <resetMask>0xFF00FFFF</resetMask>
          <fields>
            <field>
              <name>LPR_XACT_RUN_LENGTH</name>
              <description>Description: Number of transactions that are serviced once the LPR queue goes critical is the smaller of:
This number
Number of transactions available. Unit: Transaction.
FOR PERFORMANCE ONLY.
Value After Reset: 0xf
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPR_MAX_STARVE</name>
              <description>Description: Number of clocks that the LPR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies.
Unit: Clock cycles.
FOR PERFORMANCE ONLY.
Value After Reset: 0x7f
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERFWR1</name>
          <description>Description: Write CAM Register 1</description>
          <addressOffset>0x26c</addressOffset>
          <size>32</size>
          <resetValue>0x0F00007F</resetValue>
          <resetMask>0xFF00FFFF</resetMask>
          <fields>
            <field>
              <name>W_XACT_RUN_LENGTH</name>
              <description>Description: Number of transactions that are serviced once the WR queue goes critical is the smaller of:
This number
Number of transactions available. Unit: Transaction.
FOR PERFORMANCE ONLY.
Value After Reset: 0xf
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>W_MAX_STARVE</name>
              <description>Description: Number of clocks that the WR queue can be starved before it goes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies.
Unit: Clock cycles.
FOR PERFORMANCE ONLY.
Value After Reset: 0x7f
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERFVPR1</name>
          <description>Description: Variable Priority Read CAM Register 1</description>
          <addressOffset>0x274</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>VPR_TIMEOUT_RANGE</name>
              <description>Description: Indicates the range of the timeout value that is used for grouping the expired VPR commands in the CAM in DDRC. For example, if the register value is set to 0xF, then the priorities of all the VPR commands whose timeout counters are 15 or below will be considered as expired-VPR commands when the timeout value of any of the VPR commands reach 0. The expired-VPR commands, when present, are given higher priority than HPR commands. The VPR commands are expected to consist of largely page hit traffic and by grouping them together the bus utilization is expected to increase. This register applies to transactions inside the DDRC only.
The Max value for this register is 0x7FF and the Min value is 0x0.
When programmed to the Max value of 0x7FF, all the VPR commands that come in to DDRC will time-out right-away and will be considered as expired-VPR.
When programmed to the Min value of 0x0, the timer of each command would have to reach a value of 0 before it will be considered as expired-VPR.
Unit: Clock cycles.
FOR PERFORMANCE ONLY.
Value After Reset: 0x0
Exists: UMCTL2_VPR_EN==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PERFVPW1</name>
          <description>Description: Variable Priority Write CAM Register 1</description>
          <addressOffset>0x278</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>VPW_TIMEOUT_RANGE</name>
              <description>Description: Indicates the range of the timeout value that is used for grouping the expired VPW commands in the CAM in DDRC. For example, if the register value is set to 0xF, then the priorities of all the VPW commands whose timeout counters are 15 or below will be considered as expired-VPW commands when the timeout value of any of the VPW commands reach 0. The expired-VPW commands, when present, are given higher priority than normal Write commands. The VPW commands are expected to consist of largely page hit traffic and by grouping them together the bus utilization is expected to increase. This register applies to transactions inside the DDRC only.
The Max value for this register is 0x7FF and the Min value is 0x0.
When programmed to the Max value of 0x7FF, all the VPW commands that come in to DDRC will time-out right-away and will be considered as expired-VPW.
When programmed to the Min value of 0x0, the timer of each command would have to reach a value of 0 before it will be considered as expired-VPW.
Unit: Clock cycles.
FOR PERFORMANCE ONLY.
Value After Reset: 0x0
Exists: UMCTL2_VPW_EN==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBG0</name>
          <description>Description: Debug Register 0</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000017</resetMask>
          <fields>
            <field>
              <name>DIS_COLLISION_PAGE_OPT</name>
              <description>Description: When this is set to '0', auto-precharge is disabled for the flushed command in a collision case. Collision cases are write followed by read to same address, read followed by write to same address, or write followed by write to same address with DBG0.dis_wc bit = 1 (where same address comparisons exclude the two address bits representing critical word).
FOR DEBUG ONLY.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_ACT_BYPASS</name>
              <description>Description: Only present in designs supporting activate bypass.
When 1, disable bypass path for high priority read activates FOR DEBUG ONLY.
Value After Reset: 0x0
Exists: MEMC_BYPASS==1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RD_BYPASS</name>
              <description>Description: Only present in designs supporting read bypass.
When 1, disable bypass path for high priority read page hits FOR DEBUG ONLY.
Value After Reset: 0x0
Exists: MEMC_BYPASS==1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_WC</name>
              <description>Description: When 1, disable write combine. FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBG1</name>
          <description>Description: Debug Register 1</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>DIS_HIF</name>
              <description>Description: When 1, uMCTL2 asserts the HIF command ih_co_stall. uMCTL2 will ignore the co_ih_rxcmd_valid and all other associated request signals.
This bit is intended to be switched on-the-fly.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_DQ</name>
              <description>Description: When 1, uMCTL2 will not de-queue any transactions from the CAM. Bypass is also disabled. All transactions are queued in the CAM. No reads or writes are issued to SDRAM as long as this is asserted.
This bit may be used to prevent reads or writes being issued by the uMCTL2, which makes it safe to modify certain register fields associated with reads and writes (see User Guide for details). After setting this bit, it is strongly recommended to poll DBGCAM.wr_data_pipeline_empty and DBGCAM.rd_data_pipeline_empty, before making changes to any registers which affect reads and writes. This will ensure that the relevant logic in the DDRC is idle.
This bit is intended to be switched on-the-fly.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGCAM</name>
          <description>Description: CAM Debug Register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x377F7F7F</resetMask>
          <fields>
            <field>
              <name>WR_DATA_PIPELINE_EMPTY</name>
              <description>Description: This bit indicates that the write data pipeline on the DFI interface is empty. This register is intended to be polled after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_DATA_PIPELINE_EMPTY</name>
              <description>Description: This bit indicates that the read data pipeline on the DFI interface is empty. This register is intended to be polled after setting DBG1.dis_dq, to ensure that all remaining commands/data have completed.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_WR_Q_EMPTY</name>
              <description>Description: When 1, all the Write command queues and Write data buffers inside DDRC are empty. This register is to be used for debug purpose.
An example use-case scenario: When Controller enters Self- Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time.
FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_RD_Q_EMPTY</name>
              <description>Description: When 1, all the Read command queues and Read data buffers inside DDRC are empty. This register is to be used for debug purpose.
An example use-case scenario: When Controller enters Self- Refresh using the Low-Power entry sequence, Controller is expected to have executed all the commands in its queues and the write and read data drained. Hence this register should be 1 at that time.
FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_STALL</name>
              <description>Description: Stall FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_W_Q_DEPTH</name>
              <description>Description: Write queue depth
Note: The width of this field is dependent on log(MEMC_NO_OF_ENTRY+1). For example, if CAM depth
= 32, then register width is 6 bits and bit 22 is reserved. FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_LPR_Q_DEPTH</name>
              <description>Description: Low priority read queue depth Note: The width of this field is dependent on
log(MEMC_NO_OF_ENTRY+1). For example, if CAM depth
= 32, then register width is 6 bits and bit 14 is reserved FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_HPR_Q_DEPTH</name>
              <description>Description: High priority read queue depth Note: The width of this field is dependent on
log(MEMC_NO_OF_ENTRY+1). For example, if CAM depth
= 32, then register width is 6 bits and bit 6 is reserved FOR DEBUG ONLY
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGCMD</name>
          <description>Description: Command Debug Register</description>
          <addressOffset>0x30c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000033</resetMask>
          <fields>
            <field>
              <name>CTRLUPD</name>
              <description>Description: Setting this register bit to 1 indicates to the uMCTL2 to issue a dfi_ctrlupd_req to the PHY. When this request is stored in uMCTL2, the bit is automatically cleared. This operation must only be performed when DFIUPD0.dis_auto_ctrlupd=1.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZQ_CALIB_SHORT</name>
              <description>Description: Setting this register bit to 1 indicates to the uMCTL2 to issue a ZQCS (ZQ calibration short) command to the SDRAM. When this request is stored in uMCTL2, the bit is automatically cleared. This operation can be performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this register bit if in Init operating mode. This register bit is ignored when in Self-Refresh and Deep power-down operating modes.
Value After Reset: 0x0
Exists: MEMC_DDR3_OR_4_OR_LPDDR2==1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANK1_REFRESH</name>
              <description>Description: Setting this register bit to 1 indicates to the uMCTL2 to issue a refresh to rank 1. When this request is stored in uMCTL2, the bit is automatically cleared. This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode.
Value After Reset: 0x0
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANK0_REFRESH</name>
              <description>Description: Setting this register bit to 1 indicates to the uMCTL2 to issue a refresh to rank 0. When this request is stored in uMCTL2, the bit is automatically cleared. This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGSTAT</name>
          <description>Description: Status Debug Register</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000033</resetMask>
          <fields>
            <field>
              <name>CTRLUPD_BUSY</name>
              <description>Description: SoC core may initiate a ctrlupd operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ctrlupd request. It goes low when the ctrlupd operation is initiated in uMCTL2. It is recommended not to perform ctrlupd operations when this signal is high.
0 - Indicates that the SoC core can initiate a ctrlupd operation
1 - Indicates that ctrlupd operation has not been initiated yet in uMCTL2
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ZQ_CALIB_SHORT_BUSY</name>
              <description>Description: SoC core may initiate a ZQCS (ZQ calibration short) operation only if this signal is low. This signal goes high in the clock after the uMCTL2 accepts the ZQCS request. It goes low when the ZQCS operation is initiated in uMCTL2. It is recommended not to perform ZQCS operations when this signal is high.
0 - Indicates that the SoC core can initiate a ZQCS operation
1 - Indicates that ZQCS operation has not been initiated yet in uMCTL2
Value After Reset: 0x0
Exists: MEMC_DDR3_OR_4_OR_LPDDR2==1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RANK1_REFRESH_BUSY</name>
              <description>Description: SoC core may initiate a rank1_refresh operation (refresh operation to rank 1) only if this signal is low. This signal goes high in the clock after DBGCMD.rank1_refresh is set to one. It goes low when the rank1_refresh operation is stored in uMCTL2. It is recommended not to perform rank1_refresh operations when this signal is high.
0 - Indicates that the SoC core can initiate a rank1_refresh operation
1 - Indicates that rank1_refresh operation has not been stored yet in uMCTL2
Value After Reset: 0x0
Exists: MEMC_NUM_RANKS&gt;1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RANK0_REFRESH_BUSY</name>
              <description>Description: SoC core may initiate a rank0_refresh operation (refresh operation to rank 0) only if this signal is low. This signal goes high in the clock after DBGCMD.rank0_refresh is set to one. It goes low when the rank0_refresh operation is stored in uMCTL2. It is recommended not to perform rank0_refresh operations when this signal is high.
0 - Indicates that the SoC core can initiate a rank0_refresh operation
1 - Indicates that rank0_refresh operation has not been stored yet in uMCTL2
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSTAT</name>
          <description>Description: Port Status Register</description>
          <addressOffset>0x3fc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WR_PORT_BUSY_15</name>
              <description>Description: Indicates if there are outstanding writes for port 15.
Value After Reset: 0x0
Exists: UMCTL2_PORT_15==1</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_14</name>
              <description>Description: Indicates if there are outstanding writes for port 14.
Value After Reset: 0x0
Exists: UMCTL2_PORT_14==1</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_13</name>
              <description>Description: Indicates if there are outstanding writes for port 13.
Value After Reset: 0x0
Exists: UMCTL2_PORT_13==1</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_12</name>
              <description>Description: Indicates if there are outstanding writes for port 12.
Value After Reset: 0x0
Exists: UMCTL2_PORT_12==1</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_11</name>
              <description>Description: Indicates if there are outstanding writes for port 11.
Value After Reset: 0x0
Exists: UMCTL2_PORT_11==1</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_10</name>
              <description>Description: Indicates if there are outstanding writes for port 10.
Value After Reset: 0x0
Exists: UMCTL2_PORT_10==1</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_9</name>
              <description>Description: Indicates if there are outstanding writes for port 9.
Value After Reset: 0x0
Exists: UMCTL2_PORT_9==1</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_8</name>
              <description>Description: Indicates if there are outstanding writes for port 8.
Value After Reset: 0x0
Exists: UMCTL2_PORT_8==1</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_7</name>
              <description>Description: Indicates if there are outstanding writes for port 7.
Value After Reset: 0x0
Exists: UMCTL2_PORT_7==1</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_6</name>
              <description>Description: Indicates if there are outstanding writes for port 6.
Value After Reset: 0x0
Exists: UMCTL2_PORT_6==1</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_5</name>
              <description>Description: Indicates if there are outstanding writes for port 5.
Value After Reset: 0x0
Exists: UMCTL2_PORT_5==1</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_4</name>
              <description>Description: Indicates if there are outstanding writes for port 4.
Value After Reset: 0x0
Exists: UMCTL2_PORT_4==1</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_3</name>
              <description>Description: Indicates if there are outstanding writes for port 3.
Value After Reset: 0x0
Exists: UMCTL2_PORT_3==1</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_2</name>
              <description>Description: Indicates if there are outstanding writes for port 2.
Value After Reset: 0x0
Exists: UMCTL2_PORT_2==1</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_1</name>
              <description>Description: Indicates if there are outstanding writes for port 1.
Value After Reset: 0x0
Exists: UMCTL2_PORT_1==1</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PORT_BUSY_0</name>
              <description>Description: Indicates if there are outstanding writes for port 0.
Value After Reset: 0x0
Exists: UMCTL2_PORT_0==1</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_15</name>
              <description>Description: Indicates if there are outstanding reads for port 15.
Value After Reset: 0x0
Exists: UMCTL2_PORT_15==1</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_14</name>
              <description>Description: Indicates if there are outstanding reads for port 14.
Value After Reset: 0x0
Exists: UMCTL2_PORT_14==1</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_13</name>
              <description>Description: Indicates if there are outstanding reads for port 13.
Value After Reset: 0x0
Exists: UMCTL2_PORT_13==1</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_12</name>
              <description>Description: Indicates if there are outstanding reads for port 12.
Value After Reset: 0x0
Exists: UMCTL2_PORT_12==1</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_11</name>
              <description>Description: Indicates if there are outstanding reads for port 11.
Value After Reset: 0x0
Exists: UMCTL2_PORT_11==1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_10</name>
              <description>Description: Indicates if there are outstanding reads for port 10.
Value After Reset: 0x0
Exists: UMCTL2_PORT_10==1</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_9</name>
              <description>Description: Indicates if there are outstanding reads for port 9.
Value After Reset: 0x0
Exists: UMCTL2_PORT_9==1</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_8</name>
              <description>Description: Indicates if there are outstanding reads for port 8.
Value After Reset: 0x0
Exists: UMCTL2_PORT_8==1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_7</name>
              <description>Description: Indicates if there are outstanding reads for port 7.
Value After Reset: 0x0
Exists: UMCTL2_PORT_7==1</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_6</name>
              <description>Description: Indicates if there are outstanding reads for port 6.
Value After Reset: 0x0
Exists: UMCTL2_PORT_6==1</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_5</name>
              <description>Description: Indicates if there are outstanding reads for port 5.
Value After Reset: 0x0
Exists: UMCTL2_PORT_5==1</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_4</name>
              <description>Description: Indicates if there are outstanding reads for port 4.
Value After Reset: 0x0
Exists: UMCTL2_PORT_4==1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_3</name>
              <description>Description: Indicates if there are outstanding reads for port 3.
Value After Reset: 0x0
Exists: UMCTL2_PORT_3==1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_2</name>
              <description>Description: Indicates if there are outstanding reads for port 2.
Value After Reset: 0x0
Exists: UMCTL2_PORT_2==1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_1</name>
              <description>Description: Indicates if there are outstanding reads for port 1.
Value After Reset: 0x0
Exists: UMCTL2_PORT_1==1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PORT_BUSY_0</name>
              <description>Description: Indicates if there are outstanding reads for port 0.
Value After Reset: 0x0
Exists: UMCTL2_PORT_0==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PCCFG</name>
          <description>Description: Port Common Configuration Register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000011</resetMask>
          <fields>
            <field>
              <name>PAGEMATCH_LIMIT</name>
              <description>Description: Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled.	If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GO2CRITICAL_EN</name>
              <description>Description: If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_rd signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_rd signals at DDRC are driven to 1b'0.
Value After Reset: 0x0
Exists: Always</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>0xb0</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
          <name>PCFG[%s]</name>
          <description>no description available</description>
          <addressOffset>0x404</addressOffset>
          <register>
            <name>R</name>
            <description>Description: Port n Configuration Read Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00004000</resetValue>
            <resetMask>0x000073FF</resetMask>
            <fields>
              <field>
                <name>RD_PORT_PAGEMATCH_EN</name>
                <description>Description: If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (i.e. same bank and same row). See also related PCCFG.pagematch_limit register.
Value After Reset: "(MEMC_DDR4_EN==1) ? 0x0 : 0x1"
Exists: Always</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_PORT_URGENT_EN</name>
                <description>Description: If set to 1, enables the AXI urgent sideband signal (arurgent). When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_rd signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_PORT_AGING_EN</name>
                <description>Description: If set to 1, enables aging function for the read channel of the port.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_PORT_PRIORITY</name>
                <description>Description: Determines the initial load value of read aging counters. These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the	read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease.
When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition
- Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>W</name>
            <description>Description: Port n Configuration Write Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00004000</resetValue>
            <resetMask>0x000073FF</resetMask>
            <fields>
              <field>
                <name>WR_PORT_PAGEMATCH_EN</name>
                <description>Description: If set to 1, enables the Page Match feature. If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (i.e. same bank and same row). See also related PCCFG.pagematch_limit register.
Value After Reset: 0x1
Exists: Always</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_PORT_URGENT_EN</name>
                <description>Description: If set to 1, enables the AXI urgent sideband signal (awurgent). When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_PORT_AGING_EN</name>
                <description>Description: If set to 1, enables aging function for the write channel of the port.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_PORT_PRIORITY</name>
                <description>Description: Determines the initial load value of write aging counters. These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the
write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>10</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>C</name>
            <description>Description: Port n Common Configuration Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000003</resetMask>
            <fields>
              <field>
                <name>AHB_ENDIANNESS</name>
                <description>Description: If set to 0, enables support for little endian on the AHB port. If set to 1, enables support for big endian (BE- 32) on the AHB port. If set to 2, enables support for big endian (BE-A) on the AHB port.
Value After Reset: 0x0
Exists: UMCTL2_A_AHB_n==1</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>0x8</dimIncrement>
            <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
            <name>ID[%s]</name>
            <description>no description available</description>
            <addressOffset>0xc</addressOffset>
            <register>
              <name>MASKCH</name>
              <description>Description: Port n Channel m Configuration ID Mask Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ID_MASK</name>
                  <description>Description: Determines the mask used in the ID mapping function for virtual channel m.
Value After Reset: 0x0
Exists: Always</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>VALUECH</name>
              <description>Description: Port n Channel m Configuration ID Value Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <resetValue>0x00000000</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ID_VALUE</name>
                  <description>Description: Determines the value used in the ID mapping function for virtual channel m.
Value After Reset: 0x0
Exists: Always</description>
                  <bitOffset>0</bitOffset>
                  <bitWidth>32</bitWidth>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>CTRL</name>
            <description>Description: Port n Control Register</description>
            <addressOffset>0x8c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>PORT_EN</name>
                <description>Description: Enables port n.
Value After Reset: "UMCTL2_PORT_EN_RESET_VALUE"
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>QOS0</name>
            <description>Description: Port n Read QoS Configuration Register 0</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0033000F</resetMask>
            <fields>
              <field>
                <name>RQOS_MAP_REGION1</name>
                <description>Description: This bitfield indicates the traffic class of region
1.	Valid values are:	0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.	When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1 (VPR) then VPR traffic is aliased to LPR traffic.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RQOS_MAP_REGION0</name>
                <description>Description: This bitfield indicates the traffic class of region
0. Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.	When VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1 (VPR) then VPR traffic is aliased to LPR traffic.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RQOS_MAP_LEVEL1</name>
                <description>Description: Separation level1 indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 13(for dual RAQ) or 0 to 14(for single RAQ) which corresponds to arqos.	Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.	All of the map_level* registers must be set to distinct values.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>QOS1</name>
            <description>Description: Port n Read QoS Configuration Register 1</description>
            <addressOffset>0x94</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x07FF07FF</resetMask>
            <fields>
              <field>
                <name>RQOS_MAP_TIMEOUTR</name>
                <description>Description: Specifies the timeout value for transactions mapped to the red address queue.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>16</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RQOS_MAP_TIMEOUTB</name>
                <description>Description: Specifies the timeout value for transactions mapped to the blue address queue.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WQOS0</name>
            <description>Description: Port n Write QoS Configuration Register 0</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0033000F</resetMask>
            <fields>
              <field>
                <name>WQOS_MAP_REGION1</name>
                <description>Description: This bitfield indicates the traffic class of region
1. Valid values are:
0: NPW
1: VPW
When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1 (VPW) then VPW traffic is aliased to NPW traffic.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WQOS_MAP_REGION0</name>
                <description>Description: This bitfield indicates the traffic class of region
0. Valid values are:
0: NPW
1: VPW
When VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region0 is set to 1 (VPW) then VPW traffic is aliased to NPW traffic.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WQOS_MAP_LEVEL</name>
                <description>Description: Separation level indicating the end of region0 mapping; start of region0 is 0. Possible values for level1 are 0 to 14 which corresponds to awqos.	Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WQOS1</name>
            <description>Description: Port n Write QoS Configuration Register 1</description>
            <addressOffset>0x9c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000007FF</resetMask>
            <fields>
              <field>
                <name>WQOS_MAP_TIMEOUT</name>
                <description>Description: Specifies the timeout value for write transactions.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>11</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>SAR[%s]</name>
          <description>no description available</description>
          <addressOffset>0xf04</addressOffset>
          <register>
            <name>BASE</name>
            <description>Description: SAR Base Address Register n</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BASE_ADDR</name>
                <description>Description: Base address for address region n specified as awaddr[UMCTL2_A_ADDRW-1:x] and araddr[UMCTL2_A_ADDRW-1:x] where x is determined by the minimum block size parameter UMCTL2_SARMINSIZE: (x=log2(block size)).
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIZE</name>
            <description>Description: SAR Size Register n</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000000FF</resetMask>
            <fields>
              <field>
                <name>NBLOCKS</name>
                <description>Description: Number of blocks for address region n. This register determines the total size of the region in multiples of minimum block size as specified by the hardware parameter UMCTL2_SARMINSIZE. The register value is encoded as number of blocks = nblocks + 1.
Value After Reset: 0x0
Exists: Always</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>SBRCTL</name>
          <description>Description: Scrubber Control Register</description>
          <addressOffset>0xf24</addressOffset>
          <size>32</size>
          <resetValue>0x0000FF10</resetValue>
          <resetMask>0x001FFF77</resetMask>
          <fields>
            <field>
              <name>SCRUB_INTERVAL</name>
              <description>Description: Scrub interval. (512 x scrub_interval) number of clock cycles between two scrub read commands. If set to 0,	scrub commands are issued back-to-back. This mode of operation (scrub_interval=0) can typically be used for scrubbing the full range of memory at once	before or after SW controlled low power operations. After completing the full range of scrub while scrub_interval=0, scrub_done register is set and	sbr_done_intr interrupt signal is asserted.
Value After Reset: 0xff
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCRUB_BURST</name>
              <description>Description: Scrub burst count. Determines the number of back-to-back scrub read commands that can be issued together		when the controller is in one of the HW controlled low power modes. During low power, the period of the scrub burst	becomes \"scrub_burst*scrub_interval\" cycles.
During normal operation mode of the controller (ie. not in power-down	or self refresh), scrub_burst is ignored and only one scrub command is generated.	Valid values are: 1: 1 read, 2: 4 reads, 3: 16 reads, 4: 64 reads, 5: 256 reads,
6: 1024 reads.
Value After Reset: 0x1
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCRUB_MODE</name>
              <description>Description: scrub_mode:0 ECC scrubber will perform reads	scrub_mode:1 ECC scrubber will perform writes Value After Reset: 0x0
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCRUB_DURING_LOWPOWER</name>
              <description>Description: Continue scrubbing during low power. If set to 1, burst of scrubs will be issued	in HW controlled low power modes. There are two such modes: automatically initiated		by idleness or initiated by HW low-power (LP) interface. If set to 0, the scrubber		will not attempt to send commands while the DDRC is in HW controlled low power modes.	In this case, the scrubber will remember the last address issued and will automatically continue	from there when the DDRC exits the LP mode.
Value After Reset: 0x0
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCRUB_EN</name>
              <description>Description: Enable ECC scrubber. If set to 1, enables the scrubber to generate background	read commands after the memories are initialized. If set to 0, disables the scrubber, resets the address generator to 0	and clears the scrubber status. This bitfield must be accessed separately from the other bitfields in this register.
Value After Reset: 0x0
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SBRSTAT</name>
          <description>Description: Scrubber Status Register</description>
          <addressOffset>0xf28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>SCRUB_DONE</name>
              <description>Description: Scrubber done. Controller sets this bit to 1, after full range of addresses are scrubbed once while scrub_interval is set to 0.	Cleared if scrub_en is set to 0 (scrubber disabled) or scrub_interval is set to a non-zero value for normal scrub operation.	The interrupt signal, sbr_done_intr, is equivalent to this status bitfield.
Value After Reset: 0x0
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCRUB_BUSY</name>
              <description>Description: Scrubber busy. Controller sets this bit to 1 when the scrubber logic has outstanding read commands being executed.	Cleared when there are no active outstanding scrub reads in the system.
Value After Reset: 0x0
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SBRWDATA0</name>
          <description>Description: Scrubber Write Data Pattern0</description>
          <addressOffset>0xf2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCRUB_PATTERN0</name>
              <description>Description: ECC Scrubber write data pattern for data bus[31:0]
Value After Reset: 0x0
Exists: UMCTL2_SBR_EN_1==1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FFA</name>
      <description>FFA</description>
      <groupName>FFA</groupName>
      <baseAddress>0xf3018000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>No description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset the module if asserted to be 1.
EN is only active after this bit is zero.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Asserted to enable the module</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>No description available</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>FIR_OV</name>
              <description>FIR Overflow err</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FFT_OV</name>
              <description>FFT Overflow Err</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WR_ERR</name>
              <description>AXI Data Write Error</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RD_NXT_ERR</name>
              <description>AXI Read Bus Error for NXT DATA</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RD_ERR</name>
              <description>AXI Data Read Error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>NXT_CMD_RD_DONE</name>
              <description>Indicate that next command sequence is already read into the module.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OP_CMD_DONE</name>
              <description>Indicate that operation cmd is done, and data are available in system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>No description available</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRSV1</name>
              <description>Reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIR_OV</name>
              <description>FIR Overflow err</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FFT_OV</name>
              <description>FFT Overflow Err</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR_ERR</name>
              <description>Enable Data Write Error interrupt</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_NXT_ERR</name>
              <description>Enable Read Bus Error for NXT DATA interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RD_ERR</name>
              <description>Enable Data Read Error interrupt</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_CMD_RD_DONE</name>
              <description>Indicate that next command sequence is already read into the module.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_CMD_DONE</name>
              <description>Indicate that operation cmd is done, and data are available in system memory.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_CTRL</name>
          <description>No description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NXT_ADDR</name>
              <description>The address for the next command.
It will be processed after CUR_CMD is executed and done..</description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_EN</name>
              <description>Whether NXT_CMD is enabled.
Asserted to enable the NXT_CMD when CUR_CMD is done, or CUR_CMD is not enabled..</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Whether CUR_CMD is enabled.
Asserted to enable the CUR_CMD</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_CMD</name>
          <description>No description available</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x01FFFEFF</resetMask>
          <fields>
            <field>
              <name>CONJ_C</name>
              <description>asserted to have conjuate value for coefs in computation</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD</name>
              <description>The Command Used:
0: FIR
2: FFT
Others: Reserved</description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTD_TYPE</name>
              <description>Output data type:
0:Real Q31, 1:Real Q15, 2:Complex Q31, 3:Complex Q15
4:complex sp float 5: real sp float</description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_TYPE</name>
              <description>Coef data type (used for FIR):
0:Real Q31, 1:Real Q15, 2:Complex Q31, 3:Complex Q15
4:complex sp float 5: real sp float</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND_TYPE</name>
              <description>Input data type:
0:Real Q31, 1:Real Q15, 2:Complex Q31, 3:Complex Q15
4:complex sp float 5: real sp float</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NXT_CMD_LEN</name>
              <description>The length of nxt commands in 32-bit words</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG0</name>
          <description>No description available</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_MISC</name>
          <description>No description available</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>FIR_COEF_TAPS</name>
              <description>Length of FIR coefs max 256</description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FFT_MISC</name>
          <description>No description available</description>
          <alternateGroup>UNION_28</alternateGroup>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>FFT_LEN</name>
              <description>FFT length
0:8,
...,
n:2^(3+n)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IFFT</name>
              <description>Asserted to indicate IFFT</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMP_BLK</name>
              <description>Memory block for indata. Should be assigned as 1</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND_BLK</name>
              <description>Memory block for indata. Should be assigned as 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG1</name>
          <description>No description available</description>
          <alternateGroup>UNION_2C</alternateGroup>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_MISC1</name>
          <description>No description available</description>
          <alternateGroup>UNION_2C</alternateGroup>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>OUTD_MEM_BLK</name>
              <description>Should be assigned as 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COEF_MEM_BLK</name>
              <description>Should be assigned as 1</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IND_MEM_BLK</name>
              <description>Should be assigned as 2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIR_DATA_TAPS</name>
              <description>The input data data length</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG2</name>
          <description>No description available</description>
          <alternateGroup>UNION_30</alternateGroup>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FFT_INRBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_30</alternateGroup>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The input (real) data buffer pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG3</name>
          <description>No description available</description>
          <alternateGroup>UNION_34</alternateGroup>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_INBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_34</alternateGroup>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The input data buffer pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG4</name>
          <description>No description available</description>
          <alternateGroup>UNION_38</alternateGroup>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_COEFBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_38</alternateGroup>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The coef buf pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FFT_OUTRBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_38</alternateGroup>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The output (real) data buffer pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG5</name>
          <description>No description available</description>
          <alternateGroup>UNION_3C</alternateGroup>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_FIR_OUTBUF</name>
          <description>No description available</description>
          <alternateGroup>UNION_3C</alternateGroup>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOC</name>
              <description>The output data buffer pointer. The length of the output buffer should be FIR_DATA_TAPS - FIR_COEF_TAPS + 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG6</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OP_REG7</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CT</name>
              <description>Contents</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDP</name>
      <description>SDP</description>
      <groupName>SDP</groupName>
      <baseAddress>0xf3040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x60</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SDPCR</name>
          <description>SDP control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xFFFE0101</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>soft reset.
Write 1 then 0, to reset the SDP block.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKGAT</name>
              <description>Clock Gate for the SDP main logic.
Write to 1 will clock gate for most logic of the SDP block, dynamic power saving when not use SDP block.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIPDIS</name>
              <description>Cipher Disable, read the info, whether the CIPHER features is besing disable in this chip or not.
1, Cipher is disabled in this chip.
0, Cipher is enabled in this chip.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HASDIS</name>
              <description>HASH Disable, read the info, whether the HASH features is besing disable in this chip or not.
1, HASH is disabled in this chip.
0, HASH is enabled in this chip.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CIPHEN</name>
              <description>Cipher Enablement, controlled by SW.
1, Cipher is Enabled.
0, Cipher is Disabled.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASHEN</name>
              <description>HASH Enablement, controlled by SW.
1, HASH is Enabled.
0, HASH is Disabled.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MCPEN</name>
              <description>Memory Copy Enablement, controlled by SW.
1, Memory copy is Enabled.
0, Memory copy is Disabled.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFEN</name>
              <description>Constant Fill to memory, controlled by SW.
1, Constant fill is Enabled.
0, Constant fill is Disabled.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRPDI</name>
              <description>Decryption Disable bit, Write to 1 to disable the decryption.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TSTPKT0IRQ</name>
              <description>Test purpose for interrupt when Packet counter reachs "0", but CHAIN=1 in the current packet.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDSCEN</name>
              <description>when set to "1", the 1st data packet descriptor loacted in the register(CMDPTR, NPKTPTR, ...)
when set to "0", the 1st data packet descriptor loacted in the memeory(pointed by CMDPTR)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEN</name>
              <description>Interrupt Enablement, controlled by SW.
1, SDP interrupt is enabled.
0, SDP interrupt is disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODCTRL</name>
          <description>Mod control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF7FF</resetMask>
          <fields>
            <field>
              <name>AESALG</name>
              <description>AES algorithem selection.
0x0 = AES 128;
0x1 = AES 256;
0x8 = SM4
Others, reserved.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESMOD</name>
              <description>AES mode selection.
0x0 = ECB;
0x1 = CBC;
Others, reserved.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESKS</name>
              <description>AES Key Selection.
These regisgers are being used to select the AES key that stored in the 16x128 key ram of the SDP, or select the key from the OTP. Detail as following:
0x00: key from the 16x128, this is the key read address, valid for AES128; AES256 will use 128 bit from this address and 128 bit key from next address as 256 bit AES key.
0x01: key from the 16x128, this is the key read address, valid for AES128, not valid for AES286.
....
0x0E: key from the 16x128, this is the key read address, valid for AES128; AES256 will use 128 from this add and 128 from next add for the AES key.
0x0F: key from the 16x128, this is the key read address, valid for AES128, not valid for AES286.
0x20: kman_sk0[127:0] from the key manager for AES128; AES256 will use kman_sk0[255:0] as AES key.
0x21: kman_sk0[255:128] from the key manager for AES128; not valid for AES256.
0x22: kman_sk1[127:0] from the key manager for AES128; AES256 will use kman_sk1[255:0] as AES key.
0x23: kman_sk1[255:128] from the key manager for AES128; not valid for AES256.
0x24: kman_sk2[127:0] from the key manager for AES128; AES256 will use kman_sk2[255:0] as AES key.
0x25: kman_sk2[255:128] from the key manager for AES128; not valid for AES256.
0x26: kman_sk3[127:0] from the key manager for AES128; AES256 will use kman_sk3[255:0] as AES key.
0x27: kman_sk3[255:128] from the key manager for AES128; not valid for AES256.
0x30: exip0_key[127:0] from OTP for AES128; AES256 will use exip0_key[255:0] as AES key.
0x31: exip0_key[255:128] from OTP for AES128; not valid for AES256.
0x32: exip1_key[127:0] from OTP for AES128; AES256 will use exip1_key[255:0] as AES key.
0x33: exip1_key[255:128] from OTP for AES128; not valid for AES256.
Other values, reserved.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AESDIR</name>
              <description>AES direction
1x1, AES Decryption
1x0, AES Encryption.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASALG</name>
              <description>HASH Algorithem selection.
0x0 SHA1 
0x1 CRC32 
0x2 SHA256 </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASCHK</name>
              <description>HASH Check Enable Bit.
1x1, HASH check need, hash result will compare with the HASHRSLT 0-7 registers;
1x0, HASH check is not enabled, HASHRSLT0-7 store the HASH result.
For SHA1, will use HASHRSLT0-3 words, and HASH 256 will use HASH0-7 words.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASOUT</name>
              <description>When hashing is enabled, this bit controls the input or output data of the AES engine is hashed.
0 INPUT HASH
1 OUTPUT HASH</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DINSWP</name>
              <description>Decide whether the SDP byteswaps the input data (big-endian data);
When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUTSWP</name>
              <description>Decide whether the SDP byteswaps the output data (big-endian data); When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEYSWP</name>
              <description>Decide whether the SDP byteswaps the Key (big-endian data).
When all bits are set, the data is assumed to be in the big-endian format</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTCNT</name>
          <description>packet counter registers.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNTVAL</name>
              <description>This read-only field shows the current (instantaneous) value of the packet counter</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CNTINCR</name>
              <description>The value written to this field is added to the spacket count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Registers</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>packet tag.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>interrupt Request, requested when error happen, or when packet processing done, packet counter reach to zero.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CHN1PKT0</name>
              <description>the chain buffer "chain" bit is "1", while packet counter is "0", now, waiting for new buffer data.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>AESBSY</name>
              <description>AES Busy</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HASBSY</name>
              <description>Hashing Busy</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PKTCNT0</name>
              <description>Packet Counter registers reachs to ZERO now.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PKTDON</name>
              <description>Packet processing done, will trigger this itnerrrupt when the "PKTINT" bit set in the packet control word.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRSET</name>
              <description>Working mode setup error.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRPKT</name>
              <description>Packet head access error, or status update error.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRSRC</name>
              <description>Source Buffer Access Error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRDST</name>
              <description>Destination Buffer Error</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRHAS</name>
              <description>Hashing Check Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ERRCHAIN</name>
              <description>buffer chain error happen when packet's CHAIN bit=0, but the Packet counter is still not zero.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYADDR</name>
          <description>Key Address</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INDEX</name>
              <description>To write a key to the SDP KEY RAM, the software must first write the desired key index/subword to this register.
Key index pointer. The valid indices are 0-[number_keys].
In the SDP, there is a 16x128 key ram can store 16 AES128 keys or 8 AES 256 Keys; this index is for addressing the 16 128-bit key addresses.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBWRD</name>
              <description>Key subword pointer. The valid indices are 0-3. After each write to the key data register, this field
increments; To write a key, the software must first write the desired key index/subword to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEYDAT</name>
          <description>Key Data</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEYDAT</name>
              <description>This register provides the write access to the key/key subword specified by the key index register.
Writing this location updates the selected subword for the key located at the index
specified by the key index register. The write also triggers the SUBWORD field of the
KEY register to increment to the next higher word in the key</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>CIPHIV0,CIPHIV1,CIPHIV2,CIPHIV3</dimIndex>
          <name>CIPHIV[%s]</name>
          <description>no description available</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CIPHIV</name>
              <description>cipher initialization vector.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>HASWRD0,HASWRD1,HASWRD2,HASWRD3,HASWRD4,HASWRD5,HASWRD6,HASWRD7</dimIndex>
          <name>HASWRD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HASWRD</name>
              <description>Hash Data Word x - HASH result bit; will store the expected hash result bit if hash check enabled; when hash check is not enabled,  the hash engine will store the final hash result[31:0] here.
If CRC mode enabled, this work store the CRC expected result if the check enabled, or store the final calcuated CRC result.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDPTR</name>
          <description>Command Pointer</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMDPTR</name>
              <description>current command addresses the register points to the multiword
descriptor that is to be executed (or is currently being executed)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NPKTPTR</name>
          <description>Next Packet Address Pointer</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NPKTPTR</name>
              <description>Next Packet Address Pointer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTCTL</name>
          <description>Packet Control Registers</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTTAG</name>
              <description>packet tag</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIPHIV</name>
              <description>Load Initial Vector for the AES in this packet.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASFNL</name>
              <description>Hash Termination packet</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HASINI</name>
              <description>Hash Initialization packat</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHAIN</name>
              <description>whether the next command pointer register must be loaded into the channel's current descriptor
pointer.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCRSEMA</name>
              <description>whether the channel's semaphore must be decremented at the end of the current operation.
When the semaphore reaches a value of zero, no more operations are issued from the channel.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PKTINT</name>
              <description>Reflects whether the channel must issue an interrupt upon the completion of the packet</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTSRC</name>
          <description>Packet Memory Source Address</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTSRC</name>
              <description>Packet Memory Source Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTDST</name>
          <description>Packet Memory Destination Address</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTDST</name>
              <description>Packet Memory Destination Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PKTBUF</name>
          <description>Packet buffer size.</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PKTBUF</name>
              <description>No description available</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SEC</name>
      <description>SEC</description>
      <groupName>SEC</groupName>
      <baseAddress>0xf3044000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_STATE</name>
          <description>Secure state</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000300F0</resetMask>
          <fields>
            <field>
              <name>ALLOW_NSC</name>
              <description>Non-secure state allow
0: system is not healthy to enter non-secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter non-secure state</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALLOW_SEC</name>
              <description>Secure state allow
0: system is not healthy to enter secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter secure state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_FAIL</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in fail state
1: secure state is in fail state</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_NSC</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in non-secure state
1: secure state is in non-secure state</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_SEC</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in secure state
1: secure state is in secure state</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_INS</name>
              <description>PMIC secure state one hot indicator
0: secure state is not in inspect state
1: secure state is in inspect state</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_STATE_CONFIG</name>
          <description>secure state configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000009</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Lock bit of allow restart setting, once locked, lock bit itself and configuration register will keep value until next reset
0: not locked, register can be modified
1: register locked, write access to the register is ignored</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLOW_RESTART</name>
              <description>allow secure state restart from fail state
0: restart is not allowed, only hardware reset can recover secure state
1: software is allowed to switch to inspect state from fail state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VIOLATION_CONFIG</name>
          <description>Security violation config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCALATE_CONFIG</name>
          <description>Escalate behavior on security event</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>Event and escalate status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF000C</resetMask>
          <fields>
            <field>
              <name>EVENT</name>
              <description>local event statue, each bit represents one security event</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_ESC_NSC</name>
              <description>PMIC is escalating non-secure event</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PMIC_ESC_SEC</name>
              <description>PMIC is escalting secure event</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFECYCLE</name>
          <description>Lifecycle</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>LIFECYCLE</name>
              <description>lifecycle status,
bit7: lifecycle_debate,
bit6: lifecycle_scribe,
bit5: lifecycle_no_ret,
bit4: lifecycle_return,
bit3: lifecycle_secure,
bit2: lifecycle_nonsec,
bit1: lifecycle_create,
bit0: lifecycle_unknow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MON</name>
      <description>MON</description>
      <groupName>MON</groupName>
      <baseAddress>0xf3048000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>glitch0,glitch1,clock0,clock1</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Glitch and clock monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000011</resetMask>
            <fields>
              <field>
                <name>ACTIVE</name>
                <description>select glitch works in active mode or passve mode.
0: passive mode, depends on power glitch destroy DFF value
1: active mode, check glitch by DFF chain</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable glitch detector
0: detector disabled
1: detector enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Glitch and clock monitor status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag for glitch detected, write 1 to clear this flag
0: glitch not detected
1: glitch detected</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>IRQ_FLAG</name>
          <description>No description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>interrupt flag, each bit represents for one monitor, write 1 to clear interrupt flag
0: no monitor interrupt
1: monitor interrupt happened</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ_ENABLE</name>
          <description>No description available</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>interrupt enable, each bit represents for one monitor
0: monitor interrupt disabled
1: monitor interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RNG</name>
      <description>RNG</description>
      <groupName>RNG</groupName>
      <baseAddress>0xf304c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CMD</name>
          <description>Command Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>Soft Reset, Perform a software reset of the RNG This bit is self-clearing.
0 Do not perform a software reset.
1 Software reset</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRERR</name>
              <description>Clear the Error, clear the errors in the ESR register and the RNG interrupt. This bit is self-clearing.
0 Do not clear the errors and the interrupt.
1 Clear the errors and the interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRINT</name>
              <description>Clear the Interrupt, clear the RNG interrupt if an error is not present. This bit is self-clearing.
0 Do not clear the interrupt.
1 Clear the interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GENSD</name>
              <description>Generate Seed, when both ST and GS triggered, ST first and GS next.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLFCHK</name>
              <description>Self Test, when both ST and GS triggered, ST first and GS next.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIRQERR</name>
              <description>Mask Interrupt Request for Error</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MIRQDN</name>
              <description>Mask Interrupt Request for Done Event, asks the interrupts generated upon the completion of the seed and self-test modes. The status of these jobs can be viewed by:
 Reading the STA and viewing the seed done and the self-test done bits (STA[SDN, STDN]).
 Viewing the RNG_CMD for the generate-seed or the self-test bits (CMD[GS,ST]) being set, indicating that the operation is still taking place.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTRSD</name>
              <description>Auto Reseed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FUFMOD</name>
              <description>FIFO underflow response mode
00 Return all zeros and set the ESR[FUFE].
01 Return all zeros and set the ESR[FUFE].
10 Generate the bus transfer error
11 Generate the interrupt and return all zeros (overrides the CTRL[MASKERR]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STA</name>
          <description>Status Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCPF</name>
              <description>Self Check Pass Fail</description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FUNCERR</name>
              <description>Error was detected, check ESR register for details</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSIZE</name>
              <description>Fifo Size, it is 5 in this design.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRNNU</name>
              <description>Fifo Level, Indicates the number of random words currently in the output FIFO</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NSDDN</name>
              <description>New seed done.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FSDDN</name>
              <description>1st Seed done
When "1", Indicates that the RNG generated the first seed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCDN</name>
              <description>Self Check Done
Indicates whether Self Test is done or not. Can be cleared by the hardware reset or a new self test is
initiated by setting the CMD[ST].
0 Self test not completed
1 Completed a self test since the last reset.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RSDREQ</name>
              <description>Reseed needed
Indicates that the RNG needs to be reseeded. This is done by setting the CMD[GS], or
automatically if the CTRL[ARS] is set.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDLE</name>
              <description>Idle, the RNG is in the idle mode, and internal clocks are disabled, in this mode, access to the FIFO is allowed. Once the FIFO is empty, the RNGB fills the FIFO and then enters idle mode again.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>when 1, means the RNG engine is busy for seeding or random number generation, self test and so on.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERR</name>
          <description>Error Registers</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF3F</resetMask>
          <fields>
            <field>
              <name>FUFE</name>
              <description>FIFO access error(underflow)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SCKERR</name>
              <description>Self-test error
Indicates that the RNG failed the most recent self test. This bit is sticky and can only be reset by a
hardware reset or by writing 1 to the CMD[CE]</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FO2B</name>
          <description>FIFO out to bus/cpu</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FO2B</name>
              <description>SW read the FIFO output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FO2S0,FO2S1,FO2S2,FO2S3,FO2S4,FO2S5,FO2S6,FO2S7</dimIndex>
          <name>R2SK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FO2S0</name>
              <description>FIFO out to KMAN, will be SDP engine key.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>OTP</name>
      <description>OTP</description>
      <groupName>OTP</groupName>
      <baseAddress>0xf3050000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xc08</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>128</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SHADOW000,SHADOW001,SHADOW002,SHADOW003,SHADOW004,SHADOW005,SHADOW006,SHADOW007,SHADOW008,SHADOW009,SHADOW010,SHADOW011,SHADOW012,SHADOW013,SHADOW014,SHADOW015,SHADOW016,SHADOW017,SHADOW018,SHADOW019,SHADOW020,SHADOW021,SHADOW022,SHADOW023,SHADOW024,SHADOW025,SHADOW026,SHADOW027,SHADOW028,SHADOW029,SHADOW030,SHADOW031,SHADOW032,SHADOW033,SHADOW034,SHADOW035,SHADOW036,SHADOW037,SHADOW038,SHADOW039,SHADOW040,SHADOW041,SHADOW042,SHADOW043,SHADOW044,SHADOW045,SHADOW046,SHADOW047,SHADOW048,SHADOW049,SHADOW050,SHADOW051,SHADOW052,SHADOW053,SHADOW054,SHADOW055,SHADOW056,SHADOW057,SHADOW058,SHADOW059,SHADOW060,SHADOW061,SHADOW062,SHADOW063,SHADOW064,SHADOW065,SHADOW066,SHADOW067,SHADOW068,SHADOW069,SHADOW070,SHADOW071,SHADOW072,SHADOW073,SHADOW074,SHADOW075,SHADOW076,SHADOW077,SHADOW078,SHADOW079,SHADOW080,SHADOW081,SHADOW082,SHADOW083,SHADOW084,SHADOW085,SHADOW086,SHADOW087,SHADOW088,SHADOW089,SHADOW090,SHADOW091,SHADOW092,SHADOW093,SHADOW094,SHADOW095,SHADOW096,SHADOW097,SHADOW098,SHADOW099,SHADOW100,SHADOW101,SHADOW102,SHADOW103,SHADOW104,SHADOW105,SHADOW106,SHADOW107,SHADOW108,SHADOW109,SHADOW110,SHADOW111,SHADOW112,SHADOW113,SHADOW114,SHADOW115,SHADOW116,SHADOW117,SHADOW118,SHADOW119,SHADOW120,SHADOW121,SHADOW122,SHADOW123,SHADOW124,SHADOW125,SHADOW126,SHADOW127</dimIndex>
          <name>SHADOW[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SHADOW</name>
              <description>shadow register of fuse for pmic area
for PMIC, index valid for 0-15, for SOC index valid for 16-128</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOCK00,LOCK01,LOCK02,LOCK03,LOCK04,LOCK05,LOCK06,LOCK07</dimIndex>
          <name>SHADOW_LOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock for pmic part shadow registers, 2 bits per 32 bit word, lock behavior is different between different fuse types
00: not locked
01: soft locked
10: not locked, and cannot lock in furture
11: double locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>128</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>FUSE000,FUSE001,FUSE002,FUSE003,FUSE004,FUSE005,FUSE006,FUSE007,FUSE008,FUSE009,FUSE010,FUSE011,FUSE012,FUSE013,FUSE014,FUSE015,FUSE016,FUSE017,FUSE018,FUSE019,FUSE020,FUSE021,FUSE022,FUSE023,FUSE024,FUSE025,FUSE026,FUSE027,FUSE028,FUSE029,FUSE030,FUSE031,FUSE032,FUSE033,FUSE034,FUSE035,FUSE036,FUSE037,FUSE038,FUSE039,FUSE040,FUSE041,FUSE042,FUSE043,FUSE044,FUSE045,FUSE046,FUSE047,FUSE048,FUSE049,FUSE050,FUSE051,FUSE052,FUSE053,FUSE054,FUSE055,FUSE056,FUSE057,FUSE058,FUSE059,FUSE060,FUSE061,FUSE062,FUSE063,FUSE064,FUSE065,FUSE066,FUSE067,FUSE068,FUSE069,FUSE070,FUSE071,FUSE072,FUSE073,FUSE074,FUSE075,FUSE076,FUSE077,FUSE078,FUSE079,FUSE080,FUSE081,FUSE082,FUSE083,FUSE084,FUSE085,FUSE086,FUSE087,FUSE088,FUSE089,FUSE090,FUSE091,FUSE092,FUSE093,FUSE094,FUSE095,FUSE096,FUSE097,FUSE098,FUSE099,FUSE100,FUSE101,FUSE102,FUSE103,FUSE104,FUSE105,FUSE106,FUSE107,FUSE108,FUSE109,FUSE110,FUSE111,FUSE112,FUSE113,FUSE114,FUSE115,FUSE116,FUSE117,FUSE118,FUSE119,FUSE120,FUSE121,FUSE122,FUSE123,FUSE124,FUSE125,FUSE126,FUSE127</dimIndex>
          <name>FUSE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUSE</name>
              <description>fuse array, valid in PMIC part only
read operation will read out value in fuse array
write operation will update fuse array value(please make sure fuse is unlocked and  2.5V power is ready)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOCK00,LOCK01,LOCK02,LOCK03,LOCK04,LOCK05,LOCK06,LOCK07</dimIndex>
          <name>FUSE_LOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock for fuse array, 2 bits per 32 bit word, lock behavior is different between different fuse types
00: not locked
01: soft locked
10: not locked, and cannot lock in furture
11: double locked</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLOCK</name>
          <description>UNLOCK</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>unlock word for fuse array operation
write "OPEN" to unlock fuse array, write any other value will lock write to fuse.
Please make sure 24M crystal is running and 2.5V LDO working properly</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <description>DATA</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>data register for non-blocking access
this register hold dat read from fuse array or data to by programmed to fuse array</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADDR</name>
          <description>ADDR</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000007F</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>word address to be read or write</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>CMD</description>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMD</name>
              <description>command to access fure array
"BLOW" will update fuse word at ADDR to value hold in DATA
"READ" will fetch fuse value in at ADDR to DATA register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD_REQ</name>
          <description>LOAD Request</description>
          <addressOffset>0xa00</addressOffset>
          <size>32</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>REQUEST</name>
              <description>reload request for 4 regions
bit0: region0
bit1: region1
bit2: region2
bit3: region3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOAD_COMP</name>
          <description>LOAD complete</description>
          <addressOffset>0xa04</addressOffset>
          <size>32</size>
          <resetValue>0x00000007</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>COMPLETE</name>
              <description>reload complete sign for 4 regions
bit0: region 0
bit1: region1
bit2: region2
bit3: region3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>LOAD_REGION0,LOAD_REGION1,LOAD_REGION2,LOAD_REGION3</dimIndex>
          <name>REGION[%s]</name>
          <description>no description available</description>
          <addressOffset>0xa20</addressOffset>
          <size>32</size>
          <resetValue>0x00000800</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>STOP</name>
              <description>stop address of load region, fuse word at end address will NOT be reloaded
region0: fixed at 8
region1: fixed at 16
region2: fixed at 0,
region3: usrer configurable</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>start address of load region,  fuse word at start address will be reloaded
region0: fixed at 0
region1: fixed at 8
region2: fixed at 16,
region3: usrer configurable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_FLAG</name>
          <description>interrupt flag</description>
          <addressOffset>0xc00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>WRITE</name>
              <description>fuse write flag, write 1 to clear
0: fuse is not written or writing
1: value in DATA register is programmed into fuse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ</name>
              <description>fuse read flag, write 1 to clear
0: fuse is not read or reading
1: fuse value is put in DATA register</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOAD</name>
              <description>fuse load flag, write 1 to clear
0: fuse is not loaded or loading
1: fuse loaded</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <description>interrupt enable</description>
          <addressOffset>0xc04</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000007</resetMask>
          <fields>
            <field>
              <name>WRITE</name>
              <description>fuse write interrupt enable
0: fuse write interrupt is not enable
1: fuse write interrupt is enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>READ</name>
              <description>fuse read interrupt enable
0: fuse read interrupt is not enable
1: fuse read interrupt is enable</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOAD</name>
              <description>fuse load interrupt enable
0: fuse load interrupt is not enable
1: fuse load interrupt is enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>KEYM</name>
      <description>KEYM</description>
      <groupName>KEYM</groupName>
      <baseAddress>0xf3054000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x50</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SFK0,SFK1,SFK2,SFK3,SFK4,SFK5,SFK6,SFK7</dimIndex>
          <name>SOFTMKEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>software symmetric key
key will be scambled to 4 variants for software to use, and replicable on same chip.
scramble keys are chip different, and not replicable on different chip
must be write sequencely from 0 - 7, otherwise key value will be treated as all 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>SPK0,SPK1,SPK2,SPK3,SPK4,SPK5,SPK6,SPK7</dimIndex>
          <name>SOFTPKEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>software asymmetric key
key is derived from scrambles of fuse private key, software input key, SRK, and system security status.
This key os read once, sencondary read will read out 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEC_KEY_CTL</name>
          <description>secure key generation</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80011117</resetMask>
          <fields>
            <field>
              <name>LOCK_SEC_CTL</name>
              <description>block secure state key setting being changed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SK_VAL</name>
              <description>session key valid
0: session key is all 0's and not usable
1: session key is valid</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SMK_SEL</name>
              <description>software symmetric key selection
0: use origin value in software symmetric key
1: use scramble version of software symmetric key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMK_SEL</name>
              <description>batt symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMK_SEL</name>
              <description>fuse symmetric key selection
0: use scramble version of fuse symmetric key
1: use alnertave scramble of fuse symmetric key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>secure symmtric key synthesize setting, key is a XOR of following
bit0: fuse mk, 0: not selected, 1:selected
bit1: zmk from batt, 0: not selected, 1:selected
bit2: software key 0: not selected, 1:selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NSC_KEY_CTL</name>
          <description>non-secure key generation</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80011117</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC_CTL</name>
              <description>block non-secure state key setting being changed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SK_VAL</name>
              <description>session key valid
0: session key is all 0's and not usable
1: session key is valid</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SMK_SEL</name>
              <description>software symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZMK_SEL</name>
              <description>batt symmetric key selection
0: use scramble version of software symmetric key
1: use origin value in software symmetric key</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FMK_SEL</name>
              <description>fuse symmetric key selection
0: use scramble version of fuse symmetric key
1: use origin value in fuse symmetric key</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>non-secure symmtric key synthesize setting, key is a XOR of following
bit0: fuse mk, 0: not selected, 1:selected
bit1: zmk from batt, 0: not selected, 1:selected
bit2: software key 0: not selected, 1:selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RNG</name>
          <description>Random number interface behavior</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>BLOCK_RNG_XOR</name>
              <description>block RNG_XOR bit from changing, if this bit is written to 1, it will hold 1 until next reset
0: RNG_XOR can be changed by software
1: RNG_XOR ignore software change from software</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RNG_XOR</name>
              <description>control how SFK is accepted from random number generator
0: SFK value replaced by random number input
1: SFK value exclusive or with random number input,this help generate random number using 2 rings inside RNG</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>READ_CONTROL</name>
          <description>key read out control</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010001</resetMask>
          <fields>
            <field>
              <name>BLOCK_PK_READ</name>
              <description>asymmetric key readout control, if this bit is written to 1, it will hold 1 until next reset
0: key can be read out
1: key cannot be read out</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK_SMK_READ</name>
              <description>symmetric key readout control, if this bit is written to 1, it will hold 1 until next reset
0: key can be read out
1: key cannot be read out</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYSCTL</name>
      <description>SYSCTL</description>
      <groupName>SYSCTL</groupName>
      <baseAddress>0xf4000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x2c00</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>200</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>cpu0,cpx0,rsv2,rsv3,rsv4,rsv5,rsv6,rsv7,rsv8,rsv9,rsv10,rsv11,rsv12,rsv13,rsv14,rsv15,rsv16,rsv17,rsv18,rsv19,rsv20,pow_vis,pow_cpu0,pow_gpu,rsv24,rst_soc,rst_con,rst_vis,rst_cpu0,rst_gpu,rsv30,rsv31,clk_src_xtal,clk_src_pll0,clk_src_clk0_pll0,clk_src_pll1,clk_src_clk0_pll1,clk_src_clk1_pll1,clk_src_pll2,clk_src_clk0_pll2,clk_src_clk1_pll2,clk_src_pll3,clk_src_clk0_pll3,clk_src_pll4,clk_src_clk0_pll4,clk_src_pll0_ref,clk_src_pll1_ref,clk_src_pll2_ref,clk_src_pll3_ref,clk_src_pll4_ref,rsv50,rsv51,rsv52,rsv53,rsv54,rsv55,rsv56,rsv57,rsv58,rsv59,rsv60,rsv61,rsv62,rsv63,clk_top_cpu0,clk_top_mct0,clk_top_gpu0,clk_top_axif,clk_top_axis,clk_top_axic,clk_top_axiv,clk_top_axid,clk_top_can0,clk_top_can1,clk_top_can2,clk_top_can3,clk_top_can4,clk_top_can5,clk_top_can6,clk_top_can7,clk_top_lin0,clk_top_lin1,clk_top_lin2,clk_top_lin3,clk_top_lin4,clk_top_lin5,clk_top_lin6,clk_top_lin7,clk_top_i2c0,clk_top_i2c1,clk_top_i2c2,clk_top_i2c3,clk_top_spi0,clk_top_spi1,clk_top_spi2,clk_top_spi3,clk_top_urt0,clk_top_urt1,clk_top_urt2,clk_top_urt3,clk_top_urt4,clk_top_urt5,clk_top_urt6,clk_top_urt7,clk_top_tmr0,clk_top_tmr1,clk_top_tmr2,clk_top_tmr3,clk_top_tmr4,clk_top_tmr5,clk_top_tmr6,clk_top_tmr7,clk_top_xpi0,clk_top_xram,clk_top_ana0,clk_top_ana1,clk_top_aud0,clk_top_aud1,clk_top_aud2,clk_top_aud3,clk_top_eth0,clk_top_ptp0,clk_top_sdc0,clk_top_sdc1,clk_top_ntm0,clk_top_ref0,clk_top_ref1,clk_top_cam0,clk_top_cam1,clk_top_lcd0,clk_top_lcd1,clk_top_csi0,clk_top_csi1,clk_top_adc0,clk_top_adc1,clk_top_i2s0,clk_top_i2s1,clk_top_i2s2,clk_top_i2s3,rsv139,rsv140,rsv141,rsv142,rsv143,rsv144,rsv145,rsv146,rsv147,rsv148,rsv149,rsv150,rsv151,rsv152,rsv153,rsv154,rsv155,rsv156,rsv157,rsv158,rsv159,rsv160,rsv161,rsv162,rsv163,rsv164,rsv165,rsv166,rsv167,rsv168,rsv169,rsv170,rsv171,rsv172,rsv173,rsv174,rsv175,rsv176,rsv177,rsv178,rsv179,rsv180,rsv181,rsv182,rsv183,rsv184,rsv185,rsv186,rsv187,rsv188,rsv189,rsv190,rsv191,rsv192,rsv193,rsv194,rsv195,rsv196,rsv197,rsv198,rsv199,rsv200,rsv201,rsv202,rsv203,rsv204,rsv205,rsv206,rsv207,rsv208,rsv209,rsv210,rsv211,rsv212,rsv213,rsv214,rsv215,rsv216,rsv217,rsv218,rsv219,rsv220,rsv221,rsv222,rsv223,rsv224,rsv225,rsv226,rsv227,rsv228,rsv229,rsv230,rsv231,rsv232,rsv233,rsv234,rsv235,rsv236,rsv237,rsv238,rsv239,rsv240,rsv241,rsv242,rsv243,rsv244,rsv245,rsv246,rsv247,rsv248,rsv249,rsv250,rsv251,rsv252,rsv253,rsv254,rsv255,axis,axic,axiv,axig,lmm0,mct0,rom0,ddr0,xram,can0,can1,can2,can3,can4,can5,can6,can7,ptpc,crc0,oamp,lin0,lin1,lin2,lin3,lin4,lin5,lin6,lin7,i2c0,i2c1,i2c2,i2c3,spi0,spi1,spi2,spi3,urt0,urt1,urt2,urt3,urt4,urt5,urt6,urt7,wdg0,wdg1,mbx0,mbx1,tmr0,tmr1,tmr2,tmr3,tmr4,tmr5,tmr6,tmr7,i2s0,i2s1,i2s2,i2s3,pdm0,dao0,smix,rng0,sdp0,kman,gpio,adc0,adc1,sdm0,hdma,xdma,xpi0,ffa0,tsns,eth0,usb0,sdc0,sdc1,ntm0,ref0,ref1,cam0,cam1,pdma,jpeg,lcd0,lcd1,gwc0,gwc1,csi0,csi1,dsi0,dsi1,lvb0,lcb0,gpu0</dimIndex>
          <name>RESOURCE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC0000003</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any nodes
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: no change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>resource work mode
0:auto turn on and off as system required(recommended)
1:always on
2:always off
3:reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>link0,link1,link2,link3</dimIndex>
          <name>GROUP0[%s]</name>
          <description>no description available</description>
          <addressOffset>0x800</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Group setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: peripheral is not needed
1: periphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Group setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: add periphera into this groupperiphera is needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Group setting</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: delete periphera in this groupperiphera is not needed</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Group setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>denpendency on peripherals, index count from resource ahbp(0x400), each bit represents a peripheral
0: no effect
1: toggle the result that whether periphera is needed before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>1</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0</dimIndex>
          <name>AFFILIATE[%s]</name>
          <description>no description available</description>
          <addressOffset>0x900</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
bit0: cpu0 depends on group0
bit1: cpu0 depends on group1
bit2: cpu0 depends on group2
bit3: cpu0 depends on group3</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0each bit represents a group
0: no effect
1: the group is assigned to CPU0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Affiliate of Group</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
0: no effect
1: the group is not assigned to CPU0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Affiliate of Group</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000000F</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>Affiliate groups of cpu0, each bit represents a group
0: no effect
1: toggle the result that whether the group is assigned to CPU0 before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>1</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>cpu0</dimIndex>
          <name>RETENTION[%s]</name>
          <description>no description available</description>
          <addressOffset>0x920</addressOffset>
          <register>
            <name>VALUE</name>
            <description>Retention Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
bit00: soc_mem is kept on while cpu0 stop
bit01: soc_ctx is kept on while cpu0 stop
bit02: cpu0_mem is kept on while cpu0 stop
bit03: cpu0_ctx is kept on while cpu0 stop
bit04: con_ctx is kept on while cpu0 stop
bit05: vis_mem is kept on while cpu0 stop
bit06: vis_ctx is kept on while cpu0 stop
bit07: gpu_mem is kept on while cpu0 stop
bit08: gpu_ctx is kept on while cpu0 stop
bit09: xtal_hold is kept on while cpu0 stop
bit10: pll0_hold is kept on while cpu0 stop
bit11: pll1_hold is kept on while cpu0 stop
bit12: pll2_hold is kept on while cpu0 stop
bit13: pll3 is kept on while cpu0 stop
bit14: pll4 is kept on while cpu0 stop</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SET</name>
            <description>Retention Control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: keep</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>Retention Control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: no keep</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOGGLE</name>
            <description>Retention Control</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00007FFF</resetMask>
            <fields>
              <field>
                <name>LINK</name>
                <description>retention setting while CPU0 enter stop mode, each bit represents a resource
0: no effect
1: toggle the result that whether the resource is kept on while CPU0 stop before</description>
                <bitOffset>0</bitOffset>
                <bitWidth>15</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>3</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>vis,cpu0,gpu</dimIndex>
          <name>POWER[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1000</addressOffset>
          <register>
            <name>status</name>
            <description>Power Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xC0001100</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag represents power cycle happened from last clear of this bit
0: power domain did not edurance power cycle since last clear of this bit
1: power domain enduranced power cycle since last clear of this bit</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLAG_WAKE</name>
                <description>flag represents wakeup power cycle happened from last clear of this bit
0: power domain did not edurance wakeup power cycle since last clear of this bit
1: power domain enduranced wakeup power cycle since last clear of this bit</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LF_DISABLE</name>
                <description>low fanout power switch disable
0: low fanout power switches are turned on
1: low fanout power switches are truned off</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>LF_ACK</name>
                <description>low fanout power switch feedback
0: low fanout power switches are turned on
1: low fanout power switches are truned off</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>lf_wait</name>
            <description>Power Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x000000FF</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT</name>
                <description>wait time for low fan out power switch turn on, default value is 255
0: 0 clock cycle
1: 1 clock cycles
. . .
clock cycles count on 24MHz</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>off_wait</name>
            <description>Power Setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x0000000F</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>WAIT</name>
                <description>wait time for power switch turn off, default value is 15
0: 0 clock cycle
1: 1 clock cycles
. . .
clock cycles count on 24MHz</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>5</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>soc,con,vis,cpu0,gpu</dimIndex>
          <name>RESET[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1400</addressOffset>
          <register>
            <name>control</name>
            <description>Reset Setting</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x80000000</resetValue>
            <resetMask>0xC0000011</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag represents reset happened from last clear of this bit
0: domain did not edurance reset cycle since last clear of this bit
1:  domain enduranced reset cycle since last clear of this bit</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FLAG_WAKE</name>
                <description>flag represents wakeup reset happened from last clear of this bit
0: domain did not edurance wakeup reset cycle since last clear of this bit
1:  domain enduranced wakeup reset cycle since last clear of this bit</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HOLD</name>
                <description>perform reset and hold in reset, until ths bit cleared by software
0: reset is released for function
1: reset is assert and hold</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET</name>
                <description>perform reset and release imediately
0: reset is released
1 reset is asserted and will release automatically</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>config</name>
            <description>Reset Setting</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00402003</resetValue>
            <resetMask>0x00FFFFFF</resetMask>
            <fields>
              <field>
                <name>PRE_WAIT</name>
                <description>wait cycle numbers before assert reset
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RSTCLK_NUM</name>
                <description>reset clock number(must be even number)
0: 0 cycle
1: 0 cycles
2: 2 cycles
3: 2 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>POST_WAIT</name>
                <description>time guard band for  reset release
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>counter</name>
            <description>Reset Setting</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>self clear trigger counter, reset triggered when counter value is 1, write 0 will cancel reset
0: wait 0 cycle
1: wait 1 cycles
. . .
Note, clock cycle is base on 24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>20</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>69</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_cpu0,clk_top_mct0,clk_top_gpu0,clk_top_axif,clk_top_axis,clk_top_axic,clk_top_axiv,clk_top_axid,clk_top_can0,clk_top_can1,clk_top_can2,clk_top_can3,clk_top_can4,clk_top_can5,clk_top_can6,clk_top_can7,clk_top_lin0,clk_top_lin1,clk_top_lin2,clk_top_lin3,clk_top_lin4,clk_top_lin5,clk_top_lin6,clk_top_lin7,clk_top_i2c0,clk_top_i2c1,clk_top_i2c2,clk_top_i2c3,clk_top_spi0,clk_top_spi1,clk_top_spi2,clk_top_spi3,clk_top_urt0,clk_top_urt1,clk_top_urt2,clk_top_urt3,clk_top_urt4,clk_top_urt5,clk_top_urt6,clk_top_urt7,clk_top_tmr0,clk_top_tmr1,clk_top_tmr2,clk_top_tmr3,clk_top_tmr4,clk_top_tmr5,clk_top_tmr6,clk_top_tmr7,clk_top_xpi0,clk_top_xram,clk_top_ana0,clk_top_ana1,clk_top_aud0,clk_top_aud1,clk_top_aud2,clk_top_aud3,clk_top_eth0,clk_top_ptp0,clk_top_sdc0,clk_top_sdc1,clk_top_ntm0,clk_top_ref0,clk_top_ref1,clk_top_cam0,clk_top_cam1,clk_top_lcd0,clk_top_lcd1,clk_top_csi0,clk_top_csi1</dimIndex>
          <name>CLOCK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD00007FF</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux in clock component
0:osc0_clk0
1:pll0_clk0
2:pll1_clk0
3:pll1_clk1
4:pll2_clk0
5:pll2_clk1
6:pll3_clk0
7:pll4_clk0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV</name>
              <description>clock divider
0: divider by 1
1: divider by 2
2: divider by 3
. . .
255: divider by 256</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_adc0,clk_top_adc1</dimIndex>
          <name>ADCCLK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c00</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000100</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux
0: ana clock N
1: axis clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>clk_top_i2s0,clk_top_i2s1,clk_top_i2s2,clk_top_i2s3</dimIndex>
          <name>I2SCLK[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c08</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xD0000100</resetMask>
          <fields>
            <field>
              <name>GLB_BUSY</name>
              <description>global busy
0: no changes pending to any clock
1: any of nodes is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOC_BUSY</name>
              <description>local busy
0: a change is pending for current node
1: current node is changing status</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESERVE</name>
              <description>preserve function against global select
0: select global clock setting
1: not select global clock setting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX</name>
              <description>current mux
0: aud clock N
1: aud clock 0 for others , aud clock 1 for i2s0</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>global00</name>
          <description>Clock senario</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>MUX</name>
              <description>global clock override request
bit0: override to preset0
bit1: override to preset1
bit2: override to preset2
bit3: override to preset3
bit4: override to preset4
bit5: override to preset5
bit6: override to preset6
bit7: override to preset7</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>slice0,slice1,slice2,slice3</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2400</addressOffset>
          <register>
            <name>control</name>
            <description>Clock measure and monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x89FFD7FF</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>result is ready for read
0: not ready
1: result is ready</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV_BUSY</name>
                <description>divider is applying new setting</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OUTEN</name>
                <description>enable clock output</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV</name>
                <description>output divider</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HIGH</name>
                <description>clock frequency higher than upper limit</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOW</name>
                <description>clock frequency lower than lower limit</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>START</name>
                <description>start measurement</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>work mode,
0: register value will be compared to measurement
1: upper and lower value will be recordered in register</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACCURACY</name>
                <description>measurement accuracy,
0: resolution is 1kHz
1: resolution is 1Hz</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REFERENCE</name>
                <description>reference clock selection,
0: 32k
1: 24M</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SELECTION</name>
                <description>clock measurement selection</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>current</name>
            <description>Clock measure result</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>self updating measure result</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>low_limit</name>
            <description>Clock lower limit</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>lower frequency</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>high_limit</name>
            <description>Clock upper limit</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>FREQUENCY</name>
                <description>upper frequency</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>1</dim>
          <dimIncrement>0x400</dimIncrement>
          <dimIndex>cpu0</dimIndex>
          <name>CPU[%s]</name>
          <description>no description available</description>
          <addressOffset>0x2800</addressOffset>
          <register>
            <name>LP</name>
            <description>CPU0 LP control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00001000</resetValue>
            <resetMask>0xFF013703</resetMask>
            <fields>
              <field>
                <name>WAKE_CNT</name>
                <description>CPU0 wake up counter, counter satuated at 255, write 0x00 to clear</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>HALT</name>
                <description>halt request for CPU0,
0: CPU0 will start to execute after reset or receive wakeup request
1: CPU0 will not start after reset, or wakeup after WFI</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WAKE</name>
                <description>CPU0 is waking up
0: CPU0 wake up not asserted
1: CPU0 wake up asserted</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>EXEC</name>
                <description>CPU0 is executing
0: CPU0 is not executing
1: CPU0 is executing</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WAKE_FLAG</name>
                <description>CPU0 wakeup flag, indicate a wakeup event got active, write 1 to clear this bit
0: CPU0 wakeup not happened
1: CPU0 wake up happened</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEP_FLAG</name>
                <description>CPU0 sleep flag, indicate a sleep event got active, write 1 to clear this bit
0: CPU0 sleep not happened
1: CPU0 sleep happened</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_FLAG</name>
                <description>CPU0 reset flag, indicate a reset event got active, write 1 to clear this bit
0: CPU0 reset not happened
1: CPU0 reset happened</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Low power mode, system behavior after WFI
00: CPU clock stop after WFI
01: System enter low power mode after WFI
10: Keep running after WFI
11: reserved</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>CPU0 Lock GPR</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0000FFFE</resetMask>
            <fields>
              <field>
                <name>GPR</name>
                <description>Lock bit for CPU_DATA0 to CPU_DATA13, once set, this bit will not clear untile next reset</description>
                <bitOffset>2</bitOffset>
                <bitWidth>14</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>LOCK</name>
                <description>Lock bit for CPU_LOCK</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>14</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>GPR0,GPR1,GPR2,GPR3,GPR4,GPR5,GPR6,GPR7,GPR8,GPR9,GPR10,GPR11,GPR12,GPR13</dimIndex>
            <name>GPR[%s]</name>
            <description>no description available</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>GPR</name>
                <description>register for software to handle resume, can save resume address or status</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>STATUS0,STATUS1,STATUS2,STATUS3</dimIndex>
            <name>WAKEUP_STATUS[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>STATUS</name>
                <description>IRQ values</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>ENABLE0,ENABLE1,ENABLE2,ENABLE3</dimIndex>
            <name>WAKEUP_ENABLE[%s]</name>
            <description>no description available</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>IRQ wakeup enable</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOC</name>
      <description>IOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xf80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>496</dim>
          <dimIncrement>0x8</dimIncrement>
          <dimIndex>pa00,pa01,pa02,pa03,pa04,pa05,pa06,pa07,pa08,pa09,pa10,pa11,pa12,pa13,pa14,pa15,pa16,pa17,pa18,pa19,pa20,pa21,pa22,pa23,pa24,pa25,pa26,pa27,pa28,pa29,pa30,pa31,pb00,pb01,pb02,pb03,pb04,pb05,pb06,pb07,pb08,pb09,pb10,pb11,pb12,pb13,pb14,pb15,pb16,pb17,pb18,pb19,pb20,pb21,pb22,pb23,pb24,pb25,pb26,pb27,pb28,pb29,pb30,pb31,pc00,pc01,pc02,pc03,pc04,pc05,pc06,pc07,pc08,pc09,pc10,pc11,pc12,pc13,pc14,pc15,pc16,pc17,pc18,pc19,pc20,pc21,pc22,pc23,pc24,pc25,pc26,pc27,pc28,pc29,pc30,pc31,pd00,pd01,pd02,pd03,pd04,pd05,pd06,pd07,pd08,pd09,pd10,pd11,pd12,pd13,pd14,pd15,pd16,pd17,pd18,pd19,pd20,pd21,pd22,pd23,pd24,pd25,pd26,pd27,pd28,pd29,pd30,pd31,pe00,pe01,pe02,pe03,pe04,pe05,pe06,pe07,pe08,pe09,pe10,pe11,pe12,pe13,pe14,pe15,pe16,pe17,pe18,pe19,pe20,pe21,pe22,pe23,pe24,pe25,pe26,pe27,pe28,pe29,pe30,pe31,pf00,pf01,pf02,pf03,pf04,pf05,pf06,pf07,pf08,pf09,pf10,pf11,pf12,pf13,pf14,pf15,rsv176,rsv177,rsv178,rsv179,rsv180,rsv181,rsv182,rsv183,rsv184,rsv185,rsv186,rsv187,rsv188,rsv189,rsv190,rsv191,rsv192,rsv193,rsv194,rsv195,rsv196,rsv197,rsv198,rsv199,rsv200,rsv201,rsv202,rsv203,rsv204,rsv205,rsv206,rsv207,rsv208,rsv209,rsv210,rsv211,rsv212,rsv213,rsv214,rsv215,rsv216,rsv217,rsv218,rsv219,rsv220,rsv221,rsv222,rsv223,rsv224,rsv225,rsv226,rsv227,rsv228,rsv229,rsv230,rsv231,rsv232,rsv233,rsv234,rsv235,rsv236,rsv237,rsv238,rsv239,rsv240,rsv241,rsv242,rsv243,rsv244,rsv245,rsv246,rsv247,rsv248,rsv249,rsv250,rsv251,rsv252,rsv253,rsv254,rsv255,rsv256,rsv257,rsv258,rsv259,rsv260,rsv261,rsv262,rsv263,rsv264,rsv265,rsv266,rsv267,rsv268,rsv269,rsv270,rsv271,rsv272,rsv273,rsv274,rsv275,rsv276,rsv277,rsv278,rsv279,rsv280,rsv281,rsv282,rsv283,rsv284,rsv285,rsv286,rsv287,rsv288,rsv289,rsv290,rsv291,rsv292,rsv293,rsv294,rsv295,rsv296,rsv297,rsv298,rsv299,rsv300,rsv301,rsv302,rsv303,rsv304,rsv305,rsv306,rsv307,rsv308,rsv309,rsv310,rsv311,rsv312,rsv313,rsv314,rsv315,rsv316,rsv317,rsv318,rsv319,rsv320,rsv321,rsv322,rsv323,rsv324,rsv325,rsv326,rsv327,rsv328,rsv329,rsv330,rsv331,rsv332,rsv333,rsv334,rsv335,rsv336,rsv337,rsv338,rsv339,rsv340,rsv341,rsv342,rsv343,rsv344,rsv345,rsv346,rsv347,rsv348,rsv349,rsv350,rsv351,rsv352,rsv353,rsv354,rsv355,rsv356,rsv357,rsv358,rsv359,rsv360,rsv361,rsv362,rsv363,rsv364,rsv365,rsv366,rsv367,rsv368,rsv369,rsv370,rsv371,rsv372,rsv373,rsv374,rsv375,rsv376,rsv377,rsv378,rsv379,rsv380,rsv381,rsv382,rsv383,rsv384,rsv385,rsv386,rsv387,rsv388,rsv389,rsv390,rsv391,rsv392,rsv393,rsv394,rsv395,rsv396,rsv397,rsv398,rsv399,rsv400,rsv401,rsv402,rsv403,rsv404,rsv405,rsv406,rsv407,rsv408,rsv409,rsv410,rsv411,rsv412,rsv413,rsv414,rsv415,px00,px01,px02,px03,px04,px05,px06,px07,px08,px09,px10,px11,px12,px13,px14,px15,rsv432,rsv433,rsv434,rsv435,rsv436,rsv437,rsv438,rsv439,rsv440,rsv441,rsv442,rsv443,rsv444,rsv445,rsv446,rsv447,py00,py01,py02,py03,py04,py05,py06,py07,py08,py09,py10,py11,py12,py13,py14,py15,rsv464,rsv465,rsv466,rsv467,rsv468,rsv469,rsv470,rsv471,rsv472,rsv473,rsv474,rsv475,rsv476,rsv477,rsv478,rsv479,pz00,pz01,pz02,pz03,pz04,pz05,pz06,pz07,pz08,pz09,pz10,pz11,pz12,pz13,pz14,pz15</dimIndex>
          <name>PAD[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>FUNC_CTL</name>
            <description>ALT SELECT</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x0001011F</resetMask>
            <fields>
              <field>
                <name>LOOP_BACK</name>
                <description>force input on
0: disable
1: enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ANALOG</name>
                <description>select analog pin in pad
0: disable
1: enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ALT_SELECT</name>
                <description>alt select
0: ALT0
1: ALT1
...
31:ALT31</description>
                <bitOffset>0</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PAD_CTL</name>
            <description>PAD SETTINGS</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x01010056</resetValue>
            <resetMask>0x01370177</resetMask>
            <fields>
              <field>
                <name>HYS</name>
                <description>schmitt trigger enable
0: disable
1: enable</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PRS</name>
                <description>select pull up/down internal resistance strength:
For pull down, only have 100 Kohm resistance
For pull up:
00: 100 KOhm
01: 47 KOhm
10: 22 KOhm
11: 22 KOhm</description>
                <bitOffset>20</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PS</name>
                <description>pull select
0: pull down
1: pull up</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PE</name>
                <description>pull enable
0: pull disable
1: pull enable</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>KE</name>
                <description>keeper capability enable
0: keeper disable
1: keeper enable</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OD</name>
                <description>open drain
0: open drain disable
1: open drain enable</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SR</name>
                <description>slew rate
0: Slow slew rate
1: Fast slew rate</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPD</name>
                <description>additional 2-bit slew rate to select IO cell operation frequency range with reduced switching noise
00: Slow frequency slew rate(50Mhz)
01: Medium frequency slew rate(100 Mhz)
10: Fast frequency slew rate(150 Mhz)
11: Max frequency slew rate(200Mhz)</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DS</name>
                <description>drive strength
1.8V Mode:
000: 260 Ohm
001: 260 Ohm
010: 130 Ohm
011: 88 Ohm
100: 65 Ohm
101: 52 Ohm
110: 43 Ohm
111: 37 Ohm
3.3V Mode:
000: 157 Ohm
001: 157 Ohm
010: 78 Ohm
011: 53 Ohm
100: 39 Ohm
101: 32 Ohm
110: 26 Ohm
111: 23 Ohm</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="IOC">
      <name>PIOC</name>
      <description>PIOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4118000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="IOC">
      <name>BIOC</name>
      <description>BIOC</description>
      <groupName>IOC</groupName>
      <baseAddress>0xf4210000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PLLCTLV2</name>
      <description>PLLCTLV2</description>
      <groupName>PLLCTLV2</groupName>
      <baseAddress>0xf40c0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x300</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>XTAL</name>
          <description>OSC configuration</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x0001FFFF</resetValue>
          <resetMask>0xB00FFFFF</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Busy flag
0: Oscillator is working or shutdown
1: Oscillator is changing status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RESPONSE</name>
              <description>Crystal oscillator status
0: Oscillator is not stable
1: Oscillator is stable for use</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Crystal oscillator enable status
0: Oscillator is off
1: Oscillator is on</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RAMP_TIME</name>
              <description>Rampup time of XTAL oscillator in cycles of RC24M clock
0: 0 cycle
1: 1 cycle
2: 2 cycle
1048575: 1048575 cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>5</dim>
          <dimIncrement>0x80</dimIncrement>
          <dimIndex>pll0,pll1,pll2,pll3,pll4</dimIndex>
          <name>PLL[%s]</name>
          <description>no description available</description>
          <addressOffset>0x80</addressOffset>
          <register>
            <name>MFI</name>
            <description>PLL0 multiple register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000010</resetValue>
            <resetMask>0xB000007F</resetMask>
            <fields>
              <field>
                <name>BUSY</name>
                <description>Busy flag
0: PLL is stable or shutdown
1: PLL is changing status</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>PLL status
0: PLL is not stable
1: PLL is stable for use</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>PLL enable status
0: PLL is off
1: PLL is on</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>MFI</name>
                <description>loop back divider of PLL, support from 13 to 42, f=fref*(mfi + mfn/mfd)
0-15: invalid
16: divide by 16
17: divide by17
. . .
42: divide by 42
43~:invalid</description>
                <bitOffset>0</bitOffset>
                <bitWidth>7</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MFN</name>
            <description>PLL0 fraction numerator register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x09896800</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>MFN</name>
                <description>Numeratorof fractional part,f=fref*(mfi + mfn/mfd). This field supports changing while running.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MFD</name>
            <description>PLL0 fraction demoninator register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x0E4E1C00</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>MFD</name>
                <description>Demoninator of fraction part,f=fref*(mfi + mfn/mfd).  This field should not be changed during PLL enabled.  If changed, change will take efftect when PLL re-enabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SS_STEP</name>
            <description>PLL0 spread spectrum step register</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>STEP</name>
                <description>Step of spread spectrum modulator.
This register should not be changed during PLL and spread spectrum enabled.  If changed, new value will take effect when PLL disabled or spread spectrum disabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SS_STOP</name>
            <description>PLL0 spread spectrum stop register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x3FFFFFFF</resetMask>
            <fields>
              <field>
                <name>STOP</name>
                <description>Stop point of spread spectrum modulator
This register should not be changed during PLL and spread spectrum enabled.  If changed, new value will take effect when PLL disabled or spread spectrum disabled.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>30</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>PLL0 confguration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000101</resetMask>
            <fields>
              <field>
                <name>SPREAD</name>
                <description>Enable spread spectrum function.  This field supports changing during PLL running.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REFSEL</name>
                <description>Select reference clock, This filed support changing while running, but application must take frequency error and jitter into consideration.  And if MFN changed before reference switch, application need make sure time is enough for MFN updating.
0: XTAL24M
1: IRC24M</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCKTIME</name>
            <description>PLL0 lock time register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x000009C4</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>LOCKTIME</name>
                <description>Lock time of PLL in 24M clock cycles, typical value is 2500.  If MFI changed during PLL startup, PLL lock time may be longer than this setting.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STEPTIME</name>
            <description>PLL0 step time register</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x000009C4</resetValue>
            <resetMask>0x0000FFFF</resetMask>
            <fields>
              <field>
                <name>STEPTIME</name>
                <description>Step time for MFI on-the-fly change in 24M clock cycles, typical value is 2500.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>16</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADVANCED</name>
            <description>PLL0 advance configuration register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x11000000</resetMask>
            <fields>
              <field>
                <name>SLOW</name>
                <description>Use slow lock flow, PLL lock expendite is disabled.  This mode might be stabler. And software need config LOCKTIME field accordingly.
0: fast lock enabled, lock time is 100us
1: fast lock disabled, lock time is 400us</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DITHER</name>
                <description>Enable dither function</description>
                <bitOffset>24</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>3</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>DIV0,DIV1,DIV2</dimIndex>
            <name>DIV[%s]</name>
            <description>no description available</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xB000003F</resetMask>
            <fields>
              <field>
                <name>BUSY</name>
                <description>Busy flag
0: divider is working
1: divider is changing status</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>Divider response status
0: Divider is not stable
1: Divider is stable for use</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Divider enable status
0: Divider is off
1: Divider is on</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DIV</name>
                <description>Divider factor, divider factor is DIV/5 + 1
0: divide by 1
1: divide by 1.2
2: divide by 1.4
. . .
63: divide by 13.6</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PPOR</name>
      <description>PPOR</description>
      <groupName>PPOR</groupName>
      <baseAddress>0xf4100000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RESET_FLAG</name>
          <description>flag indicate reset source</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>reset reason of last hard reset, write 1 to clear each bit
0: brownout
1: temperature(not available)
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_STATUS</name>
          <description>reset source status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STATUS</name>
              <description>current status of reset sources
0: brownout
1: temperature(not available)
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_HOLD</name>
          <description>reset hold attribute</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HOLD</name>
              <description>hold arrtibute, when set, SOC keep in reset status until reset source release, or, reset will be released after SOC enter reset status
0: brownout
1: temperature(not available)
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET_ENABLE</name>
          <description>reset source enable</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>enable of reset sources
0: brownout
1: temperature(not available)
4: debug reset
5: jtag soft reset
8: cpu0 lockup(not available)
9: cpu1 lockup(not available)
10: cpu0 request(not available)
11: cpu1 request(not available)
16: watch dog 0
17: watch dog 1
18: watch dog 2(not available)
19: watch dog 3(not available)
24: pmic watch dog
30: jtag ieee reset
31: software</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SOFTWARE_RESET</name>
          <description>Software reset counter</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>counter decrease in 24MHz and stop at 0, trigger reset when value reach 2, software can write 0 to cancel reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PCFG</name>
      <description>PCFG</description>
      <groupName>PCFG</groupName>
      <baseAddress>0xf4104000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xac</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BANDGAP</name>
          <description>BANGGAP control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00101010</resetValue>
          <resetMask>0x831F1F1F</resetMask>
          <fields>
            <field>
              <name>VBG_TRIMMED</name>
              <description>Bandgap trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: bandgap is not trimmed
1: bandgap is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOWPOWER_MODE</name>
              <description>Banggap work in low power mode, banggap function limited
0: banggap works in normal mode
1: banggap works in low power mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_SAVE</name>
              <description>Banggap work in power save mode, banggap function normally
0: banggap works in high performance mode
1: banggap works in power saving mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_1P0_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P65_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P50_TRIM</name>
              <description>Banggap 1.0V output trim value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO1P1</name>
          <description>1V LDO config</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0000044C</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>VOLT</name>
              <description>LDO output voltage in mV,  value valid through 700-1320, , step 20mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1320mV.
700: 700mV
720: 720mV
. . .
1320:1320mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO2P5</name>
          <description>2.5V LDO config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x000009C4</resetValue>
          <resetMask>0x10010FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag, will set 1ms after enabled or voltage change
0: LDO is not ready for use
1: LDO is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>LDO enable
0: turn off LDO
1: turn on LDO</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>LDO output voltage in mV,  value valid through 2125-2900, step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 2900mV.
2125: 2125mV
2150: 2150mV
. . .
2900:2900mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_MODE</name>
          <description>DCDC mode select</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x0003047E</resetValue>
          <resetMask>0x10070FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag
0: DCDC is applying new change
1: DCDC is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>DCDC work mode
XX0: turn off
001: basic mode
011: generic mode
101: automatic mode
111: expert mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>DCDC voltage in mV in normal mode,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_LPMODE</name>
          <description>DCDC low power mode</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000384</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>STBY_VOLT</name>
              <description>DCDC voltage in mV in standby mode,  ,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_PROT</name>
          <description>DCDC protection</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x11818191</resetMask>
          <fields>
            <field>
              <name>ILIMIT_LP</name>
              <description>over current setting for low power mode
0:250mA
1:200mA</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLOAD_LP</name>
              <description>over current in low power mode
0: current is below setting
1: overcurrent happened in low power mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_POWER_LOSS</name>
              <description>disable power loss protection
0: power loss protection enabled, DCDC shuts down when power loss
1: power loss protection disabled, DCDC try working after power voltage drop</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_LOSS_FLAG</name>
              <description>power loss
0: input power is good
1: input power is too low</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_OVERVOLTAGE</name>
              <description>output over voltage protection
0: protection enabled, DCDC will shut down is output voltage is unexpected high
1: protection disabled, DCDC continue to adjust output voltage</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERVOLT_FLAG</name>
              <description>output over voltage flag
0: output is normal
1: output is unexpected high</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_SHORT</name>
              <description>disable output short circuit protection
0: short circuits protection enabled, DCDC shut down if short circuit on output detected
1: short circuit protection disabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_CURRENT</name>
              <description>short circuit current setting
0: 2.0A,
1: 1.3A</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_FLAG</name>
              <description>short circuit flag
0: current is within limit
1: short circuits detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_CURRENT</name>
          <description>DCDC current estimation</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000811F</resetMask>
          <fields>
            <field>
              <name>ESTI_EN</name>
              <description>enable current measure</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Current level valid
0: data is invalid
1: data is valid</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEVEL</name>
              <description>DCDC current level, current level is num * 50mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_ADVMODE</name>
          <description>DCDC advance setting</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x05120067</resetValue>
          <resetMask>0x073F006F</resetMask>
          <fields>
            <field>
              <name>EN_RCSCALE</name>
              <description>Enable RC scale</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_C</name>
              <description>Loop C number</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_R</name>
              <description>Loop R number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_DET</name>
              <description>enable feed forward detect
0: feed forward detect is disabled
1: feed forward detect is enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_LOOP</name>
              <description>enable feed forward loop
0: feed forward loop is disabled
1: feed forward loop is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM_EXIT</name>
              <description>avoid over voltage
0: stay in DCM mode when voltage excess
1: change to CCM mode when voltage excess</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SKIP</name>
              <description>enable skip on narrow pulse
0: do not skip narrow pulse
1: skip narrow pulse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_IDLE</name>
              <description>enable skip when voltage is higher than threshold
0: do not skip
1: skip if voltage is excess</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM</name>
              <description>DCM mode
0: CCM mode
1: DCM mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_ADVPARAM</name>
          <description>DCDC advance parameter</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00006E1C</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>MIN_DUT</name>
              <description>minimum duty cycle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_DUT</name>
              <description>maximum duty cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_MISC</name>
          <description>DCDC misc parameter</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00070100</resetValue>
          <resetMask>0x13170317</resetMask>
          <fields>
            <field>
              <name>EN_HYST</name>
              <description>hysteres enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_SIGN</name>
              <description>hysteres sign</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_THRS</name>
              <description>hysteres threshold</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_SCALE</name>
              <description>Loop RC scale threshold</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_FF</name>
              <description>Loop feed forward number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_THRE</name>
              <description>overload for threshold for lod power mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_HYST</name>
              <description>current hysteres range
0: 12.5mV
1: 25mV</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY</name>
              <description>enable delay
0: delay disabled,
1: delay enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>clock selection
0: select DCDC internal oscillator
1: select RC24M oscillator</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_STEP</name>
              <description>enable stepping in voltage change
0: stepping disabled,
1: steping enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_DEBUG</name>
          <description>DCDC Debug</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00005DBF</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>UPDATE_TIME</name>
              <description>DCDC voltage change time in 24M clock cycles, default value is 1mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_START_TIME</name>
          <description>DCDC ramp time</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x0001193F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>START_TIME</name>
              <description>Start delay for DCDC to turn on, in 24M clock cycles, default value is 3mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDC_RESUME_TIME</name>
          <description>DCDC resume time</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00008C9F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>RESUME_TIME</name>
              <description>Resume delay for DCDC to recover from low power mode, in 24M clock cycles, default value is 1.5mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POWER_TRAP</name>
          <description>power trap</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80010001</resetMask>
          <fields>
            <field>
              <name>TRIGGERED</name>
              <description>Low power trap status, thit bit will set when power related low power flow triggered, write 1 to clear this flag.
0: low power trap is not triggered
1: low power trap triggered</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RETENTION</name>
              <description>DCDC enter standby mode, which will reduce voltage for memory content retention
0: Shutdown DCDC
1: reduce DCDC voltage</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRAP</name>
              <description>Enable trap of SOC power supply, trap is used to hold SOC in low power mode for DCDC to enter further low power mode, this bit will self-clear when power related low pwer flow triggered
0: trap not enabled, pmic side low power function disabled
1: trap enabled, STOP operation leads to PMIC low power flow if SOC is not retentioned.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE_CAUSE</name>
          <description>Wake up source</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAUSE</name>
              <description>wake up cause, each bit represents one wake up source, write 1 to clear the register bit
0: wake up source is not active during last wakeup
1: wake up source is active furing last wakeup
bit 0: pmic_enable
bit 5: VAD interrupt
bit 6: VAD wake interrupt
bit 7: UART interrupt
bit 8: TMR interrupt
bit 9: WDG interrupt
bit10: GPIO in PMIC interrupt
bit16: Security violation in BATT
bit17: GPIO in BATT interrupt
bit19: RTC alarm interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKE_MASK</name>
          <description>Wake up mask</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MASK</name>
              <description>mask for wake up sources, each bit represents one wakeup source
0: allow source to wake up system
1: disallow source to wakeup system
bit 0: pmic_enable
bit 5: VAD interrupt
bit 6: VAD wake interrupt
bit 7: UART interrupt
bit 8: TMR interrupt
bit 9: WDG interrupt
bit10: GPIO in PMIC interrupt
bit16: Security violation in BATT
bit17: GPIO in BATT interrupt
bit19: RTC alarm interrupt</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCG_CTRL</name>
          <description>Clock gate control in PMIC</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SCG</name>
              <description>control whether clock being gated during PMIC low power flow, 2 bits for each peripheral
00,01: reserved
10: clock is always off
11: clock is always on
bit6-7:gpio
bit8-9:ioc
bit10-11: timer
bit12-13:wdog
bit14-15:uart
bit16-17:VAD
bit18-19:SRAM</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RC24M</name>
          <description>RC 24M config</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000310</resetValue>
          <resetMask>0x8000071F</resetMask>
          <fields>
            <field>
              <name>RC_TRIMMED</name>
              <description>RC24M trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: RC is not trimmed
1: RC is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_C</name>
              <description>Coarse trim for RC24M, bigger value means faster</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_F</name>
              <description>Fine trim for RC24M, bigger value means faster</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RC24M_TRACK</name>
          <description>RC 24M track mode</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010011</resetMask>
          <fields>
            <field>
              <name>SEL24M</name>
              <description>Select track reference
0: select 32K as reference
1: select 24M XTAL as reference</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RETURN</name>
              <description>Retrun default value when XTAL loss
0: remain last tracking value
1: switch to default value</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRACK</name>
              <description>track mode
0: RC24M free running
1: track RC24M to external XTAL</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRACK_TARGET</name>
          <description>RC 24M track target</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_DIV</name>
              <description>Divider for reference source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TARGET</name>
              <description>Target frequency multiplier of divided source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>RC 24M track status</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0011871F</resetMask>
          <fields>
            <field>
              <name>SEL32K</name>
              <description>track is using XTAL32K
0: track is not using XTAL32K
1: track is using XTAL32K</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SEL24M</name>
              <description>track is using XTAL24M
0: track is not using XTAL24M
1: track is using XTAL24M</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EN_TRIM</name>
              <description>default value takes effect
0: default value is invalid
1: default value is valid</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIM_C</name>
              <description>default coarse trim value</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIM_F</name>
              <description>default fine trim value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_MODE</name>
          <description>DCDCM mode select</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00030546</resetValue>
          <resetMask>0x10070FFF</resetMask>
          <fields>
            <field>
              <name>READY</name>
              <description>Ready flag
0: DCDCM is applying new change
1: DCDCM is ready</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MODE</name>
              <description>DCDCM work mode
XX0: turn off
001: basic mode
011: generic mode
101: automatic mode
111: expert mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VOLT</name>
              <description>DCDCM voltage in mV in normal mode,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_LPMODE</name>
          <description>DCDCM low power mode</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000546</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>STBY_VOLT</name>
              <description>DCDCM voltage in mV in standby mode,  ,  value valid through 600-1375, , step 25mV.  Hardware select voltage no less than target if not on valid steps, with maximum 1375mV.
600: 600mV
625: 625mV
. . .
1375:1375mV</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_PROT</name>
          <description>DCDCM protection</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <resetMask>0x11818191</resetMask>
          <fields>
            <field>
              <name>ILIMIT_LP</name>
              <description>over current setting for low power mode
0:250mA
1:200mA</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLOAD_LP</name>
              <description>over current in low power mode
0: current is below setting
1: overcurrent happened in low power mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_POWER_LOSS</name>
              <description>disable power loss protection
0: power loss protection enabled, DCDCM shuts down when power loss
1: power loss protection disabled, DCDCM try working after power voltage drop</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_LOSS_FLAG</name>
              <description>power loss
0: input power is good
1: input power is too low</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_OVERVOLTAGE</name>
              <description>output over voltage protection
0: protection enabled, DCDCM will shut down is output voltage is unexpected high
1: protection disabled, DCDCM continue to adjust output voltage</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERVOLT_FLAG</name>
              <description>output over voltage flag
0: output is normal
1: output is unexpected high</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DISABLE_SHORT</name>
              <description>disable output short circuit protection
0: short circuits protection enabled, DCDCM shut down if short circuit on output detected
1: short circuit protection disabled</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_CURRENT</name>
              <description>short circuit current setting
0: 2.0A
1: 1.3A</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHORT_FLAG</name>
              <description>short circuit flag
0: current is within limit
1: short circuits detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_CURRENT</name>
          <description>DCDCM current estimation</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000811F</resetMask>
          <fields>
            <field>
              <name>ESTI_EN</name>
              <description>enable current measure</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Current level valid
0: data is invalid
1: data is valid</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LEVEL</name>
              <description>DCDCM current level, current level is num * 50mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_ADVMODE</name>
          <description>DCDCM advance setting</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x05120067</resetValue>
          <resetMask>0x073F007F</resetMask>
          <fields>
            <field>
              <name>EN_RCSCALE</name>
              <description>Enable RC scale</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_C</name>
              <description>Loop C number</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_R</name>
              <description>Loop R number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_DET</name>
              <description>enable feed forward detect
0: feed forward detect is disabled
1: feed forward detect is enabled</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_FF_LOOP</name>
              <description>enable feed forward loop
0: feed forward loop is disabled
1: feed forward loop is enabled</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_AUTOLP</name>
              <description>enable auto enter low power mode
0: do not enter low power mode
1: enter low power mode if current is detected low</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM_EXIT</name>
              <description>avoid over voltage
0: stay in DCM mode when voltage excess
1: change to CCM mode when voltage excess</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SKIP</name>
              <description>enable skip on narrow pulse
0: do not skip narrow pulse
1: skip narrow pulse</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_IDLE</name>
              <description>enable skip when voltage is higher than threshold
0: do not skip
1: skip if voltage is excess</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_DCM</name>
              <description>DCM mode
0: CCM mode
1: DCM mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_ADVPARAM</name>
          <description>DCDCM advance parameter</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <resetValue>0x0000701C</resetValue>
          <resetMask>0x00007F7F</resetMask>
          <fields>
            <field>
              <name>MIN_DUT</name>
              <description>minimum duty cycle</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MAX_DUT</name>
              <description>maximum duty cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_MISC</name>
          <description>DCDCM misc parameter</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <resetValue>0x00070100</resetValue>
          <resetMask>0x13170317</resetMask>
          <fields>
            <field>
              <name>EN_HYST</name>
              <description>hysteres enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_SIGN</name>
              <description>hysteres sign</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HYST_THRS</name>
              <description>hysteres threshold</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RC_SCALE</name>
              <description>Loop RC scale threshold</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DC_FF</name>
              <description>Loop feed forward number</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_THRE</name>
              <description>overload for threshold for lod power mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OL_HYST</name>
              <description>current hysteres range
0: 12.5mV
1: 25mV</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DELAY</name>
              <description>enable delay
0: delay disabled,
1: delay enabled</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>clock selection
0: select DCDCM internal oscillator
1: select RC24M oscillator</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_STEP</name>
              <description>enable stepping in voltage change
0: stepping disabled,
1: steping enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_DEBUG</name>
          <description>DCDCM Debug</description>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <resetValue>0x00005DBF</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>UPDATE_TIME</name>
              <description>DCDCM voltage change time in 24M clock cycles, default value is 1mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_START_TIME</name>
          <description>DCDCM ramp time</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x0001193F</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>START_TIME</name>
              <description>Start delay for DCDCM to turn on, in 24M clock cycles, default value is 3mS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_RESUME_TIME</name>
          <description>DCDCM resume time</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x000000F0</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>RESUME_TIME</name>
              <description>Resume delay for DCDCM to recover from low power mode, in 24M clock cycles, default value is 10uS</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCDCM_POWER_CONFIG</name>
          <description>DCDCM power config</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00010000</resetMask>
          <fields>
            <field>
              <name>RETENTION</name>
              <description>DCDCM enter standby mode, which will reduce voltage for memory content retention
0: Shutdown DCDCM
1: reduce DCDC voltage</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PGPR0</name>
      <description>PGPR0</description>
      <groupName>PGPR</groupName>
      <baseAddress>0xf4110000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMIC_GPR00</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR01</name>
          <description>Generic control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR02</name>
          <description>Generic control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR03</name>
          <description>Generic control</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR04</name>
          <description>Generic control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR05</name>
          <description>Generic control</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR06</name>
          <description>Generic control</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR07</name>
          <description>Generic control</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR08</name>
          <description>Generic control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR09</name>
          <description>Generic control</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR10</name>
          <description>Generic control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR11</name>
          <description>Generic control</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR12</name>
          <description>Generic control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR13</name>
          <description>Generic control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR14</name>
          <description>Generic control</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_GPR15</name>
          <description>Generic control</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="PGPR0">
      <name>PGPR1</name>
      <description>PGPR1</description>
      <groupName>PGPR</groupName>
      <baseAddress>0xf4114000</baseAddress>
    </peripheral>
    <peripheral>
      <name>VAD</name>
      <description>VAD</description>
      <groupName>VAD</groupName>
      <baseAddress>0xf412c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xa4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0FF7FBFF</resetMask>
          <fields>
            <field>
              <name>CAPT_DLY</name>
              <description>Capture cycle delay&gt;=0, should be less than PDM_CLK_HFDIV</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_HFDIV</name>
              <description>The clock divider will work at least 4.
0: div-by-2,
1: div-by-4
. . .
n: div-by-2*(n+1)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VAD_IE</name>
              <description>VAD event interrupt enable</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OFIFO_AV_IE</name>
              <description>OFIFO data available interrupt enable</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMBUF_EMPTY_IE</name>
              <description>Buf empty interrupt enable</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OFIFO_OVFL_ERR_IE</name>
              <description>OFIFO overflow error interrupt enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IIR_OVLD_ERR_IE</name>
              <description>IIR overload error interrupt enable</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IIR_OVFL_ERR_IE</name>
              <description>IIR overflow error interrupt enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_OVLD_ERR_IE</name>
              <description>CIC overload Interrupt Enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC_SAT_ERR_IE</name>
              <description>CIC saturation Interrupt Enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MEMBUF_DISABLE</name>
              <description>asserted to disable membuf</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_THRSH</name>
              <description>OFIFO threshold to generate ofifo_av (when fillings &gt;= threshold) (fifo size: max 16 items, 16*32bits)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_DIV_BYPASS</name>
              <description>asserted to bypass the pdm clock divider</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDM_CLK_OE</name>
              <description>pdm_clk_output_en</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_POL</name>
              <description>Asserted to select PDM_CLK high level captured, otherwise to select PDM_CLK low level captured.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CHNUM</name>
              <description>the number of channels to be stored in buffer. Asserted to enable 2 channels.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FILTCTRL</name>
          <description>Filter Control Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>DECRATIO</name>
              <description>the decimation ratio of iir after CIC -1
2: means dec-by-3</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IIR_SLOT_EN</name>
              <description>IIR slot enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEC_CTRL0</name>
          <description>Decision Control Register 0</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF03FF</resetMask>
          <fields>
            <field>
              <name>NOISE_TOL</name>
              <description>the value of amplitude for noise determination when calculationg ZCR</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLK_CFG</name>
              <description>asserted to have 3 sub-blocks, otherwise to have 2 sub-blocks</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SUBBLK_LEN</name>
              <description>length of sub-block</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEC_CTRL1</name>
          <description>Decision Control Register 1</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003FFFFF</resetMask>
          <fields>
            <field>
              <name>ZCR_HIGH</name>
              <description>ZCR high limit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZCR_LOW</name>
              <description>ZCR low limit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEC_CTRL2</name>
          <description>Decision Control Register 2</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AMP_HIGH</name>
              <description>amplitude high limit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP_LOW</name>
              <description>amplitude low limit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ST</name>
          <description>Status</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>VAD</name>
              <description>VAD event found</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OFIFO_AV</name>
              <description>OFIFO data available</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MEMBUF_EMPTY</name>
              <description>Buf empty</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OFIFO_OVFL</name>
              <description>OFIFO overflow</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IIR_OVLD</name>
              <description>IIR overloading</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>IIR_OVFL</name>
              <description>IIR oberflow</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CIC_OVLD_ERR</name>
              <description>CIC overload</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CIC_SAT_ERR</name>
              <description>CIC saturation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OFIFO</name>
          <description>Out FIFO</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>D</name>
              <description>The PCM data.
When there is only one channel, the samples are from Ch0, and the 2 samples in the 32-bits are: bit [31:16]: the samples earlier in time ([T-1]). Bit [15:0]: the samples later in time ([T]).
When there is two channels, the samples in the 32-bits are: bit [31:16]: the samples belong to Ch 1 (when ch_pol[1:0]==2, the data is captured at the positive part of the pdm clk). bit [15:0]: the samples belong to Ch 0 (when ch_pol[1:0]==2, the data is captured at the negtive part of the pdm clk).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RUN</name>
          <description>Run Command Register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>SFTRST</name>
              <description>software reset. Self-clear</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VAD_EN</name>
              <description>module enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OFIFO_CTRL</name>
          <description>Out FIFO Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Asserted to enable OFIFO</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CIC_CFG</name>
          <description>CIC Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FC00</resetMask>
          <fields>
            <field>
              <name>POST_SCALE</name>
              <description>the shift value after CIC results.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>STE_ACT</dimIndex>
          <name>COEF[%s]</name>
          <description>no description available</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>The current detected short time energy</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MIPI_DSI_PHY0</name>
      <description>MIPI_DSI_PHY0</description>
      <groupName>MIPI_DSI_PHY</groupName>
      <baseAddress>0xf4140000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x94</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>clane_para0</name>
          <description>timer counter about clock lane parameter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_RST2ENLPTX_C</name>
              <description>the soft reset of clk_cfg domain</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clane_para1</name>
          <description>timer counter about clock lane parameter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_INITTIME_C</name>
              <description>the number of byteclk cycles that clklane drive LP-11 during initialization period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clane_para2</name>
          <description>timer counter about clock lane parameter</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00808080</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>T_CLKPREPARE_C</name>
              <description>the number of byteclk cycles that clock lane clkp/n lines are at the hs prepare state lp-00 during a hs clock transmission</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CLKZERO_C</name>
              <description>the number of byteclk cycles that clock lane clkp/n lines are at the hs-zero state hs-0 during a hs clock transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CLKPRE_C</name>
              <description>the number of byteclk cycles that hs clock shall be driven prior to data lane beginning the transition from lp to hs mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clane_para3</name>
          <description>timer counter about clock lane parameter</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00808080</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>T_CLKPOST_C</name>
              <description>the number of byteclk cycles that the clock lane should keep sending the hs-clock after the last associated data lane has transitioned to LP mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CLKTRIAL_C</name>
              <description>the number of byteclk cycles that the clock lane clkp/n lines are at state hs-tail sate hs-0 during a hs clock transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSEXIT_C</name>
              <description>the number of byteclk cycles that the clock lane clkp/n lines are at hs-exit state after a hs clock transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane0_para0</name>
          <description>timer counter about datalane0 parameter</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_RST2ENLPTX_D0</name>
              <description>the number of byteclk cycles that datalane0 wait to enable lptx_en after reset release</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane0_para1</name>
          <description>timer counter about datalane0 parameter</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000014</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_INITTIME_D0</name>
              <description>the number of byteclk cycles that datalane0 drive lp-11 during initiaalization period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane0_para2</name>
          <description>timer counter about datalane0 parameter</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x80808080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_HSPREPARE_D0</name>
              <description>the number of byteclk cycles that the datalane0 stay at hs prepare state lp-00 during a hs transmission</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSZERO_D0</name>
              <description>the number of byteclk cycles that the datalane0 stay at hs-zero sate during a hs transmission</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSTRAIL_D0</name>
              <description>the number of byteclk cycles that the datalane0 stay at hs-trail state during a hs clock transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSEXIT_D0</name>
              <description>the number of byteclk cycles that the datalane0 stay at state hs-exit sate after a hs clock transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane0_para3</name>
          <description>timer counter about datalane0 parameter</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_WAKEUP_D0</name>
              <description>the number of byteclk cycles from exiting ultra low power sate to enabling the low-power driver</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane0_para4</name>
          <description>timer counter about datalane0 parameter</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00808080</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>T_TAGO_D0</name>
              <description>the number of byteclk cycles that the tx drives the bridge state during a turnaroud procedure</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_TASURE_D0</name>
              <description>the number of byteclk cycles that the rx waits after a bridge state has been detected during a turnaround procedure</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_TAGET_D0</name>
              <description>the number of byteclk cycles that the new transmitter drivers the bridge state after accepting control during bta</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane1_para0</name>
          <description>timer counter about datalane1 parameter</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_RST2ENLPTX_D1</name>
              <description>the number of byteclk cycles that datalane1 wait to enable lptx_en after reset release</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane1_para1</name>
          <description>timer counter about datalane1 parameter</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000014</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_INITTIME_D1</name>
              <description>the number of byteclk cycles that datalane1 drive lp-11 during initiaalization period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane1_para2</name>
          <description>timer counter about datalane1 parameter</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x80808080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_HSPREPARE_D1</name>
              <description>the number of byteclk cycles that the datalane1 stay at hs prepare state lp-00 during a hs transmission</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSZERO_D1</name>
              <description>the number of byteclk cycles that the datalane1 stay at hs-zero sate during a hs transmission</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSTRAIL_D1</name>
              <description>the number of byteclk cycles that the datalane1 stay at hs-trail state during a hs clock transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSEXIT_D1</name>
              <description>the number of byteclk cycles that the datalane1 stay at state hs-exit sate after a hs clock transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane1_para3</name>
          <description>timer counter about datalane1 parameter</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_WAKEUP_D1</name>
              <description>the number of byteclk cycles from exiting ultra low power sate to enabling the low-power driver</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane2_para0</name>
          <description>timer counter about datalane2 parameter</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_RST2ENLPTX_D2</name>
              <description>the number of byteclk cycles that datalane2 wait to enable lptx_en after reset release</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane2_para1</name>
          <description>timer counter about datalane2 parameter</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000014</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_INITTIME_D2</name>
              <description>the number of byteclk cycles that datalane2 drive lp-11 during initiaalization period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane2_para2</name>
          <description>timer counter about datalane2 parameter</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x80808080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_HSPREPARE_D2</name>
              <description>the number of byteclk cycles that the datalane2 stay at hs prepare state lp-00 during a hs transmission</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSZERO_D2</name>
              <description>the number of byteclk cycles that the datalane2 stay at hs-zero sate during a hs transmission</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSTRAIL_D2</name>
              <description>the number of byteclk cycles that the datalane2 stay at hs-trail state during a hs clock transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSEXIT_D2</name>
              <description>the number of byteclk cycles that the datalane2 stay at state hs-exit sate after a hs clock transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane2_para3</name>
          <description>timer counter about datalane2 parameter</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_WAKEUP_D2</name>
              <description>the number of byteclk cycles from exiting ultra low power sate to enabling the low-power driver</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane3_para0</name>
          <description>timer counter about datalane3 parameter</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000050</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_RST2ENLPTX_D3</name>
              <description>the number of byteclk cycles that datalane3 wait to enable lptx_en after reset release</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane3_para1</name>
          <description>timer counter about datalane3 parameter</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000014</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_INITTIME_D3</name>
              <description>the number of byteclk cycles that datalane3 drive lp-11 during initiaalization period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane3_para2</name>
          <description>timer counter about datalane3 parameter</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x80808080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_HSPREPARE_D3</name>
              <description>the number of byteclk cycles that the datalane3 stay at hs prepare state lp-00 during a hs transmission</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSZERO_D3</name>
              <description>the number of byteclk cycles that the datalane3 stay at hs-zero sate during a hs transmission</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSTRAIL_D3</name>
              <description>the number of byteclk cycles that the datalane3 stay at hs-trail state during a hs clock transmission</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_HSEXIT_D3</name>
              <description>the number of byteclk cycles that the datalane3 stay at state hs-exit sate after a hs clock transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>dlane3_para3</name>
          <description>timer counter about datalane3 parameter</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_WAKEUP_D3</name>
              <description>the number of byteclk cycles from exiting ultra low power sate to enabling the low-power driver</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>common_para0</name>
          <description>timing parameter for all lanes</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000014</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>T_LPX</name>
              <description>the number of byteclk cycles of transmitted length of any low-power state period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ctrl_para0</name>
          <description>dphy control parameter</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x000000E0</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>VBG_RDY</name>
              <description>the indicator signal of reference generator is ready</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>EN_ULPRX_D0</name>
              <description>ulp-rx enable for lane0</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LPRX_D0</name>
              <description>lp-rx enable for lane0</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_LPCD_D0</name>
              <description>lp-cd enable for lane0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWON_SEL</name>
              <description>select the cource of PMA power on control signals</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWON_PLL</name>
              <description>power on pll high active</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWON_DSI</name>
              <description>power on all dsi lane</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SU_IDDQ_EN</name>
              <description>power down all modules inside su includes ivref, r-calibration and pll, high effective</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pll_ctrl_para0</name>
          <description>dphy pll control parameter</description>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x01029AB6</resetValue>
          <resetMask>0x0FFFFFFF</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>pll lock indication</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RATE</name>
              <description>data reate control signal</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>REFCLK_DIV</name>
              <description>input reference clock divider ratio control</description>
              <bitOffset>19</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_DIV</name>
              <description>pll loop divider ratio control</description>
              <bitOffset>4</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_PIXELCLK_DIV</name>
              <description>pixell clock divided from pll output</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>rcal_ctrl</name>
          <description>dphy calibration control parameter</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00002E00</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>RCAL_EN</name>
              <description>enable hs-tx output impedance trimming</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RCAL_TRIM</name>
              <description>default value of hs-tx output resistance configure</description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RCAL_CTRL</name>
              <description>resistor calibration control, reserved for test</description>
              <bitOffset>1</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RCAL_DONE</name>
              <description>hs-tx output impedance trimming done indicator signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>trim_para</name>
          <description>dphy trimming parameter</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00003322</resetValue>
          <resetMask>0x00003FFF</resetMask>
          <fields>
            <field>
              <name>HSTX_AMP_TRIM</name>
              <description>hs-tx output vod trimming for lane-0~4</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPTX_SR_TRIM</name>
              <description>lp-tx output slew-rate trimming for lane0~4</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPRX_VREF_TRIM</name>
              <description>lp-rx input threshold voltage trimming for lane0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPCD_VREF_TRIM</name>
              <description>lp-cd input threshold voltage trimming for lane0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>test_para0</name>
          <description>dphy test control parameter</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x007FFFFF</resetMask>
          <fields>
            <field>
              <name>ERROR_NUM</name>
              <description>the byte num of mismatch data of lane in bist mode</description>
              <bitOffset>17</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_N_DONE</name>
              <description>indicate prbs7 bist test is done</description>
              <bitOffset>12</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_N_OK</name>
              <description>indicate prbs7 bist test is ok</description>
              <bitOffset>7</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ATEST_EN</name>
              <description>analog test signal enable</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATEST_SEL</name>
              <description>analog test signal select</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FSET_EN</name>
              <description>enable fast transmission between lp-tx and hs-tx</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FT_SEL</name>
              <description>pt/ft test mode select</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>test_para1</name>
          <description>dphy bist test control parameter</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x009C40C0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHECK_NUM</name>
              <description>the byte num of prbs bist check num</description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_THRESHOLD</name>
              <description>the threshold of prbs bit error</description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_BIT_ERROR</name>
              <description>enable insert error in bist test pattern</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_EN</name>
              <description>bist enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_SEL</name>
              <description>bist mode select</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRBS_SEL</name>
              <description>prbs generator and checker pattern select signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>misc_para</name>
          <description>dphy control parameter</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x0000007F</resetValue>
          <resetMask>0x000007FF</resetMask>
          <fields>
            <field>
              <name>DLL_SEL</name>
              <description>the phase select of clk_rxesc</description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LANE_NUM</name>
              <description>the number of active data lanes</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHYERR_MASK</name>
              <description>mask the phy error</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clane_para4</name>
          <description>dphy clock lane control parameter</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T_WAKEUP_C</name>
              <description>the number of byteclk cycles from exiting ultra low power state to enabling the low-power driver</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>interface_para</name>
          <description>dphy clock lane control parameter</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000301</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>TXREADYESC_EXTEND_VLD</name>
              <description>the extend length of txreadyesc</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RXVALIDESC_EXTEND_VLD</name>
              <description>the extend length of rxvalidesc</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pcs_reserved_pin_para</name>
          <description>reserved the pins for pcs</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000001F</resetMask>
          <fields>
            <field>
              <name>CLK_TXHS_SEL_INNER</name>
              <description>select the clock source of clk_txhs in pcs</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_CLK_TXHS</name>
              <description>clk_txhs inverter signal</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_CLK_TXESC</name>
              <description>clk_txesc inverter signal</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_PCLK</name>
              <description>pclk inverter signal</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_DSI_RCLK</name>
              <description>pma clock dsi_rclk_i inverter signal</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clane_data_para</name>
          <description>parallel data about clock lane parameter</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x000000AA</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>CLANE_DATA_SEL</name>
              <description>select the data about clock lane</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLANE_DATA</name>
              <description>the parallel data about clock lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>pma_lane_sel_para</name>
          <description>pma about clock lane select parameter</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <resetValue>0x0000000D</resetValue>
          <resetMask>0x0000000F</resetMask>
          <fields>
            <field>
              <name>PMA_DLANE4_SEL</name>
              <description>select the channel 4 as the data lane</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMA_DLANE3_SEL</name>
              <description>select the channel 3 as the data lane</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMA_DLANE2_SEL</name>
              <description>select the channel 2 as the data lane</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMA_DLANE1_SEL</name>
              <description>select the channel 1 as the data lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MIPI_DSI_PHY0">
      <name>MIPI_DSI_PHY1</name>
      <description>MIPI_DSI_PHY1</description>
      <groupName>MIPI_DSI_PHY</groupName>
      <baseAddress>0xf4144000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MIPI_CSI_PHY0</name>
      <description>MIPI_CSI_PHY0</description>
      <groupName>MIPI_CSI_PHY</groupName>
      <baseAddress>0xf4148000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xd28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>soft_rst</name>
          <description>soft reset control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>HS_CLK_SOFT_RST</name>
              <description>the soft reset of clk_hs domain</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG_CLK_SOFT_RST</name>
              <description>the soft reset of clk_cfg domain</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>phy_rcal</name>
          <description>dphy resistor calibration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x0000E00F</resetValue>
          <resetMask>0x0003FFFF</resetMask>
          <fields>
            <field>
              <name>RCAL_DONE</name>
              <description>hs-rx terminal trimming done indicator signal</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCAL_OUT</name>
              <description>hs-rx terminal trimming results</description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RCAL_CTL</name>
              <description>rcal function control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RCAL_TRIM</name>
              <description>default value of HS-RX terminal configure</description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RCAL_EN</name>
              <description>enable hs-rx terminal trimming</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ulp_rx_en</name>
          <description>enable lprx and ulprx</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x000000E3</resetValue>
          <resetMask>0x000000E3</resetMask>
          <fields>
            <field>
              <name>CSI_1_ULPRX_EN</name>
              <description>data lane1 ulp-rx receiver enable control</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_0_ULPRX_EN</name>
              <description>data lane0 ulp-rx receiver enable control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CLK_ULPRX_EN</name>
              <description>clock lane ulp-rx receiver enable control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_1_LPRX_EN</name>
              <description>data lane1 lp-rx receiver enable control</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CLK_LPRX_EN</name>
              <description>clock lane lp=rx receiver enable control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>voffcal_out</name>
          <description>hs-rx dc-offset auto-calibration results</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3FFFF000</resetMask>
          <fields>
            <field>
              <name>CSI_CLK_VOFFCAL_DONE</name>
              <description>clock lane hs-rx dc-offset auto-calibration done</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_CLK_VOFFCAL_OUT</name>
              <description>clock lane hs-rx dc-offset auto-calibration results</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_0_VOFFCAL_DONE</name>
              <description>data lane0 hs-rx dc-offset auto-calibration done</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_O_VOFFCAL_OUT</name>
              <description>data lane0 hs-rx dc-offset auto-calibration result</description>
              <bitOffset>18</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_1_VOFFCAL_DONE</name>
              <description>data lane1 hs-rx dc-offset auto-calibration done</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_1_VOFFCAL_OUT</name>
              <description>data lane1 hs-rx dc-offset auto-calibration result</description>
              <bitOffset>12</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>csi_ctl01</name>
          <description>dphy hardcore control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3F7F3F7F</resetMask>
          <fields>
            <field>
              <name>CSI_CTL1_7</name>
              <description>clock lane hs-rx dc-offset auto-calibration enable</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_6</name>
              <description>clock lane hs-rx dc-offset trimming control</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_5</name>
              <description>ulprx_vref_trim</description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_4</name>
              <description>bypass hs_rx_voffcal_en</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_3</name>
              <description>hs_rx_voffcal_trim_polar</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_2</name>
              <description>ulprx_lpen</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_1</name>
              <description>force data lane-n and clock lane lp/ulprx to be normal operation</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL1_0</name>
              <description>force data lane-n and clock lane hs-rx to be normal operation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_7</name>
              <description>clock lane hs-rx dc-offset auto-calibration enable</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_6</name>
              <description>clock lane hs-rx dc-offset trimming control</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_5</name>
              <description>ulprx_vref_trim</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_4</name>
              <description>bypass hs_rx_voffcal_en</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_3</name>
              <description>hs_rx_voffcal_trim_polar</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_2</name>
              <description>ulprx_lpen</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_1</name>
              <description>force data lane-n and clock lane lp/ulprx to be normal operation</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL0_0</name>
              <description>force data lane-n and clock lane hs-rx to be normal operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>csi_ctl23</name>
          <description>dphy hardcore control</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x1F1F0000</resetMask>
          <fields>
            <field>
              <name>CSI_CTL3_3</name>
              <description>data lane-1 skew trimming enable</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL3_2</name>
              <description>data lane-1 hs-rx skew adjust with binary code</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL3_1</name>
              <description>data lane-0 skew trimming enable</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CTL3_0</name>
              <description>data lane-0 hs-rx skew adjust with binary code</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>csi_vinit</name>
          <description>ulp lp-rx input threshold voltage trimming for data lane</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00200000</resetValue>
          <resetMask>0x00FF00FF</resetMask>
          <fields>
            <field>
              <name>CSI_LPRX_VREF_TRIM</name>
              <description>pt ft indicator in csi clk data lane</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSI_CLK_LPRX_VINT</name>
              <description>pt ft indicator in csi clk lane</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_1_LPRX_VINIT</name>
              <description>pt ft indicator in csi lane-1</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSI_0_LPRX_VINIT</name>
              <description>pt ft indicator in csi lane-0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>clane_para</name>
          <description>clock lane parameter</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000314</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_CLK_TERMEN</name>
              <description>time for the clock lane receiver to enable the HS line termination</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_CLK_SETTLE</name>
              <description>the value of tclk-settle of clklane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>t_hs_termen</name>
          <description>t-termen of all datalane</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000303</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_D1_TERMEN</name>
              <description>the value of ths-termen of datalane1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_D0_TERMEN</name>
              <description>the value of ths-termen of datalane0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>t_hs_settle</name>
          <description>t-settle of all data lanes</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000A0A</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>T_D1_SETTLE</name>
              <description>the value of ths-settle of data lane1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>T_D0_SETTLE</name>
              <description>the value of ths-settle of data lane0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>t_clane_init</name>
          <description>t-init of clock lane</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00007530</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>T_CLK_INIT</name>
              <description>initialization time of lock lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>t_lane_init0</name>
          <description>t-init of data lane0</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00007530</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>T_D0_INIT</name>
              <description>initialization time of data lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>t_lane_init1</name>
          <description>t-init of data lane1</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00007530</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>T_D1_INIT</name>
              <description>initialization time of data lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>tlpx_ctrl</name>
          <description>the time of tlpx_ctrl of all lane</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000002</resetValue>
          <resetMask>0x000001FF</resetMask>
          <fields>
            <field>
              <name>EN_TLPX_CHECK</name>
              <description>enable the tlpx width check</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TLPX</name>
              <description>the width of tlpx</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ne_swap</name>
          <description>lane swap and dp/dn swap select</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000004</resetValue>
          <resetMask>0x0000030F</resetMask>
          <fields>
            <field>
              <name>DPDN_SWAP_LANE1</name>
              <description>datalane1 dpdn swap</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DPDN_SWAP_LAN0</name>
              <description>datalane0 dpdn swap</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LANE_SWAP_LAN1</name>
              <description>data lane1 swap</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LANE_SWAP_LANE0</name>
              <description>data lane0 swap</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>misc_info</name>
          <description>misc info of dphyrx_pcs control</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ULPS_LP10_SEL</name>
              <description>the lp10 select signal in ulps_exit state</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LONG_SOTSYNC_EN</name>
              <description>at least six zero is checked before sot swquence "00011101"</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>bist_test0</name>
          <description>bist test control</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000CF</resetMask>
          <fields>
            <field>
              <name>BIST_DONE_LAN1</name>
              <description>bist_done of lane1</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_DONE_LAN0</name>
              <description>bist_done of lane0</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_OK_LANE1</name>
              <description>bist_ok of lane1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_OK_LANE0</name>
              <description>bist_ok of lane0</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BIST_EN_SEL</name>
              <description>the source of bist_en sel</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BIST_EN_SOFT</name>
              <description>enable prbs bist test</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>bist_test1</name>
          <description>bist test control</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000100</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRBS_CHECK_NUM</name>
              <description>the byte num of prbs bist check num</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>bist_test2</name>
          <description>bist test control</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x007F0005</resetValue>
          <resetMask>0x00FFFFFF</resetMask>
          <fields>
            <field>
              <name>PRBS_SEED</name>
              <description>the seed of prbs7</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRBS_ERR_THRESHOLD</name>
              <description>the threshold of prbs bist error</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>bist_test3</name>
          <description>bist test control</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRBS_ERR_NUM_LAN1</name>
              <description>the byte num of mismatch data of data lane1 in bist mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRBS_ERR_NUM_LAN0</name>
              <description>the byte num of mismatch data of data lane0 in bist mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test0</name>
          <description>burn-in test control</description>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000004F</resetMask>
          <fields>
            <field>
              <name>BURN_IN_OK_CLAN</name>
              <description>burn_in_ok of clock lane</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BURN_IN_OK_LAN1</name>
              <description>burn_in_ok of lane1</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BURN_IN_OK_LAN0</name>
              <description>burn_in_ok of lane0</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BURN_IN_EN_SEL</name>
              <description>the source of prbs burn_in_en sel</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BURN_IN_EN_SOFT</name>
              <description>enable prbs burn_in test</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test1</name>
          <description>burn-in test control</description>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000000FF</resetMask>
          <fields>
            <field>
              <name>BURN_IN_SEED</name>
              <description>the seed of prbs7 for brun-in test</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test2</name>
          <description>bist test control</description>
          <addressOffset>0xa8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BURN_IN_ERR_NUM_LAN1</name>
              <description>the bit num of mismatch data on data lan1 in burn-in mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BURN_IN_ERR_NUM_LAN0</name>
              <description>the bit num of mismatch data on data lan0 in burn-in mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test4</name>
          <description>bist test control</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>BURN_IN_ERR_NUM_CLAN</name>
              <description>the bit num of mismatch data on clock lane in burn-in mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test5</name>
          <description>burn-in test control</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BURN_IN_CHECK_NUM_LAN0</name>
              <description>the checked bit num of lane0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test6</name>
          <description>burn-in test control</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BURN_IN_CHECKED_NUM_LAN1</name>
              <description>the checked bit num of lane1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>burn_in_test9</name>
          <description>burn-in test control</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BURN_IN_CHECK_NUM_CLAN</name>
              <description>the checked bit num of clock lane</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_info</name>
          <description>debug data control</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x003F0000</resetMask>
          <fields>
            <field>
              <name>DEBUG_MODE_SEL</name>
              <description>the debug bus sel</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_cfg_reg0</name>
          <description>the hardcore interface control in debug mode</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CFG_REG0</name>
              <description>debug config register0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_cfg_reg1</name>
          <description>the hardcore interface control in debug mode</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CFG_REG1</name>
              <description>debug config register1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_cfg_reg2</name>
          <description>the hardcore interface control in debug mode</description>
          <addressOffset>0xd12</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CFG_REG2</name>
              <description>debug config register2</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_cfg_reg3</name>
          <description>the hardcore interface control in debug mode</description>
          <addressOffset>0xd16</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CFG_REG3</name>
              <description>debug config register3</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_cfg_reg4</name>
          <description>the hardcore interface control in debug mode</description>
          <addressOffset>0xd20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CFG_REG4</name>
              <description>debug config register4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>debug_cfg_reg5</name>
          <description>the hardcore interface control in debug mode</description>
          <addressOffset>0xd24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CFG_REG5</name>
              <description>debug config register5</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MIPI_CSI_PHY0">
      <name>MIPI_CSI_PHY1</name>
      <description>MIPI_CSI_PHY1</description>
      <groupName>MIPI_CSI_PHY</groupName>
      <baseAddress>0xf414c000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DDRPHY</name>
      <description>DDRPHY</description>
      <groupName>DDRPHY</groupName>
      <baseAddress>0xf4150000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RIDR</name>
          <description>Revision Identification Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UDRID</name>
              <description>User-Defined Revision ID: General purpose revision identification set by the user.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHYMJR</name>
              <description>PHY Major Revision: Indicates major revision of the PHY such addition of the features that make the new version not compatible with previous versions.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHYMDR</name>
              <description>PHY Moderate Revision: Indicates moderate revision of the PHY such as addition of new features. Normally the new version is still compatible with previous versions.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PHYMNR</name>
              <description>PHY Minor Revision: Indicates minor update of the PHY such as bug fixes. Normally no new features are included.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PUBMJR</name>
              <description>PUB Major Revision: Indicates major revision of the PUB such addition of the features that make the new version not compatible with previous versions.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PUBMDR</name>
              <description>PUB Moderate Revision: Indicates moderate revision of the PUB such as addition of new features. Normally the new version is still compatible with previous versions.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PUBMNR</name>
              <description>PUB Minor Revision: Indicates minor update of the PUB such as bug fixes. Normally no new features are included.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PIR</name>
          <description>PHY Initialization Register (PIR)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INITBYP</name>
              <description>Initialization Bypass: Bypasses or stops, if set, all initialization routines currently running, including PHY initialization, DRAM initialization, and PHY training.
Initialization may be triggered manually using INIT and the other relevant bits of the PIR register. This bit is self-clearing.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZCALBYP</name>
              <description>Impedance Calibration Bypass: Bypasses or stops, if set, impedance calibration of all ZQ control blocks that automatically triggers after reset. Impedance calibration may be triggered manually using INIT and ZCAL bits of the PIR register. This bit is self-clearing.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCALBYP</name>
              <description>Digital Delay Line (DDL) Calibration Bypass: Bypasses or stops, if set, DDL calibration that automatically triggers after reset. DDL calibration may be triggered manually using INIT and DCAL bits of the PIR register. This bit is self- clearing.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKBYP</name>
              <description>PLL Lock Bypass: Bypasses or stops, if set, the waiting of PLLs to lock. PLL lock wait is automatically triggered after reset. PLL lock wait may be triggered manually using INIT and PLLINIT bits of the PIR register. This bit is self-clearing.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLRSR</name>
              <description>Clear Status Registers: Writing 1 to this bit clears (reset to 0) select status bits in register PGSR0.
This bit is primarily for debug purposes and is typically not needed during normal functional operation. It can be used when PGSR.IDONE=1, to manually clear a selection of the PGSR status bits, although starting a new initialization process (PIR[0].INIT = 1b1) automatically clears the PGSR status bits associated with the initialization steps enabled.
The following list describes which bits within the PGSR0 register are cleared when CLRSR is set to 1b1 and which bits are not cleared:
The following bits are not cleared by PIR[27] (CLRSR):
PGSR0[31] (APLOCK)
PGSR0[29:28] (PLDONE_CHN)
PGSR0[23] (WLAERR)
PGSR0[21] (WLERR)
PGSR0[4] (DIDONE)
PGSR0[2] (DCDONE)
PGSR0[1] (PLDONE)
PGSR0[0] (IDONE)
The following bits are always zero:
PGSR0[30] (reserved)
PGSR0[19:12] (reserved)
The following bits are cleared unconditionally by PIR[27] (CLRSR):
PGSR0[27] (WEERR)
PGSR0[26] (REERR)
PGSR0[25] (WDERR)
PGSR0[24] (RDERR)
- PGSR0[22] (QSGERR)
- PGSR0[20] (ZCERR)
- PGSR0[11] (WEDONE)
- PGSR0[10] (REDONE)
- PGSR0[9] (WDDONE)
- PGSR0[8] (RDDONE)
- PGSR0[7] (WLADONE)
- PGSR0[6] (QSGDONE)
- PGSR0[5] (WLDONE)
- PGSR0[3] (ZCDONE)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDIMMINIT</name>
              <description>RDIMM Initialization: Executes the RDIMM buffer chip initialization before executing DRAM initialization. The RDIMM buffer chip initialization is run after the DRAM is reset and CKE have been driven high by the DRAM initialization sequence.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CTLDINIT</name>
              <description>Controller DRAM Initialization: Indicates, if set, that DRAM initialization will be performed by the controller. Otherwise if not set it indicates that DRAM initialization will be performed using the built-in initialization sequence or using software through the configuration port.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLBYP</name>
              <description>PLL Bypass: A setting of 1 on this bit will put all PHY PLLs in bypass mode.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ICPC</name>
              <description>Initialization Complete Pin Configuration: Specifies how the DFI initialization complete output pin (dfi_init_complete) should be used to indicate the status of initialization. Valid value are:
0 = Asserted after PHY initialization (DLL locking and impedance calibration) is complete.
1 = Asserted after PHY initialization is complete and the triggered the PUB initialization (DRAM initialization, data training, or initialization trigger with no selected initialization) is complete.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WREYE</name>
              <description>Write Data Eye Training: Executes a PUB training routine to maximize the write data eye.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDEYE</name>
              <description>Read Data Eye Training: Executes a PUB training routine to maximize the read data eye.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRDSKW</name>
              <description>Write Data Bit Deskew: Executes a PUB training routine to deskew the DQ bits during write.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDDSKW</name>
              <description>Read Data Bit Deskew: Executes a PUB training routine to deskew the DQ bits during read.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLADJ</name>
              <description>Write Leveling Adjust (DDR3 Only): Executes a PUB training routine that re- adjusts the write latency used during write in case the write leveling routine changed the expected latency.
Note: Ensure that the DCU command cache is cleared prior to running WLADJ.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QSGATE</name>
              <description>Read DQS Gate Training: Executes a PUB training routine to determine the optimum position of the read data DQS strobe for maximum system timing margins.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WL</name>
              <description>Write Leveling (DDR3 Only): Executes a PUB write leveling routine.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRAMINIT</name>
              <description>DRAM Initialization: Executes the DRAM initialization sequence.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DRAMRST</name>
              <description>DRAM Reset (DDR3 Only): Issues a reset to the DRAM (by driving the DRAM reset pin low) and wait 200us. This can be triggered in isolation or with the full DRAM initialization (DRAMINIT). For the later case, the reset is issued and 200us is waited before starting the full initialization sequence.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PHYRST</name>
              <description>PHY Reset: Resets the AC and DATX8 modules by asserting the AC/DATX8 reset pin.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCAL</name>
              <description>Digital Delay Line (DDL) Calibration: Performs PHY delay line calibration.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLINIT</name>
              <description>PLL Initialization: Executes the PLL initialization sequence which includes correct driving of PLL power-down, reset and gear shift pins, and then waiting for the PHY PLLs to lock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZCAL</name>
              <description>Impedance Calibration: Performs PHY impedance calibration. When set the impedance calibration will be performed in parallel with PHY initialization (PLL initialization + DDL calibration + PHY reset).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Initialization Trigger: A write of '1' to this bit triggers the DDR system initialization, including PHY initialization, DRAM initialization, and PHY training. The exact initialization steps to be executed are specified in bits 1 to 15 of this register. A bit setting of 1 means the step will be executed as part of the initialization sequence, while a setting of 0 means the step will be bypassed. The initialization trigger bit is self-clearing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PGCR0</name>
          <description>PHY General Configuration Registers 0-1 (PGCR0- 1)</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CKEN</name>
              <description>CK Enable: Controls whether the CK going to the SDRAM is enabled (toggling) or disabled (static value) and whether the CK is inverted. Two bits for each of the up to three CK pairs. Valid values for the two bits are:
00 = CK disabled (Driven to constant 0) 01 = CK toggling with inverted polarity
10 = CK toggling with normal polarity (This should be the default setting) 11 = CK disabled (Driven to constant 1)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUBMODE</name>
              <description>Enables, if set, the PUB to control the interface to the PHY and SDRAM. In this mode the DFI commands from the controller are ignored. The bit must be set to 0 after the system determines it is convenient to pass control of the DFI bus to the controller. When set to 0 the DFI interface has control of the PHY and SDRAM interface except when triggering pub operations such as BIST, DCU or data training.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTOSEL</name>
              <description>Digital Test Output Select: Selects the PHY digital test output that is driven onto PHY digital test output (phy_dto) pin: Valid values are:
00000 = DATX8 0 PLL digital test output 00001 = DATX8 1 PLL digital test output 00010 = DATX8 2 PLL digital test output 00011 = DATX8 3 PLL digital test output 00100 = DATX8 4 PLL digital test output 00101 = DATX8 5 PLL digital test output 00110 = DATX8 6 PLL digital test output 00111 = DATX8 7 PLL digital test output 01000 = DATX8 8 PLL digital test output 01001 = AC PLL digital test output 01010  01111 = Reserved
10000 = DATX8 0 delay line digital test output 10001 = DATX8 1 delay line digital test output 10010 = DATX8 2 delay line digital test output 10011 = DATX8 3 delay line digital test output 10100 = DATX8 4 delay line digital test output 10101 = DATX8 5 delay line digital test output 10110 = DATX8 6 delay line digital test output 10111 = DATX8 7 delay line digital test output 11000 = DATX8 8 delay line digital test output 11001 = AC delay line digital test output 11010  11111 = Reserved</description>
              <bitOffset>14</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCWDL</name>
              <description>Oscillator Mode Write-Leveling Delay Line Select: Selects which of the two write leveling LCDLs is active. The delay select value of the inactive LCDL is set to zero while the delay select value of the active LCDL can be varied by the input write leveling delay select pin. Valid values are:
00 = No WL LCDL is active 01 = DDR WL LCDL is active 10 = SDR WL LCDL is active 11 = Both LCDLs are active</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCDIV</name>
              <description>Oscillator Mode Division: Specifies the factor by which the delay line oscillator mode output is divided down before it is output on the delay line digital test output pin dl_dto. Valid values are:
000 = Divide by 1
001 = Divide by 256
010 = Divide by 512
011 = Divide by 1024
100 = Divide by 2048
101 = Divide by 4096
110 = Divide by 8192
111 = Divide by 65536</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OSCEN</name>
              <description>Oscillator Enable: Enables, if set, the delay line oscillation.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLTST</name>
              <description>Delay Line Test Start: A write of '1' to this bit will trigger delay line oscillator mode period measurement. This bit is not self clearing and needs to be reset to '0' before the measurement can be re-triggered.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLTMODE</name>
              <description>Delay Line Test Mode: Selects, if set, the delay line oscillator test mode. Setting this bit also clears all delay line register values. For DL oscillator testing, first set this bit, then apply desired non-zero LCDL and BDL register programmings.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDBVT</name>
              <description>Read Data BDL VT Compensation: Enables, if set, the VT drift compensation of the read data bit delay lines.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDBVT</name>
              <description>Write Data BDL VT Compensation: Enables, if set, the VT drift compensation of the write data bit delay lines.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RGLVT</name>
              <description>Read DQS Gating LCDL Delay VT Compensation: Enables, if set, the VT drift compensation of the read DQS gating LCDL.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDLVT</name>
              <description>Read DQS LCDL Delay VT Compensation: Enables, if set, the VT drift compensation of the read DQS LCDL.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDLVT</name>
              <description>Write DQ LCDL Delay VT Compensation: Enables, if set, the VT drift compensation of the write DQ LCDL.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLLVT</name>
              <description>Write Leveling LCDL Delay VT Compensation: Enables, if set, the VT drift compensation of the write leveling LCDL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PGCR1</name>
          <description>PHY General Configuration Registers 0-1 (PGCR0- 1)</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LBMODE</name>
              <description>Loopback Mode: Indicates, if set, that the PHY/PUB is in loopback mode.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LBGDQS</name>
              <description>Loopback DQS Gating: Selects the DQS gating mode that should be used when the PHY is in loopback mode, including BIST loopback mode. Valid values are:
00 = DQS gate is always on
01 = DQS gate training will be triggered on the PUB 10 = DQS gate is set manually using software
11 = Reserved</description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LBDQSS</name>
              <description>Loopback DQS Shift: Selects how the read DQS is shifted during loopback to ensure that the read DQS is centered into the read data eye. Valid values are:
1b0 = PUB sets the read DQS LCDL to 0 (internally). DQS is already shifted 90 degrees by write path
1b1 = The read DQS shift is set manually through software</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IOLB</name>
              <description>I/O Loop-Back Select: Selects where inside the I/O the loop-back of signals happens. Valid values are:
0 = Loopback is after output buffer; output enable must be asserted 1 = Loopback is before output buffer; output enable is dont care</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INHVT</name>
              <description>VT Calculation Inhibit: Inhibits calculation of the next VT compensated delay line values. A value of 1 will inhibit the VT calculation. This bit should be set to 1 during writes to the delay line registers.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DXHRST</name>
              <description>DX PHY High-Speed Reset: a Write of '0' to this bit resets the DX macro without resetting the PUB RTL logic. This bit is not self-clearing and a '1' must be written to de-assert the reset.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZCKSEL</name>
              <description>Impedance Clock Divider Select: Selects the divide ratio for the clock used by the impedance control logic relative to the clock used by the memory controller and SDRAM.
Valid values are:
00 = Divide by 2
01 = Divide by 8
10 = Divide by 32
11 = Divide by 64
For more information, refer to Impedance Calibration on page 174.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLDLMT</name>
              <description>Delay Line VT Drift Limit: Specifies the minimum change in the delay line VT drift in one direction which should result in the assertion of the delay line VT drift status signal (vt_drift). The limit is specified in terms of delay select values. A value of 0 disables the assertion of delay line VT drift status signal.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FDEPTH</name>
              <description>Filter Depth: Specifies the number of measurements over which all AC and DATX8 initial period measurements, that happen after reset or when calibration is manually triggered, are averaged. Valid values are:
00 = 2
01 = 4
10 = 8
11 = 16</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPFDEPTH</name>
              <description>Low-Pass Filter Depth: Specifies the number of measurements over which MDL period measurements are filtered. This determines the time constant of the low pass filter. Valid values are:
00 = 2
01 = 4
10 = 8
11 = 16</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPFEN</name>
              <description>Low-Pass Filter Enable: Enables, if set, the low pass filtering of MDL period measurements.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MDLEN</name>
              <description>Master Delay Line Enable: Enables, if set, the AC master delay line calibration to perform subsequent period measurements following the initial period measurements that are performed after reset or on when calibration is manually triggered. These additional measurements are accumulated and filtered as long as this bit remains high.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IODDRM</name>
              <description>I/O DDR Mode (D3F I/O Only): Selects the DDR mode for the I/Os. These bits connect to bits [2:1] of the IOM pin of the SSTL I/O. For more information, refer to the SSTL I/O chapter in the DWC DDR PHY Databook.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLSELT</name>
              <description>Write Leveling Select Type: Selects the encoding type for the write leveling select signal depending on the desired setup/hold margins for the internal pipelines. Refer to the DDR PHY Databook for details of how the select type is used. Valid values are:
0 = Type 1: Setup margin of 90 degrees and hold margin of 90 degrees 1 = Type 2: Setup margin of 135 degrees and hold margin of 45 degrees</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACHRST</name>
              <description>AC PHY High-Speed Reset: a Write of '0' to this bit resets the AC macro without resetting the PUB RTL logic. This bit is not self-clearing and a '1' must be written to de-assert the reset.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WSLOPT</name>
              <description>Write System Latency Optimization: controls the insertion of a pipeline stage on the AC signals from the DFI interface to the PHY to cater for a negative write system latency (WSL) value (only -1 possible).
0x0 = A pipeline stage is inserted only if WL2 training results in a WSL of -1 for any rank
0x1 = Inserts a pipeline stage</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLSTEP</name>
              <description>Write Leveling Step: Specifies the number of delay step-size increments during each step of write leveling. Valid values are:
0 = computed to be 1/2 of the associated lane's DXnGSR0.WLPRD value 1 = 1 step size</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WLMODE</name>
              <description>Write Leveling (Software) Mode: Indicates, if set, that the PUB is in software write leveling mode in which software executes single steps of DQS pulsing by writing '1' to PIR.WL. The write leveling DQ status from the DRAM is captured in DXnGSR0.WLDQ.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDDISDX</name>
              <description>Power Down Disabled Byte: Indicates, if set, that the PLL and I/Os of a disabled byte should be powered down.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PGSR0</name>
          <description>PHY General Status Registers 0-1 (PGSR0-1) on page 89</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>APLOCK</name>
              <description>AC PLL Lock: Indicates, if set, that AC PLL has locked. This is a direct status of the AC PLL lock pin.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLDONE_CHN</name>
              <description>PLL Lock Done per Channel: Indicates PLL locking has completed for each underlying channel. Bit 28 represents channel 0 while bit 29 represents channel 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WEERR</name>
              <description>Write Eye Training Error: Indicates, if set, that there is an error in write eye training.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REERR</name>
              <description>Read Data Eye Training Error: Indicates, if set, that there is an error in read eye training.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDERR</name>
              <description>Write Data Bit Deskew Error: Indicates, if set, that there is an error in write bit deskew.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDERR</name>
              <description>Read Data Bit Deskew Error: Indicates, if set, that there is an error in read bit deskew.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WLAERR</name>
              <description>Write Data Leveling Adjustment Error: Indicates, if set, that there is an error in write leveling adjustment.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QSGERR</name>
              <description>Read DQS Gate Training Error: Indicates, if set, that there is an error in DQS gate training.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WLERR</name>
              <description>Write Leveling Error: Indicates, if set, that there is an error in write leveling.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ZCERR</name>
              <description>Impedance Calibration Error: Indicates, if set, that there is an error in impedance calibration.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WEDONE</name>
              <description>Write Data Eye Training Done: Indicates, if set, that write eye training has completed.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>REDONE</name>
              <description>Read Data Eye Training Done: Indicates, if set, that read eye training has completed.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDDONE</name>
              <description>Write Data Bit Deskew Done: Indicates, if set, that write bit deskew has completed.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDDONE</name>
              <description>Read Data Bit Deskew Done: Indicates, if set, that read bit deskew has completed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WLADONE</name>
              <description>Write Leveling Adjustment Done: Indicates, if set, that write leveling adjustment has completed.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QSGDONE</name>
              <description>Read DQS Gate Training Done: Indicates, if set, that DQS gate training has completed.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WLDONE</name>
              <description>Write Leveling Done: Indicates, if set, that write leveling has completed.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DIDONE</name>
              <description>DRAM Initialization Done: Indicates, if set, that DRAM initialization has completed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ZCDONE</name>
              <description>Impedance Calibration Done: Indicates, if set, that impedance calibration has completed.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DCDONE</name>
              <description>Digital Delay Line (DDL) Calibration Done: Indicates, if set, that DDL calibration has completed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PLDONE</name>
              <description>PLL Lock Done: Indicates, if set, that PLL locking has completed.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IDONE</name>
              <description>Initialization Done: Indicates, if set, that the DDR system initialization has completed. This bit is set after all the selected initialization routines in PIR register have completed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PGSR1</name>
          <description>PHY General Status Registers 0-1 (PGSR0-1) on page 89</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PARERR</name>
              <description>RDIMM Parity Error: Indicates, if set, that there was a parity error (i.e. err_out_n was sampled low) during one of the transactions to the RDIMM buffer chip. This bit remains asserted until cleared by the PIR.CLRSR.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>VTSTOP</name>
              <description>VT Stop: Indicates, if set, that the VT calculation logic has stopped computing the next values for the VT compensated delay line values. After assertion of the PGCR.INHVT, the VTSTOP bit should be read to ensure all VT compensation logic has stopped computations before writing to the delay line registers.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DLTCODE</name>
              <description>Delay Line Test Code: Returns the code measured by the PHY control block that corresponds to the period of the AC delay line digital test output.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DLTDONE</name>
              <description>Delay Line Test Done: Indicates, if set, that the PHY control block has finished doing period measurement of the AC delay line digital test output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PLLCR</name>
          <description>PLL Control Register (PLLCR) on page 91</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BYP</name>
              <description>PLL Bypass: Bypasses the PLL, if set, to 1.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLRST</name>
              <description>PLL Rest: Resets the PLLs by driving the PLL reset pin. This bit is not self-clearing and a 0 must be written to de-assert the reset.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLLPD</name>
              <description>PLL Power Down: Puts the PLLs in power down mode by driving the PLL power down pin. This bit is not self-clearing and a 0 must be written to de-assert the power-down.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FRQSEL</name>
              <description>PLL Frequency Select: Selects the operating range of the PLL. Valid values for PHYs that go up to 2133 Mbps are:
00 = PLL reference clock (ctl_clk/REF_CLK) ranges from 335MHz to 533MHz 01 = PLL reference clock (ctl_clk/REF_CLK) ranges from 225MHz to 385MHz 10 = Reserved
11 = PLL reference clock (ctl_clk/REF_CLK) ranges from 166MHz to 275MHz
Valid values for PHYs that dont go up to 2133 Mbps are:
00 = PLL reference clock (ctl_clk/REF_CLK) ranges from 250MHz to 400MHz 01 = PLL reference clock (ctl_clk/REF_CLK) ranges from 166MHz to 300MHz 10 = Reserved
11 = Reserved</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>QPMODE</name>
              <description>PLL Quadrature Phase Mode: Enables, if set, the quadrature phase clock outputs. This mode is not used in this version of the PHY.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPPC</name>
              <description>Charge Pump Proportional Current Control</description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CPIC</name>
              <description>Charge Pump Integrating Current Control</description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GSHIFT</name>
              <description>Gear Shift: Enables, if set, rapid locking mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATOEN</name>
              <description>Analog Test Enable (ATOEN): Selects the analog test signal that is driven on the analog test output pin. Otherwise the analog test output is tri-stated. This allows analog test output pins from multiple PLLs to be connected together. Valid values are:
0000 = All PLL analog test signals are tri-stated 0001 = AC PLL analog test signal is driven out
0010 = DATX8 0 PLL analog test signal is driven out 0011 = DATX8 1 PLL analog test signal is driven out 0100 = DATX8 2 PLL analog test signal is driven out 0101 = DATX8 3 PLL analog test signal is driven out 0110 = DATX8 4 PLL analog test signal is driven out 0111 = DATX8 5 PLL analog test signal is driven out 1000 = DATX8 6 PLL analog test signal is driven out 1001 = DATX8 7 PLL analog test signal is driven out 1010 = DATX8 8 PLL analog test signal is driven out 1011  1111 = Reserved</description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATC</name>
              <description>Analog Test Control: Selects various PLL analog test signals to be brought out via PLL analog test output pin (pll_ato). Valid values are:
0000 = Reserved
0001 = vdd_ckin
0010 = vrfbf
0011 = vdd_cko
0100 = vp_cp
0101 = vpfil(vp)
0110 = Reserved
0111 = gd
1000 = vcntrl_atb
1001 = vref_atb
1010 = vpsf_atb
1011  1111 = Reserved</description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTC</name>
              <description>Digital Test Control: Selects various PLL digital test signals and other test mode signals to be brought out via bit [1] of the PLL digital test output (pll_dto[1]). Valid values are:
00 = 0 (Test output is disabled) 01 = PLL x1 clock (X1)
10 = PLL reference (input) clock (REF_CLK) 11 = PLL feedback clock (FB_X1)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTR0</name>
          <description>PHY Timing Registers 0-4 (PTR0-4)</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPLLPD</name>
              <description>PLL Power-Down Time: Number of configuration or APB clock cycles that the PLL must remain in power-down mode, i.e. number of clock cycles from when PLL power-down pin is asserted to when PLL power-down pin is de-asserted. This must correspond to a value that is equal to or more than 1us. Default value corresponds to 1us.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPLLGS</name>
              <description>PLL Gear Shift Time: Number of configuration or APB clock cycles from when the PLL reset pin is de-asserted to when the PLL gear shift pin is de-asserted. This must correspond to a value that is equal to or more than 4us. Default value corresponds to 4us.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPHYRST</name>
              <description>PHY Reset Time: Number of configuration or APB clock cycles that the PHY reset must remain asserted after PHY calibration is done before the reset to the PHY is de-asserted. This is used to extend the reset to the PHY so that the reset is asserted for some clock cycles after the clocks are stable. Valid values are from 1 to 63 (the value must be non-zero).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTR1</name>
          <description>PHY Timing Registers 0-4 (PTR0-4)</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TPLLLOCK</name>
              <description>PLL Lock Time: Number of configuration or APB clock cycles for the PLL to stabilize and lock, i.e. number of clock cycles from when the PLL reset pin is de-asserted to when the PLL has lock and is ready for use. This must correspond to a value that is equal to or more than 100us. Default value corresponds to 100us.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPLLRST</name>
              <description>PLL Reset Time: Number of configuration or APB clock cycles that the PLL must remain in reset mode, i.e. number of clock cycles from when PLL power-down pin is de-asserted and PLL reset pin is asserted to when PLL reset pin is de-asserted.
The setting must correspond to a value that is equal to, or greater than, 3us.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTR2</name>
          <description>PHY Timing Registers 0-4 (PTR0-4)</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TWLDLYS</name>
              <description>Write Leveling Delay Settling Time: Number of controller clock cycles from when a new value of the write leveling delay is applies to the LCDL to when to DQS high is driven high. This allows the delay to settle.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCALH</name>
              <description>Calibration Hold Time: Number of controller clock cycles from when the clock was disabled (cal_clk_en deasserted) to when calibration is enable (cal_en asserted).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCALS</name>
              <description>Calibration Setup Time: Number of controller clock cycles from when calibration is enabled (cal_en asserted) to when the calibration clock is asserted again (cal_clk_en asserted).</description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCALON</name>
              <description>Calibration On Time: Number of clock cycles that the calibration clock is enabled (cal_clk_en asserted).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTR3</name>
          <description>PHY Timing Registers 0-4 (PTR0-4)</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDINIT1</name>
              <description>DRAM Initialization Time 1: DRAM initialization time in DRAM clock cycles corresponding to the following:
DDR3 = CKE high time to first command (tRFC + 10 ns or 5 tCK, whichever is bigger) DDR2 = CKE high time to first command (400 ns)
Default value corresponds to DDR3 tRFC of 360ns at 1066 MHz.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDINIT0</name>
              <description>DRAM Initialization Time 0: DRAM initialization time in DRAM clock cycles corresponding to the following:
DDR3 = CKE low time with power and clock stable (500 us) DDR2 = CKE low time with power and clock stable (200 us) Default value corresponds to DDR3 500 us at 1066 MHz.
During Verilog simulations, it is recommended that this value is changed to a much smaller value in order to avoid long simulation times. However, this may cause a memory model error, due to a violation of the CKE setup sequence. This violation is expected if this value is not programmed to the required SDRAM CKE low time, but memory models should be able to tolerate this violation without malfunction of the model.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PTR4</name>
          <description>PHY Timing Registers 0-4 (PTR0-4)</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDINIT3</name>
              <description>DRAM Initialization Time 3: DRAM initialization time in DRAM clock cycles corresponding to the following:
DDR3 = Time from ZQ initialization command to first command (1 us) Default value corresponds to the DDR3 640ns at 1066 MHz.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDINIT2</name>
              <description>DRAM Initialization Time 2: DRAM initialization time in DRAM clock cycles corresponding to the following:
DDR3 = Reset low time (200 us on power-up or 100 ns after power-up) Default value corresponds to DDR3 200 us at 1066 MHz.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACMDLR</name>
          <description>AC Master Delay Line Register (ACMDLR) on page 96</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MDLD</name>
              <description>MDL Delay: Delay select for the LCDL for the Master Delay Line.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TPRD</name>
              <description>Target Period: Target period measured by the master delay line calibration for VT drift compensation. This is the current measured value of the period and is continuously updated if the MDL is enabled to do so.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IPRD</name>
              <description>Initial Period: Initial period measured by the master delay line calibration for VT drift compensation. This value is used as the denominator when calculating the ratios of updates during VT compensation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACBDLR</name>
          <description>AC Bit Delay Line Register (ACBDLR) on page 96</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACBD</name>
              <description>Address/Command Bit Delay: Delay select for the BDLs on address and command signals.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CK2BD</name>
              <description>CK2 Bit Delay: Delay select for the BDL on CK2.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CK1BD</name>
              <description>CK1 Bit Delay: Delay select for the BDL on CK1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CK0BD</name>
              <description>CK0 Bit Delay: Delay select for the BDL on CK0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACIOCR</name>
          <description>AC I/O Configuration Register (ACIOCR) on page 97</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ACSR</name>
              <description>Address/Command Slew Rate (D3F I/O Only): Selects slew rate of the I/O for all address and command pins.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTIOM</name>
              <description>SDRAM Reset I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for SDRAM Reset.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTPDR</name>
              <description>SDRAM Reset Power Down Receiver: Powers down, when set, the input receiver on the I/O for SDRAM RST# pin.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTPDD1</name>
              <description>SDRAM Reset Power Down Driver: Powers down, when set, the output driver on the I/O for SDRAM RST# pin.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTODT</name>
              <description>SDRAM Reset On-Die Termination: Enables, when set, the on-die termination on the I/O for SDRAM RST# pin.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANKPDR</name>
              <description>Rank Power Down Receiver: Powers down, when set, the input receiver on the I/O CKE[3:0], ODT[3:0], and CS#[3:0] pins. RANKPDR[0] controls the power down for CKE[0], ODT[0], and CS#[0], RANKPDR[1] controls the power down for CKE[1], ODT[1], and CS#[1], and so on.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSPDD1</name>
              <description>CS# Power Down Driver: Powers down, when set, the output driver on the I/O for CS#[3:0] pins. CSPDD[0] controls the power down for CS#[0], CSPDD[1] controls the power down for CS#[1], and so on. CKE and ODT driver power down is controlled by DSGCR register.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANKODT</name>
              <description>Rank On-Die Termination: Enables, when set, the on-die termination on the I/O for CKE[3:0], ODT[3:0], and CS#[3:0] pins. RANKODT[0] controls the on-die termination for CKE[0], ODT[0], and CS#[0], RANKODT[1] controls the on-die termination for CKE[1], ODT[1], and CS#[1], and so on.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKPDR</name>
              <description>CK Power Down Receiver: Powers down, when set, the input receiver on the I/O for CK[0], CK[1], and CK[2] pins, respectively.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKPDD1</name>
              <description>CK Power Down Driver: Powers down, when set, the output driver on the I/O for CK[0], CK[1], and CK[2] pins, respectively.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKODT</name>
              <description>CK On-Die Termination: Enables, when set, the on-die termination on the I/O for CK[0], CK[1], and CK[2] pins, respectively.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACPDR</name>
              <description>AC Power Down Receiver: Powers down, when set, the input receiver on the I/O for RAS#, CAS#, WE#, BA[2:0], and A[15:0] pins.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACPDD1</name>
              <description>AC Power Down Driver: Powers down, when set, the output driver on the I/O for RAS#, CAS#, WE#, BA[2:0], and A[15:0] pins.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACODT</name>
              <description>Address/Command On-Die Termination: Enables, when set, the on-die termination on the I/O for RAS#, CAS#, WE#, BA[2:0], and A[15:0] pins.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACOE</name>
              <description>Address/Command Output Enable: Enables, when set, the output driver on the I/O for all address and command pins.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACIOM</name>
              <description>Address/Command I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for all address and command pins. This bit connects to bit
[0] of the IOM pin on the D3F I/Os, and for other I/O libraries, it connects to the IOM pin of the I/O.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DXCCR</name>
          <description>DATX8 Common Configuration Register (DXCCR) on page 99</description>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DDPDRCDO</name>
              <description>Dynamic Data Power Down Receiver Count Down Offset: Offset applied in calculating window of time where receiver is powered up</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DDPDDCDO</name>
              <description>Dynamic Data Power Down Driver Count Down Offset: Offset applied in calculating window of time where driver is powered up</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DYNDXPDR</name>
              <description>Data Power Down Receiver: Dynamically powers down, when set, the input receiver on I/O for the DQ pins of the active DATX8 macros. Applies only when DXPDR and DXnGCR.DXPDR are not set to 1. Receiver is powered-up on a DFI READ command and powered-down (trddata_en + fixed_read_latency + n) HDR cycles after the last DFI READ command. Note that n is defined by the register bit field DXCCR[31:28] (DDPDRCDO).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DYNDXPDD1</name>
              <description>Dynamic Data Power Down Driver: Dynamically powers down, when set, the output driver on I/O for the DQ pins of the active DATX8 macros. Applies only when DXPDD and DXnGCR.DXPDD are not set to 1. Driver is powered-up on a DFI WRITE command and powered-down (twrlat + WL/2 + n) HDR cycles after the last DFI WRITE command. Note that n is defined by the register bit field DXCCR[27:24] (DDPDDCDO).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UDQIOM</name>
              <description>Unused DQ I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for unused DQ pins.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UDQPDR</name>
              <description>Unused DQ Power Down Receiver: Powers down, when set, the input receiver on the I/O for unused DQ pins.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UDQPDD1</name>
              <description>Unused DQ Power Down Driver: Powers down, when set, the output driver on the I/O for unused DQ pins.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UDQODT</name>
              <description>Unused DQ On-Die Termination: Enables, when set, the on-die termination on the I/O for unused DQ pins.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MSBUDQ</name>
              <description>Most Significant Byte Unused DQs: Specifies the number of DQ bits that are not used in the most significant byte. The used (valid) bits for this byte are [8-MSBDQ- 1:0]. To disable the whole byte, use the DXnGCR.DXEN register.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DXSR</name>
              <description>Data Slew Rate (D3F I/O Only): Selects slew rate of the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DQSNRES</name>
              <description>DQS# Resistor: Selects the on-die pull-up/pull-down resistor for DQS# pins. Same encoding as DQSRES.
Refer PHY databook for pull-down/pull-up resistor values (RA_SEL/RB_SEL) for DQS/DQS_b.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DQSRES</name>
              <description>DQS Resistor: Selects the on-die pull-down/pull-up resistor for DQS pins. DQSRES[3] selects pull-down (when set to 0) or pull-up (when set to 1). DQSRES[2:0] selects the resistor value.
Refer PHY databook for pull-down/pull-up resistor values (RA_SEL/RB_SEL) for DQS/DQS_b.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DXPDR</name>
              <description>Data Power Down Receiver: Powers down, when set, the input receiver on I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the PDR configuration bit of the individual DATX8.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DXPDD1</name>
              <description>Data Power Down Driver: Powers down, when set, the output driver on I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the PDD configuration bit of the individual DATX8.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MDLEN</name>
              <description>Master Delay Line Enable: Enables, if set, all DATX8 master delay line calibration to perform subsequent period measurements following the initial period measurements that are performed after reset or on when calibration is manually triggered. These additional measurements are accumulated and filtered as long as this bit remains high. This bit is ANDed with the MDLEN bit in the individual DATX8.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DXIOM</name>
              <description>Data I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the IOM configuration bit of the individual DATX8.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DXODT</name>
              <description>Data On-Die Termination: Enables, when set, the on-die termination on the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the ODT configuration bit of the individual DATX8 (DATX8 General Configuration Register (DXnGCR) on page 148)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DSGCR</name>
          <description>DDR System General Configuration Register (DSGCR) on page 101</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CKEOE</name>
              <description>SDRAM CKE Output Enable: Enables, when set, the output driver on the I/O for SDRAM CKE pins.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTOE</name>
              <description>SDRAM Reset Output Enable: Enables, when set, the output driver on the I/O for SDRAM RST# pin.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ODTOE</name>
              <description>SDRAM ODT Output Enable: Enables, when set, the output driver on the I/O for SDRAM ODT pins.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKOE</name>
              <description>SDRAM CK Output Enable: Enables, when set, the output driver on the I/O for SDRAM CK/CK# pins.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ODTPDD1</name>
              <description>ODT Power Down Driver: Powers down, when set, the output driver on the I/O for ODT[3:0] pins. ODTPDD[0] controls the power down for ODT[0], ODTPDD[1] controls the power down for ODT[1], and so on.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEPDD1</name>
              <description>CKE Power Down Driver: Powers down, when set, the output driver on the I/O for CKE[3:0] pins. CKEPDD[0] controls the power down for CKE[0], CKEPDD[1] controls the power down for CKE[1], and so on.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SDRMODE</name>
              <description>Single Data Rate Mode: Indicates, if set, that the external controller is configured to run in single data rate (SDR) mode. Otherwise if not set the controller is running in half data rate (HDR) mode. This bit not supported in the current version of the PUB.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RRMODE</name>
              <description>Rise-to-Rise Mode: Indicates, if set, that the PHY mission mode is configured to run in rise-to-rise mode. Otherwise if not set the PHY mission mode is running in rise-to- fall mode.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATOAE</name>
              <description>ATO Analog Test Enable: Enables, if set, the analog test output (ATO) I/O.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTOOE</name>
              <description>DTO Output Enable: Enables, when set, the output driver on the I/O for DTO pins.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTOIOM</name>
              <description>DTO I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DTO pins.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTOPDR</name>
              <description>DTO Power Down Receiver: Powers down, when set, the input receiver on the I/O for DTO pins.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTOPDD1</name>
              <description>DTO Power Down Driver: Powers down, when set, the output driver on the I/O for DTO pins.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTOODT</name>
              <description>DTO On-Die Termination: Enables, when set, the on-die termination on the I/O for DTO pins.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUAD</name>
              <description>PHY Update Acknowledge Delay: Specifies the number of clock cycles that the indication for the completion of PHY update from the PHY to the controller should be delayed. This essentially delays, by this many clock cycles, the de-assertion of dfi_ctrlup_ack and dfi_phyupd_req signals relative to the time when the delay lines or I/Os are updated.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRRMODE</name>
              <description>Bypass Rise-to-Rise Mode: Indicates, if set, that the PHY bypass mode is configured to run in rise-to-rise mode. Otherwise if not set the PHY bypass mode is running in rise-to-fall mode.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DQSGX</name>
              <description>DQS Gate Extension: Specifies, if set, that the DQS gating must be extended by two DRAM clock cycles and then re-centered, i.e. one clock cycle extension on either side.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CUAEN</name>
              <description>Controller Update Acknowledge Enable: Specifies, if set, that the PHY should issue controller update acknowledge when the DFI controller update request is asserted. By default the PHY does not acknowledge controller initiated update requests but simply does an update whenever there is a controller update request. This speeds up the update.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPPLLPD</name>
              <description>Low Power PLL Power Down: Specifies, if set, that the PHY should respond to the DFI low power opportunity request and power down the PLL of the byte if the wakeup time request satisfies the PLL lock time.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPIOPD</name>
              <description>Low Power I/O Power Down: Specifies, if set, that the PHY should respond to the DFI low power opportunity request and power down the I/Os of the byte.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ZUEN</name>
              <description>Impedance Update Enable: Specifies, if set, that in addition to DDL VT update, the PHY could also perform impedance calibration (update).
Refer to the Impedance Control Register 0-1 (ZQnCR0-1) on page 145 bit fields DFICU0, DFICU1 and DFICCU bits to control if an impedance calibration is performed (update) with a DFI controller update request.
Refer to the Impedance Control Register 0-1 (ZQnCR0-1) on page 145 bit fields DFIPU0 and DFIPU1 bits to control if an impedance calibration is performed (update) with a DFI PHY update request.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BDISEN</name>
              <description>Byte Disable Enable: Specifies, if set, that the PHY should respond to DFI byte disable request. Otherwise the byte disable from the DFI is ignored in which case bytes can only be disabled using the DXnGCR register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUREN</name>
              <description>PHY Update Request Enable: Specifies if set, that the PHY should issue PHY- initiated update request when there is DDL VT drift.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <description>DRAM Configuration Register (DCR) on page 103</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UDIMM</name>
              <description>Un-buffered DIMM Address Mirroring: Indicates, if set, that there is address mirroring on the second rank of an un-buffered DIMM (the rank connected to CS#[1]). In this case, the PUB re-scrambles the bank and address when sending mode register commands to the second rank. This only applies to PUB internal SDRAM transactions. Transactions generated by the controller must make its own adjustments when using an un-buffered DIMM. DCR[NOSRA] must be set if address mirroring is enabled.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR2T</name>
              <description>DDR 2T Timing: Indicates, if set, that 2T timing should be used by PUB internally generated SDRAM transactions.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NOSRA</name>
              <description>No Simultaneous Rank Access: Specifies, if set, that simultaneous rank access on the same clock cycle is not allowed. This means that multiple chip select signals should not be asserted at the same time. This may be required on some DIMM systems.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEMASK</name>
              <description>Byte Mask: Mask applied to all beats of read data on all bytes lanes during read DQS gate training. This allows training to be conducted based on selected bit(s) from the byte lanes.
Valid values for each bit are:
0 = Disable compare for that bit 1 = Enable compare for that bit
Note that this mask applies in DDR3 MPR operation mode as well and must be in keeping with the PDQ field setting.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPRDQ</name>
              <description>Multi-Purpose Register (MPR) DQ (DDR3 Only): Specifies the value that is driven on non-primary DQ pins during MPR reads. Valid values are:
0 = Primary DQ drives out the data from MPR (0-1-0-1); non-primary DQs drive 0 1 = Primary DQ and non-primary DQs all drive the same data from MPR (0-1-0-1)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDQ</name>
              <description>Primary DQ (DDR3 Only): Specifies the DQ pin in a byte that is designated as a primary pin for Multi-Purpose Register (MPR) reads. Valid values are 0 to 7 for DQ[0] to DQ[7], respectively.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DDR8BNK</name>
              <description>DDR 8-Bank: Indicates, if set, that the SDRAM used has 8 banks. tRPA = tRP+1 and tFAW are used for 8-bank DRAMs, otherwise tRPA = tRP and no tFAW is used.
Note that a setting of 1 for DRAMs that have fewer than 8 banks results in correct functionality, but less tight DRAM command spacing for the parameters.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DDRMD</name>
              <description>DDR Mode: SDRAM DDR mode. Valid values are: 000 = Reserved
001 = Reserved
010 = DDR2
011 = DDR3
100  111 = Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTPR0</name>
          <description>DRAM Timing Parameters Register 0-2 (DTPR0-2)</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRC</name>
              <description>Activate to activate command delay (same bank). Valid values are 2 to 63.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRRD</name>
              <description>Activate to activate command delay (different banks). Valid values are 1 to 15.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRAS</name>
              <description>Activate to precharge command delay. Valid values are 2 to 63.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRCD</name>
              <description>Activate to read or write delay. Minimum time from when an activate command is issued to when a read or write to the activated row can be issued. Valid values are 2 to 15.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRP</name>
              <description>Precharge command period: The minimum time between a precharge command and any other command. Note that the Controller automatically derives tRPA for 8- bank DDR2 devices by adding 1 to tRP. Valid values are 2 to 15.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWTR</name>
              <description>Internal write to read command delay. Valid values are 1 to 15.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRTP</name>
              <description>Internal read to precharge command delay. Valid values are 2 to 15.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTPR1</name>
          <description>DRAM Timing Parameters Register 0-2 (DTPR0-2)</description>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TAOND_TAOFD</name>
              <description>ODT turn-on/turn-off delays (DDR2 only). Valid values are: 00 = 2/2.5
01 = 3/3.5
10 = 4/4.5
11 = 5/5.5
Most DDR2 devices utilize a fixed value of 2/2.5. For non-standard SDRAMs, the user must ensure that the operational Write Latency is always greater than or equal to the ODT turn-on delay. For example, a DDR2 SDRAM with CAS latency set to 3 and CAS additive latency set to 0 has a Write Latency of 2. Thus 2/2.5 can be used, but not 3/3.5 or higher.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWLO</name>
              <description>Write leveling output delay: Number of clock cycles from when write leveling DQS is driven high by the control block to when the results from the SDRAM on DQ is sampled by the control block. This must include the SDRAM tWLO timing parameter plus the round trip delay from control block to SDRAM back to control block.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TWLMRD</name>
              <description>Minimum delay from when write leveling mode is programmed to the first DQS/DQS# rising edge.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRFC</name>
              <description>Refresh-to-Refresh: Indicates the minimum time between two refresh commands or between a refresh and an active command. This is derived from the minimum refresh interval from the datasheet, tRFC(min), divided by the clock cycle time. The default number of clock cycles is for the largest JEDEC tRFC(min parameter value supported.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TFAW</name>
              <description>4-bank activate period. No more than 4-bank activate commands may be issued in a given tFAW period. Only applies to 8-bank devices. Valid values are 2 to 63.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMOD</name>
              <description>Load mode update delay (DDR3 only). The minimum time between a load mode register command and a non-load mode register command. Valid values are: 000 = 12
001 = 13
010 = 14
011 = 15
100 = 16
101 = 17
110  111 = Reserved</description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TMRD</name>
              <description>Load mode cycle time: The minimum time between a load mode register command and any other command. For DDR3 this is the minimum time between two load mode register commands. Valid values for DDR2 are 2 to 3. For DDR3, the value used for tMRD is 4 plus the value programmed in these bits, i.e. tMRD value for DDR3 ranges from 4 to 7.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTPR2</name>
          <description>DRAM Timing Parameters Register 0-2 (DTPR0-2)</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCCD</name>
              <description>Read to read and write to write command delay. Valid values are: 0 = BL/2 for DDR2 and 4 for DDR3
1 = BL/2 + 1 for DDR2 and 5 for DDR3</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRTW</name>
              <description>Read to Write command delay. Valid values are:
0 = standard bus turn around delay
1 = add 1 clock to standard bus turn around delay
This parameter allows the user to increase the delay between issuing Write commands to the SDRAM when preceded by Read commands. This provides an option to increase bus turn-around margin for high frequency systems.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRTODT</name>
              <description>Read to ODT delay (DDR3 only). Specifies whether ODT can be enabled immediately after the read post-amble or one clock delay has to be added. Valid values are:
0 = ODT may be turned on immediately after read post-amble
1 = ODT may not be turned on until one clock after the read post-amble
If tRTODT is set to 1, then the read-to-write latency is increased by 1 if ODT is enabled.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDLLK</name>
              <description>DLL locking time. Valid values are 2 to 1023.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TCKE</name>
              <description>CKE minimum pulse width. Also specifies the minimum time that the SDRAM must remain in power down or self refresh mode. For DDR3 this parameter must be set to the value of tCKESR which is usually bigger than the value of tCKE. Valid values are 2 to 15.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXP</name>
              <description>Power down exit delay. The minimum time between a power down exit command and any other command. This parameter must be set to the maximum of the various minimum power down exit delay parameters specified in the SDRAM datasheet, i.e. max(tXP, tXARD, tXARDS) for DDR2 and max(tXP, tXPDLL) for DDR3. Valid values are 2 to 31.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TXS</name>
              <description>Self refresh exit delay. The minimum time between a self refresh exit command and any other command. This parameter must be set to the maximum of the various minimum self refresh exit delay parameters specified in the SDRAM datasheet, i.e. max(tXSNR, tXSRD) for DDR2 and max(tXS, tXSDLL) for DDR3. Valid values are 2 to 1023.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MR0</name>
          <description>Mode Register 0 (MR0) on page 108</description>
          <alternateGroup>UNION_MR0</alternateGroup>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD</name>
              <description>Power-Down Control: Controls the exit time for power-down modes. Refer to the SDRAM datasheet for details on power-down modes. Valid values are:
0 = Slow exit (DLL off) 1 = Fast exit (DLL on)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR</name>
              <description>Write Recovery: This is the value of the write recovery. It is calculated by dividing the datasheet write recovery time, tWR (ns) by the datasheet clock cycle time, tCK (ns) and rounding up a non-integer value to the next integer. Valid values are:
000 = 16
001 = 5
010 = 6
011 = 7
100 = 8
101 = 10
110 = 12
111 = 14
All other settings are reserved and should not be used.
NOTE: tWR (ns) is the time from the first SDRAM positive clock edge after the last data-in pair of a write command, to when a precharge of the same bank can be issued.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DR</name>
              <description>DLL Reset: Writing a 1 to this bit will reset the SDRAM DLL. This bit is self- clearing, i.e. it returns back to 0 after the DLL reset has been issued.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TM</name>
              <description>Operating Mode: Selects either normal operating mode (0) or test mode (1). Test mode is reserved for the manufacturer and should not be used.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLH</name>
              <description>CAS Latency: The delay between when the SDRAM registers a read command to when data is available. Valid values are:
0010 = 5
0100 = 6
0110 = 7
1000 = 8
1010 = 9
1100 = 10
1110 = 11
0001 = 12
0011 = 13
0101 = 14
All other settings are reserved and should not be used.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BT</name>
              <description>Burst Type: Indicates whether a burst is sequential (0) or interleaved (1).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLL</name>
              <description>CAS Latency low bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BL</name>
              <description>Burst Length: Determines the maximum number of column locations that can be accessed during a given read or write command. Valid values are:
Valid values for DDR3 are: 00 = 8 (Fixed)
01 = 4 or 8 (On the fly)
10 = 4 (Fixed)
11 = Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MR</name>
          <description>No description available</description>
          <alternateGroup>UNION_MR0</alternateGroup>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PD</name>
              <description>Power-Down Control: Controls the exit time for power-down modes. Refer to the SDRAM datasheet for details on power-down modes. Valid values are:
0 = Fast exit 1 = Slow exit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WR</name>
              <description>Write Recovery: This is the value of the write recovery. It is calculated by dividing the datasheet write recovery time, tWR (ns) by the datasheet clock cycle time, tCK (ns) and rounding up a non-integer value to the next integer. Valid values are:
001 = 2
010 = 3
011 = 4
100 = 5
101 = 6
All other settings are reserved and should not be used.
NOTE: tWR (ns) is the time from the first SDRAM positive clock edge after the last data-in pair of a write command, to when a precharge of the same bank can be issued.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DR</name>
              <description>DLL Reset: Writing a 1 to this bit will reset the SDRAM DLL. This bit is self- clearing, i.e. it returns back to 0 after the DLL reset has been issued.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TM</name>
              <description>Operating Mode: Selects either normal operating mode (0) or test mode (1). Test mode is reserved for the manufacturer and should not be used.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CL</name>
              <description>CAS Latency: The delay between when the SDRAM registers a read command to when data is available. Valid values are:
010 = 2
011 = 3
100 = 4
101 = 5
110 = 6
111 = 7
All other settings are reserved and should not be used.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BT</name>
              <description>Burst Type: Indicates whether a burst is sequential (0) or interleaved (1).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BL</name>
              <description>Burst Length: Determines the maximum number of column locations that can be accessed during a given read or write command. Valid values are:
010 = 4
011 = 8
All other settings are reserved and should not be used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MR1</name>
          <description>Mode Register 1 (MR1) on page 111</description>
          <alternateGroup>UNION_MR1</alternateGroup>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QOFF</name>
              <description>Output Enable/Disable: When 0, all outputs function normal; when 1 all SDRAM outputs are disabled removing output buffer current. This feature is intended to be used for IDD characterization of read current and should not be used in normal operation.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDQS</name>
              <description>Termination Data Strobe: When enabled (1) TDQS provides additional termination resistance outputs that may be useful in some system configurations. Refer to the SDRAM datasheet for details.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTTH</name>
              <description>On Die Termination high bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEVEL</name>
              <description>Write Leveling Enable: Enables write-leveling when set.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTTM</name>
              <description>On Die Termination mid bit:
Selects the effective resistance for SDRAM on die termination. Valid values are:
000 = ODT disabled 001 = RZQ/4
010 = RZQ/2
011 = RZQ/6
100 = RZQ/12
101 = RZQ/8
All other settings are reserved and should not be used.
Bit on [9, 6,2]</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DICH</name>
              <description>Output Driver Impedance Control high bit:
Controls the output drive strength. Valid values are:
00 = RZQ/6
01 = RZQ7
10 = Reserved
11 = Reserved</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AL</name>
              <description>Posted CAS Additive Latency: Setting additive latency that allows read and write commands to be issued to the SDRAM earlier than normal (refer to the SDRAM datasheet for details). Valid values are:
00 = 0 (AL disabled)
01 = CL - 1
10 = CL - 2
11 = Reserved</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTTL</name>
              <description>On Die Termination low bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DICL</name>
              <description>Output Driver Impedance Control low bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DE</name>
              <description>DLL Enable/Disable: Enable (0) or disable (1) the DLL. DLL must be enabled for normal operation.
Note: SDRAM DLL off mode is not supported</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMR</name>
          <description>No description available</description>
          <alternateGroup>UNION_MR1</alternateGroup>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>QOFF</name>
              <description>Output Enable/Disable: When 0, all outputs function normal; when 1 all SDRAM outputs are disabled removing output buffer current. This feature is intended to be
used for IDD characterization of read current and should not be used in normal operation.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDQS</name>
              <description>RDQS Enable/Disable: When enabled (1), RDQS is identical in function and timing to data strobe DQS during a read, and ignored during a write. A 0 disables the SDRAM from driving RDQS. The Controller does not allow the user to change this bit.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DQS</name>
              <description>DQS_b Enable/Disable: When 0, DQS_b is the complement of the differential data strobe pair DQS/DQS_b. When 1, DQS is used in a single-ended mode and the DQS_b pin is disabled. Also used to similarly enable/disable RDQS_b if RDQS is enabled. The Controller does not allow the user to change this bit.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCD</name>
              <description>Off-Chip Driver (OCD) Impedance Calibration: Used to calibrate and match pull-up to pull- down impedance to 18  nominal (refer to the SDRAM datasheet for details). Valid values are:
000 = OCD calibration mode exit 001 = Drive (1) pull-up
010 = Drive (0) pull-down
100 = OCD enter adjust mode 111 = OCD calibration default
All other settings are reserved and should not be used. Note that OCD is not supported by all vendors. Refer to the SDRAM datasheet for details on the recommended OCD settings.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTTH</name>
              <description>On Die Termination high bit:
Selects the effective resistance for SDRAM on die termination. Valid values are:
00 = ODT disabled 01 = 75
10 = 150
11 = 50 (some vendors)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AL</name>
              <description>Posted CAS Additive Latency: Setting additive latency that allows read and write commands to be issued to the SDRAM earlier than normal (refer to the SDRAM datasheet for details). Valid values are:
000 = 0
001 = 1
010 = 2
011 = 3
100 = 4
101 = 5
All other settings are reserved and should not be used. The maximum allowed value of AL is tRCD-1.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RTTL</name>
              <description>On Die Termination low bit:</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIC</name>
              <description>Output Driver Impedance Control: Controls the output drive strength. Valid values are:
0 = Full strength
1 = Reduced strength</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DE</name>
              <description>DLL Enable/Disable: Enable (0) or disable (1) the DLL. DLL must be enabled for normal operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MR2</name>
          <description>Mode Register 2/Extended Mode Register 2 (MR2/EMR2) on page 114</description>
          <alternateGroup>UNION_MR2</alternateGroup>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTTWR</name>
              <description>Dynamic ODT: Selects RTT for dynamic ODT. Valid values are: 00 = Dynamic ODT off
01 = RZQ/4
10 = RZQ/2
11 = Reserved</description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SRT</name>
              <description>Self-Refresh Temperature Range: Selects either normal (0) or extended (1) operating temperature range during self-refresh.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASR</name>
              <description>Auto Self-Refresh: When enabled (1), SDRAM automatically provides self-refresh power management functions for all supported operating temperature values.
Otherwise the SRT bit must be programmed to indicate the temperature range.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CWL</name>
              <description>CAS Write Latency: The delay between when the SDRAM registers a write command to when write data is available. Valid values are:
000 = 5 (tCK &gt; 2.5ns)
001 = 6 (2.5ns &gt; tCK &gt; 1.875ns)
010 = 7 (1.875ns &gt; tCK&gt; 1.5ns)
011 = 8 (1.5ns &gt; tCK &gt; 1.25ns)
100 = 9 (1.25ns &gt; tCK &gt; 1.07ns)
101 = 10 (1.07ns &gt; tCK &gt; 0.935ns)
110 = 11 (0.935ns &gt; tCK &gt; 0.833ns)
111 = 12 (0.833ns &gt; tCK &gt; 0.75ns)
All other settings are reserved and should not be used.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PASR</name>
              <description>Partial Array Self Refresh: Specifies that data located in areas of the array beyond the specified location will be lost if self refresh is entered.
Valid settings for 4 banks are:
000 = Full Array
001 = Half Array (BA[1:0] = 00 &amp; 01)
010 = Quarter Array (BA[1:0] = 00) 011 = Not defined
100 = 3/4 Array (BA[1:0] = 01, 10, &amp; 11)
101 = Half Array (BA[1:0] = 10 &amp; 11)
110 = Quarter Array (BA[1:0] = 11) 111 = Not defined
Valid settings for 8 banks are:
000 = Full Array
001 = Half Array (BA[2:0] = 000, 001, 010 &amp; 011)
010 = Quarter Array (BA[2:0] = 000, 001) 011 = 1/8 Array (BA[2:0] = 000)
100 = 3/4 Array (BA[2:0] = 010, 011, 100, 101, 110 &amp; 111)
101 = Half Array (BA[2:0] = 100, 101, 110 &amp; 111)
110 = Quarter Array (BA[2:0] = 110 &amp; 111)
111 = 1/8 Array (BA[2:0] 111)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMR2</name>
          <description>No description available</description>
          <alternateGroup>UNION_MR2</alternateGroup>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SRF</name>
              <description>Self Refresh Rate: Enables, if set, high temperature self refresh rate.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DCC</name>
              <description>Duty Cycle Corrector: Enables, if set, duty cycle correction within SDRAM.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PASR</name>
              <description>Partial Array Self Refresh: Specifies that data located in areas of the array beyond the specified location will be lost if self refresh is entered.
Valid settings for 4 banks are:
000 = Full Array
001 = Half Array (BA[1:0] = 00 &amp; 01)
010 = Quarter Array (BA[1:0] = 00) 011 = Not defined
100 = 3/4 Array (BA[1:0] = 01, 10, &amp; 11)
101 = Half Array (BA[1:0] = 10 &amp; 11)
110 = Quarter Array (BA[1:0] = 11) 111 = Not defined
Valid settings for 8 banks are:
000 = Full Array
001 = Half Array (BA[2:0] = 000, 001, 010 &amp; 011)
010 = Quarter Array (BA[2:0] = 000, 001) 011 = 1/8 Array (BA[2:0] = 000)
100 = 3/4 Array (BA[2:0] = 010, 011, 100, 101, 110 &amp; 111)
101 = Half Array (BA[2:0] = 100, 101, 110 &amp; 111)
110 = Quarter Array (BA[2:0] = 110 &amp; 111)
111 = 1/8 Array (BA[2:0] 111)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MR3</name>
          <description>Mode Register 3 (MR3) on page 116</description>
          <alternateGroup>UNION_MR3</alternateGroup>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MPR</name>
              <description>Multi-Purpose Register Enable: Enables, if set, that read data should come from the Multi-Purpose Register. Otherwise read data come from the DRAM array.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MPRLOC</name>
              <description>Multi-Purpose Register (MPR) Location: Selects MPR data location: Valid value are: 00 = Predefined pattern for system calibration
All other settings are reserved and should not be used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EMR3</name>
          <description>No description available</description>
          <alternateGroup>UNION_MR3</alternateGroup>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
        </register>
        <register>
          <name>ODTCR</name>
          <description>ODT Configuration Register (ODTCR) on page 117</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WRODT3</name>
              <description>No description available</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRODT2</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRODT1</name>
              <description>No description available</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WRODT0</name>
              <description>Write ODT: Specifies whether ODT should be enabled (1) or disabled (0) on each of the up to four ranks when a write command is sent to rank n. WRODT0, WRODT1, WRODT2, and WRODT3 specify ODT settings when a write is to rank 0, rank 1, rank 2, and rank 3, respectively. The four bits of each field each represent a rank, the LSB being rank 0 and the MSB being rank 3. Default is to enable ODT only on rank being written to.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDODT3</name>
              <description>No description available</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDODT2</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDODT1</name>
              <description>No description available</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDODT0</name>
              <description>Read ODT: Specifies whether ODT should be enabled (1) or disabled (0) on each of the up to four ranks when a read command is sent to rank n. RDODT0, RDODT1, RDODT2, and RDODT3 specify ODT settings when a read is to rank 0, rank 1, rank 2, and rank 3, respectively. The four bits of each field each represent a rank, the LSB being rank 0 and the MSB being rank 3. Default is to disable ODT during reads.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTCR</name>
          <description>Data Training Configuration Register (DTCR) on page 118</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFF7FFFFF</resetMask>
          <fields>
            <field>
              <name>RFSHDT</name>
              <description>Refresh During Training: A non-zero value specifies that a burst of refreshes equal to the number specified in this field should be sent to the SDRAM after training each rank except the last rank.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RANKEN</name>
              <description>Rank Enable: Specifies the ranks that are enabled for data-training. Bit 0 controls rank 0, bit 1 controls rank 1, bit 2 controls rank 2, and bit 3 controls rank 3. Setting the bit to 1 enables the rank, and setting it to 0 disables the rank.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTEXD</name>
              <description>Data Training Extended Write DQS: Enables, if set, an extended write DQS whereby two additional pulses of DQS are added as post-amble to a burst of writes.
Generally this should only be enabled when running read bit deskew with the intention of performing read eye deskew prior to running write leveling adjustment.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTDSTP</name>
              <description>Data Training Debug Step: A write of 1 to this bit steps the data training algorithm through a single step. This bit is used to initiate one step of the data training algorithm in question.
This bit is self-clearing. To trigger the next step, this bit must be written to again. Note: The training steps must be repeated in order to get new data in the Data Training Eye Data Register 0-1 (DTEDR0-1) on page 122. For example, to see the
training results for a different lane, select that lane and repeat the training steps to
populate DTEDR0 and DTEDR1 with the correct data.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTDEN</name>
              <description>Data Training Debug Enable: Enables, if set, the data training single step debug mode.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTDBS</name>
              <description>Data Training Debug Byte Select: Selects the byte during data training single step debug mode.
Note: DTDEN is not used to enable this feature.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTWDQMO</name>
              <description>Data Training WDQ Margin Override: If set, the Training WDQ Margin value specified in DTCR[11:8] (DTWDQM) is used during data training. Otherwise the value is computed as  of the ddr_clk period measurement found during calibration of the WDQ LCDL.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBDC</name>
              <description>Data Training Bit Deskew Centering: Enables, if set, eye centering capability during write and read bit deskew training.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTWBDDM</name>
              <description>Data Training Write Bit Deskew Data Mask, if set, it enables write bit deskew of the data mask</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTWDQM</name>
              <description>Training WDQ Margin: Defines how close to 0 or how close to 2*(wdq calibration_value) the WDQ LCDL can be moved during training. Basically defines how much timing margin.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCMPD</name>
              <description>Read Data Training Compare Data: Specifies, if set, that DQS gate training should also check if the returning read data is correct. Otherwise data-training only checks if the correct number of DQS edges were returned.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTMPR</name>
              <description>Read Data Training Using MPR (DDR3 Only): Specifies, if set, that DQS gate training should use the SDRAM Multi-Purpose Register (MPR) register. Otherwise data-training is performed by first writing to some locations in the SDRAM and then reading them back.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTRANK</name>
              <description>Data Training Rank: Select the SDRAM rank to be used during Read DQS gate training, Read/Write Data Bit Deskew, Read/Write Eye Training.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTRPTN</name>
              <description>Data Training Repeat Number: Repeat number used to confirm stability of DDR write or read.
Note: The minimum value should be 0x4 and the maximum value should be 0x14.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTAR0</name>
          <description>Data Training Address Register 0-3 (DTAR0-3)</description>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTBANK</name>
              <description>Data Training Bank Address: Selects the SDRAM bank address to be used during data training.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTROW</name>
              <description>Data Training Row Address: Selects the SDRAM row address to be used during data training.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCOL</name>
              <description>Data Training Column Address: Selects the SDRAM column address to be used during data training. The lower four bits of this address must always be 000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTAR1</name>
          <description>Data Training Address Register 0-3 (DTAR0-3)</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTBANK</name>
              <description>Data Training Bank Address: Selects the SDRAM bank address to be used during data training.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTROW</name>
              <description>Data Training Row Address: Selects the SDRAM row address to be used during data training.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCOL</name>
              <description>Data Training Column Address: Selects the SDRAM column address to be used during data training. The lower four bits of this address must always be 000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTAR2</name>
          <description>Data Training Address Register 0-3 (DTAR0-3)</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTBANK</name>
              <description>Data Training Bank Address: Selects the SDRAM bank address to be used during data training.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTROW</name>
              <description>Data Training Row Address: Selects the SDRAM row address to be used during data training.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCOL</name>
              <description>Data Training Column Address: Selects the SDRAM column address to be used during data training. The lower four bits of this address must always be 000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTAR3</name>
          <description>Data Training Address Register 0-3 (DTAR0-3)</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTBANK</name>
              <description>Data Training Bank Address: Selects the SDRAM bank address to be used during data training.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTROW</name>
              <description>Data Training Row Address: Selects the SDRAM row address to be used during data training.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTCOL</name>
              <description>Data Training Column Address: Selects the SDRAM column address to be used during data training. The lower four bits of this address must always be 000.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR0</name>
          <description>Data Training Eye Data Register 0-1 (DTEDR0-1)</description>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTBYTE3</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBYTE2</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBYTE1</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBYTE0</name>
              <description>Data Training Data: The first 4 bytes of data used during data training. This same data byte is used for each Byte Lane. Default sequence is a walking 1 while toggling data every data cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR1</name>
          <description>Data Training Eye Data Register 0-1 (DTEDR0-1)</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTBYTE7</name>
              <description>No description available</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBYTE6</name>
              <description>No description available</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBYTE5</name>
              <description>No description available</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTBYTE4</name>
              <description>Data Training Data: The second 4 bytes of data used during data training. This same data byte is used for each Byte Lane. Default sequence is a walking 1 while toggling data every data cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTEDR0</name>
          <description>Data Training Eye Data Register 0-1 (DTEDR0-1)</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTWBMX</name>
              <description>Data Training Write BDL Shift Maximum.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DTWBMN</name>
              <description>Data Training Write BDL Shift Minimum.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DTWLMX</name>
              <description>Data Training WDQ LCDL Maximum.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DTWLMN</name>
              <description>Data Training WDQ LCDL Minimum.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DTEDR1</name>
          <description>Data Training Eye Data Register 0-1 (DTEDR0-1)</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DTRBMX</name>
              <description>Data Training Read BDL Shift Maximum.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DTRBMN</name>
              <description>Data Training Read BDL Shift Minimum.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DTRLMX</name>
              <description>Data Training RDQS LCDL Maximum.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DTRLMN</name>
              <description>Data Training RDQS LCDL Minimum.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PGCR2</name>
          <description>PHY General Configuration Register 2 (PGCR2) on page 87</description>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DYNACPDD1</name>
              <description>Dynamic AC Power Down Driver: Powers down, when set, the output driver on I/O for ADDR and BA. This bit is ORed with bit ACIOCR[3] (ACPDD).</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LPMSTRC0</name>
              <description>Low-Power Master Channel 0: set to 1 to have channel 0 act as master to drive channel 1 low-power functions simultaneously. Only valid in shared-AC mode.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ACPDDC</name>
              <description>AC Power-Down with Dual Channels: Set to 1 to power-down address/command lane when both data channels are powered-down. Only valid in shared-AC mode.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SHRAC</name>
              <description>Shared-AC mode: set to 1 to enable shared address/command mode with two independent data channels  available only if shared address/command mode support is compiled in.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DTPMXTMR</name>
              <description>Data Training PUB Mode Timer Exit: Specifies the number of controller clocks to wait when entering and exiting pub mode data training. The default value ensures controller refreshes do not cause memory model errors when entering and exiting data training. The value should be increased if controller initiated SDRAM ZQ short or long operation may occur just before or just after the execution of data training.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FXDLAT</name>
              <description>Fixed Latency: Specified whether all reads should be returned to the controller with a fixed read latency. Enabling fixed read latency increases the read latency. Valid values are:
0 = Disable fixed read latency 1 = Enable fixed read latency
Fixed read latency is calculated as (12 + (maximum DXnGTR.RxDGSL)/2) HDR clock cycles</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NOBUB</name>
              <description>No Bubbles: Specified whether reads should be returned to the controller with no bubbles. Enabling no-bubble reads increases the read latency. Valid values are: 0 = Bubbles are allowed during reads
1 = Bubbles are not allowed during reads</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TREFPRD</name>
              <description>Refresh Period: Indicates the period, after which the PUB has to issue a refresh command to the SDRAM. This is derived from the maximum refresh interval from the datasheet, tRFC(max) or REFI, divided by the clock cycle time. A further 400 clocks must be subtracted from the derived number to account for command flow and missed slots of refreshes in the internal PUB blocks. The default corresponds to DDR3 9*7.8us at 1066MHz when a burst of 9 refreshes are issued at every refresh interval.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RDIMMGCR0</name>
          <description>RDIMM General Configuration Register 0-1 (RDIMMGCR0-1)</description>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MIRROR</name>
              <description>RDIMM Mirror: Selects between two different ballouts of the RDIMM buffer chip for front or back operation. This register bit controls the buffer chip MIRROR signal.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QCSEN</name>
              <description>RDMIMM Quad CS Enable: Enables, if set, the Quad CS mode for the RDIMM registering buffer chip. This register bit controls the buffer chip QCSEN# signal.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>MIRROROE</name>
              <description>MIRROR Output Enable: Enables, when set, the output driver on the I/O for MIRROR pin.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>QCSENOE</name>
              <description>QCSEN# Output Enable: Enables, when set, the output driver on the I/O for QCSEN# pin.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDIMMIOM</name>
              <description>RDIMM Outputs I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for QCSEN# and MIRROR pins.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDIMMPDR</name>
              <description>RDIMM Outputs Power Down Receiver: Powers down, when set, the input receiver on the I/O for QCSEN# and MIRROR pins.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDIMMPDD</name>
              <description>RDIMM Outputs Power Down Driver: Powers down, when set, the output driver on the I/O for QCSEN# and MIRROR pins.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDIMMODT</name>
              <description>RDIMM Outputs On-Die Termination: Enables, when set, the on-die termination on the I/O for QCSEN# and MIRROR pins.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROUTOE</name>
              <description>ERROUT# Output Enable: Enables, when set, the output driver on the I/O for ERROUT# pin.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROUTIOM</name>
              <description>ERROUT# I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for ERROUT# pin.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROUTPDR</name>
              <description>ERROUT# Power Down Receiver: Powers down, when set, the input receiver on the I/O for ERROUT# pin.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROUTPDD</name>
              <description>ERROUT# Power Down Driver: Powers down, when set, the output driver on the I/O for ERROUT# pin.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROUTODT</name>
              <description>ERROUT# On-Die Termination: Enables, when set, the on-die termination on the I/O for ERROUT# pin.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARINOE</name>
              <description>PAR_IN Output Enable: Enables, when set, the output driver on the I/O for PAR_IN pin.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARINIOM</name>
              <description>PAR_IN I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for PAR_IN pin.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARINPDR</name>
              <description>PAR_IN Power Down Receiver: Powers down, when set, the input receiver on the I/O for PAR_IN pin.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARINPDD</name>
              <description>PAR_IN Power Down Driver: Powers down, when set, the output driver on the I/O for PAR_IN pin.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARINODT</name>
              <description>PAR_IN On-Die Termination: Enables, when set, the on-die termination on the I/O for PAR_IN pin.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SOPERR</name>
              <description>Stop On Parity Error: Indicates, if set, that the PUB is to stop driving commands to the DRAM upon encountering a parity error. Transactions can resume only after status is cleared via PIR.CLRSR.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERRNOREG</name>
              <description>Parity Error No Registering: Indicates, if set, that parity error signal from the RDIMM should be passed to the DFI controller without any synchronization or registering. Otherwise, the error signal is synchronized as shown in Figure 4-30 on page 262.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDIMM</name>
              <description>Registered DIMM: Indicates, if set, that a registered DIMM is used. In this case, the PUB increases the SDRAM write and read latencies (WL/RL) by 1 and also enforces that accesses adhere to RDIMM buffer chip. This only applies to PUB internal SDRAM transactions. Transactions generated by the controller must make its own adjustments to WL/RL when using a registered DIMM. The DCR.NOSRA register bit must be set to 1 if using the standard RDIMM buffer chip so that normal DRAM accesses do not assert multiple chip select bits at the same time.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RDIMMGCR1</name>
          <description>RDIMM General Configuration Register 0-1 (RDIMMGCR0-1)</description>
          <addressOffset>0xb4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRINIT</name>
              <description>Control Registers Initialization Enable: Indicates which RDIMM buffer chip control registers (RC0 to RC15) should be initialized (written) when the PUB is triggered to initialize the buffer chip. A setting of 1 on CRINIT[n] bit means that CRn should be written during initialization.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBCMRD</name>
              <description>Command word to command word programming delay: Number of DRAM clock cycles between two RDIMM buffer chip command programming accesses. The value used for tBCMRD is 8 plus the value programmed in these bits, i.e. tBCMRD value ranges from 8 to 15. This parameter corresponds to the buffer chip tMRD parameter.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TBCSTAB</name>
              <description>Stabilization time: Number of DRAM clock cycles for the RDIMM buffer chip to stabilize. This parameter corresponds to the buffer chip tSTAB parameter. Default value is in decimal format and corresponds to 6us at 533MHz.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RDIMMCR0</name>
          <description>RDIMM Control Register 0-1 (RDIMMCR0-1)</description>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RC7</name>
              <description>Control Word 7: Reserved, free to use by vendor.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC6</name>
              <description>Control Word 6: Reserved, free to use by vendor.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC5</name>
              <description>Control Word 5 (CK Driver Characteristics Control Word): RC5[1:0] is driver settings for clock Y1, Y1#, Y3, and Y3# outputs, and RC5[3:2] is driver settings for clock Y0, Y0#, Y2, and Y2# outputs. Bit definitions are:
00 = Light drive (4 or 5 DRAM loads)
01 = Moderate drive (8 or 10 DRAM loads)
10 = Strong drive (16 or 20 DRAM loads)
11 = Reserved</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC4</name>
              <description>Control Word 4 (Control Signals Driver Characteristics Control Word): RC4[1:0] is driver settings for control A outputs, and RC4[3:2] is driver settings for control B outputs. Bit definitions are:
00 = Light drive (4 or 5 DRAM loads)
01 = Moderate drive (8 or 10 DRAM loads)
10 = Reserved
11 = Reserved</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC3</name>
              <description>Control Word 3 (Command/Address Signals Driver Characteristics Control Word): RC3[1:0] is driver settings for command/address A outputs, and RC3[3:2] is driver settings for command/address B outputs. Bit definitions are:
00 = Light drive (4 or 5 DRAM loads)
01 = Moderate drive (8 or 10 DRAM loads)
10 = Strong drive (16 or 20 DRAM loads)
11 = Reserved</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC2</name>
              <description>Control Word 2 (Timing Control Word): Bit definitions are:
RC2[0]: 0 = Standard (1/2 clock) pre-launch, 1 = Prelaunch controlled by RC12. RC2[1]: 0 = Reserved.
RC2[2]: 0 = 100 Ohm input bus termination, 1 = 150 Ohm input bus termination. RC2[3]: 0 = Operation frequency band 1, 1 = Test mode frequency band 2.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC1</name>
              <description>Control Word 1 (Clock Driver Enable Control Word): Bit definitions are: RC1[0]: 0 = Y0/Y0# clock enabled, 1 = Y0/Y0# clock disabled.
RC1[1]: 0 = Y1/Y1# clock enabled, 1 = Y1/Y1# clock disabled. RC1[2]: 0 = Y2/Y2# clock enabled, 1 = Y2/Y2# clock disabled. RC1[3]: 0 = Y3/Y3# clock enabled, 1 = Y3/Y3# clock disabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC0</name>
              <description>Control Word 0 (Global Features Control Word): Bit definitions are: RC0[0]: 0 = Output inversion enabled, 1 = Output inversion disabled. RC0[1]: 0 = Floating outputs disabled, 1 = Floating outputs enabled. RC0[2]: 0 = A outputs enabled, 1 = A outputs disabled.
RC0[3]: 0 = B outputs enabled, 1 = B outputs disabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RDIMMCR1</name>
          <description>RDIMM Control Register 0-1 (RDIMMCR0-1)</description>
          <addressOffset>0xbc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RC15</name>
              <description>Control Word 15: Reserved for future use.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC14</name>
              <description>Control Word 14: Reserved for future use.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC13</name>
              <description>Control Word 13: Reserved for future use.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC12</name>
              <description>Control Word 12: Reserved for future use.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC11</name>
              <description>Control Word 11 (Operating Voltage VDD Control Word): RC10[1:0] is VDD operating voltage setting as follows: 00 = DDR3 1.5V mode
01 = DDR3L 1.35V mode
10 = Reserved
11 = Reserved RC10[3:2]: Reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC10</name>
              <description>Control Word 10 (RDIMM Operating Speed Control Word): RC10[2:0] is RDIMM operating speed setting as follows: 000 = DDR3/DDR3L-800
001 = DDR3/DDR3L-1066
010 = DDR3/DDR3L-1333
011 = DDR3/DDR3L-1600
100 = Reserved
101 = Reserved
110 = Reserved
111 = Reserved RC10[3]: Dont care.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC9</name>
              <description>Control Word 9 (Power Saving Settings Control Word): Bit definitions are: RC9[0]: 0 = Floating outputs as defined in RC0, 1 = Weak drive enabled. RC9[1]: 0 = Reserved.
RC9[2]: 0 = CKE power down with IBT ON, QxODT is a function of DxODT, 1 = CKE power down with IBT off, QxODT held LOW. RC9[2] is valid only when RC9[3] is 1.
RC9[3]: 0 = CKE power down mode disabled, 1 = CKE power down mode enabled.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RC8</name>
              <description>Control Word 8 (Additional Input Bus Termination Setting Control Word): RC8[2:0] is Input Bus Termination (IBT) setting as follows:
000 = IBT as defined in RC2. 001 = Reserved
010 = 200 Ohm
011 = Reserved
100 = 300 Ohm
101 = Reserved
110 = Reserved
111 = Off
RC8[3]: 0 = IBT off when MIRROR is HIGH, 1 = IBT on when MIRROR is high</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCUAR</name>
          <description>DCU Address Register (DCUAR) on page 129</description>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ATYPE</name>
              <description>Access Type: Specifies the type of access to be performed using this address. Valid values are:
0 = Write access 1 = Read access</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INCA</name>
              <description>Increment Address: Specifies, if set, that the cache address specified in WADDR and SADDR should be automatically incremented after each access of the cache. The increment happens in such a way that all the slices of a selected word are first accessed before going to the next word.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSEL</name>
              <description>Cache Select: Selects the cache to be accessed. Valid values are: 00 = Command cache
01 = Expected data cache 10 = Read data cache
11 = Reserved</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSADDR</name>
              <description>Cache Slice Address: Address of the cache slice to be accessed.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CWADDR</name>
              <description>Cache Word Address: Address of the cache word to be accessed.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCUDR</name>
          <description>DCU Data Register (DCUDR) on page 130</description>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CDATA</name>
              <description>Cache Data: Data to be written to or read from a cache. This data corresponds to the cache word slice specified by the DCU Address Register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCURR</name>
          <description>DCU Run Register (DCURR) on page 130</description>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XCEN</name>
              <description>Expected Compare Enable: Indicates, if set, that read data coming back from the SDRAM should be should be compared with the expected data.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RCEN</name>
              <description>Read Capture Enable: Indicates, if set, that read data coming back from the SDRAM should be captured into the read data cache.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SCOF</name>
              <description>Stop Capture On Full: Specifies, if set, that the capture of read data should stop when the capture cache is full.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SONF</name>
              <description>Stop On Nth Fail: Specifies, if set, that the execution of commands and the capture of read data should stop when there are N read data failures. The number of failures is specified by NFAIL. Otherwise commands execute until the end of the program or until manually stopped using a STOP command.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NFAIL</name>
              <description>Number of Failures: Specifies the number of failures after which the execution of commands and the capture of read data should stop if SONF bit of this register is set. Execution of commands and the capture of read data will stop after (NFAIL+1) failures if SONF is set.
Valid values are from 0 to 254.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EADDR</name>
              <description>End Address: Cache word address where the execution of command should end.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SADDR</name>
              <description>Start Address: Cache word address where the execution of commands should begin.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DINST</name>
              <description>DCU Instruction: Selects the DCU command to be executed: Valid values are: 0000 = NOP: No operation
0001 = Run: Triggers the execution of commands in the command cache. 0010 = Stop: Stops the execution of commands in the command cache.
0011 = Stop Loop: Stops the execution of an infinite loop in the command cache. 0100 = Reset: Resets all DCU run time registers. See DCU Status on page 255 for details.
0101  1111 Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCULR</name>
          <description>DCU Loop Register (DCULR) on page 131</description>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>XLEADDR</name>
              <description>Expected Data Loop End Address: The last expected data cache word address that contains valid expected data. Expected data should looped between 0 and this address.
XLEADDR field uses only the following bits based on the cache depth:
DCU expected data cache = 4, XLEADDR[1:0]
DCU expected data cache = 8, XLEADDR[2:0]
DCU expected data cache = 16, XLEADDR[3:0]</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IDA</name>
              <description>Increment DRAM Address: Indicates, if set, that DRAM addresses should be incremented every time a DRAM read/write command inside the loop is executed.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINF</name>
              <description>Loop Infinite: Indicates, if set, that the loop should be executed indefinitely until stopped by the STOP command. Otherwise the loop is execute LCNT times.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LCNT</name>
              <description>Loop Count: The number of times that the loop should be executed if LINF is not set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEADDR</name>
              <description>Loop End Address: Command cache word address where the loop should end.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSADDR</name>
              <description>Loop Start Address: Command cache word address where the loop should start.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCUGCR</name>
          <description>DCU General Configuration Register (DCUGCR) on page 132</description>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RCSW</name>
              <description>Read Capture Start Word: The capture and compare of read data should start after Nth word. For example setting this value to 12 will skip the first 12 read data.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCUTPR</name>
          <description>DCU Timing Parameter Register (DCUTPR) on page 132</description>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDCUT3</name>
              <description>DCU Generic Timing Parameter 3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDCUT2</name>
              <description>DCU Generic Timing Parameter 2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDCUT1</name>
              <description>DCU Generic Timing Parameter 1</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDCUT0</name>
              <description>DCU Generic Timing Parameter 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCUSR0</name>
          <description>DCU Status Register 0-1 (DCUSR0-1)</description>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFULL</name>
              <description>Capture Full: Indicates, if set, that the capture cache is full.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CFAIL</name>
              <description>Capture Fail: Indicates, if set, that at least one read data word has failed.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDONE</name>
              <description>Run Done: Indicates, if set, that the DCU has finished executing the commands in the command cache. This bit is also set to indicate that a STOP command has successfully been executed and command execution has stopped.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCUSR1</name>
          <description>DCU Status Register 0-1 (DCUSR0-1)</description>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LPCNT</name>
              <description>Loop Count: Indicates the value of the loop count. This is useful when the program has stopped because of failures to assess how many reads were executed before first fail.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FLCNT</name>
              <description>Fail Count: Number of read words that have failed.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RDCNT</name>
              <description>Read Count: Number of read words returned from the SDRAM.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTRR</name>
          <description>BIST Run Register (BISTRR) on page 133</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCCSEL</name>
              <description>BIST Clock Cycle Select: Selects the clock numbers on which the AC loopback data is written into the FIFO. Data is written into the loopback FIFO once every four clock cycles. Valid values are:
00 = Clock cycle 0, 4, 8, 12, etc.
01 = Clock cycle 1, 5, 9, 13, etc.
10 = Clock cycle 2, 6, 10, 14, etc.
11 = Clock cycle 3, 7, 11, 15, etc.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCKSEL</name>
              <description>BIST CK Select: Selects the CK that should be used to register the AC loopback signals from the I/Os. Valid values are:
00 = CK[0]
01 = CK[1]
10 = CK[2]
11 = Reserved</description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BDXSEL</name>
              <description>BIST DATX8 Select: Select the byte lane for comparison of loopback/read data. Valid values are 0 to 8.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BDPAT</name>
              <description>BIST Data Pattern: Selects the data pattern used during BIST. Valid values are: 00 = Walking 0
01 = Walking 1
10 = LFSR-based pseudo-random
11 = User programmable (Not valid for AC loopback).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BDMEN</name>
              <description>BIST Data Mask Enable: Enables, if set, that the data mask BIST should be included in the BIST run, i.e. data pattern generated and loopback data compared. This is valid only for loopback mode.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BACEN</name>
              <description>BIST AC Enable: Enables the running of BIST on the address/command lane PHY. This bit is exclusive with BDXEN, i.e. both cannot be set to 1 at the same time.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BDXEN</name>
              <description>BIST DATX8 Enable: Enables the running of BIST on the data byte lane PHYs. This bit is exclusive with BACEN, i.e. both cannot be set to 1 at the same time.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BSONF</name>
              <description>BIST Stop On Nth Fail: Specifies, if set, that the BIST should stop when an nth data word or address/command comparison error has been encountered.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NFAIL</name>
              <description>Number of Failures: Specifies the number of failures after which the execution of commands and the capture of read data should stop if BSONF bit of this register is set. Execution of commands and the capture of read data will stop after (NFAIL+1) failures if BSONF is set.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BINF</name>
              <description>BIST Infinite Run: Specifies, if set, that the BIST should be run indefinitely until when it is either stopped or a failure has been encountered. Otherwise BIST is run until number of BIST words specified in the BISTWCR register has been generated.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BMODE</name>
              <description>BIST Mode: Selects the mode in which BIST is run. Valid values are:
0 = Loopback mode: Address, commands and data loop back at the PHY I/Os.
1 = DRAM mode: Address, commands and data go to DRAM for normal memory accesses.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BINST</name>
              <description>BIST Instruction: Selects the BIST instruction to be executed: Valid values are: 000 = NOP: No operation
001 = Run: Triggers the running of the BIST. 010 = Stop: Stops the running of the BIST.
011 = Reset: Resets all BIST run-time registers, such as error counters. 100  111 Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTWCR</name>
          <description>BIST Word Count Register (BISTWCR) on page 136</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BWCNT</name>
              <description>BIST Word Count: Indicates the number of words to generate during BIST. This must be a multiple of DRAM burst length (BL) divided by 2, e.g. for BL=8, valid values are 4, 8, 12, 16, and so on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTMSKR0</name>
          <description>BIST Mask Register 0-2 (BISTMSKR0-2)</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ODTMSK</name>
              <description>Mask bit for each of the up to 4 ODT bits.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSMSK</name>
              <description>Mask bit for each of the up to 4 CS# bits.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CKEMSK</name>
              <description>Mask bit for each of the up to 4 CKE bits.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WEMSK</name>
              <description>Mask bit for the WE#.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BAMSK</name>
              <description>Mask bit for each of the up to 3 bank address bits.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMSK</name>
              <description>Mask bit for each of the up to 16 address bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTMSKR1</name>
          <description>BIST Mask Register 0-2 (BISTMSKR0-2)</description>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMMSK</name>
              <description>Mask bit for the data mask (DM) bit.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PARMSK</name>
              <description>Mask bit for the PAR_IN. Only for DIMM parity support and only if the design is compiled for less than 3 ranks.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CASMSK</name>
              <description>Mask bit for the CAS.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RASMSK</name>
              <description>Mask bit for the RAS.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTMSKR2</name>
          <description>BIST Mask Register 0-2 (BISTMSKR0-2)</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DQMSK</name>
              <description>Mask bit for each of the 8 data (DQ) bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTLSR</name>
          <description>BIST LFSR Seed Register (BISTLSR) on page 137</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEED</name>
              <description>LFSR seed for pseudo-random BIST patterns.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTAR0</name>
          <description>BIST Address Register 0-2 (BISTAR0-2)</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BBANK</name>
              <description>BIST Bank Address: Selects the SDRAM bank address to be used during BIST.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BROW</name>
              <description>BIST Row Address: Selects the SDRAM row address to be used during BIST.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BCOL</name>
              <description>BIST Column Address: Selects the SDRAM column address to be used during BIST. The lower bits of this address must be 0000 for BL16, 000 for BL8, 00 for BL4 and 0 for BL2.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTAR1</name>
          <description>BIST Address Register 0-2 (BISTAR0-2)</description>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BAINC</name>
              <description>BIST Address Increment: Selects the value by which the SDRAM address is incremented for each write/read access. This value must be at the beginning of a burst boundary, i.e. the lower bits must be 0000 for BL16, 000 for BL8, 00 for BL4 and 0 for BL2.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BMRANK</name>
              <description>BIST Maximum Rank: Specifies the maximum SDRAM rank to be used during BIST. The default value is set to maximum ranks minus 1. Example default shown here is for a 4-rank system</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BRANK</name>
              <description>BIST Rank: Selects the SDRAM rank to be used during BIST. Valid values range from 0 to maximum ranks minus 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTAR2</name>
          <description>BIST Address Register 0-2 (BISTAR0-2)</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BMBANK</name>
              <description>BIST Maximum Bank Address: Specifies the maximum SDRAM bank address to be used during BIST before the address increments to the next rank.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BMROW</name>
              <description>BIST Maximum Row Address: Specifies the maximum SDRAM row address to be used during BIST before the address increments to the next bank.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BMCOL</name>
              <description>BIST Maximum Column Address: Specifies the maximum SDRAM column address to be used during BIST before the address increments to the next row.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTUDPR</name>
          <description>BIST User Data Pattern Register (BISTUDPR) on page 138</description>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUDP1</name>
              <description>BIST User Data Pattern 1: Data to be applied on odd DQ pins during BIST.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUDP0</name>
              <description>BIST User Data Pattern 0: Data to be applied on even DQ pins during BIST.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTGSR</name>
          <description>BIST General Status Register (BISTGSR) on page 139</description>
          <addressOffset>0x128</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CASBER</name>
              <description>CAS Bit Error: Indicates the number of bit errors on CAS.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RASBER</name>
              <description>RAS Bit Error: Indicates the number of bit errors on RAS.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DMBER</name>
              <description>DM Bit Error: Indicates the number of bit errors on data mask (DM) bit. DMBER[1:0] are for even DQS cycles first DM beat, and DMBER[3:2] are for even DQS cycles second DM beat. Similarly, DMBER[5:4] are for odd DQS cycles first DM beat, and DMBER[7:6] are for odd DQS cycles second DM beat.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARBER</name>
              <description>PAR_IN Bit Error (DIMM Only): Indicates the number of bit errors on PAR_IN</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BDXERR</name>
              <description>BIST Data Error: indicates, if set, that there is a data comparison error in the byte lane.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BACERR</name>
              <description>BIST Address/Command Error: indicates, if set, that there is a data comparison error in the address/command lane.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BDONE</name>
              <description>BIST Done: Indicates, if set, that the BIST has finished executing. This bit is reset to zero when BIST is triggered.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTWER</name>
          <description>BIST Word Error Register (BISTWER) on page 139</description>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DXWER</name>
              <description>Byte Word Error: Indicates the number of word errors on the byte lane. An error on any bit of the data bus including the data mask bit increments the error count.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACWER</name>
              <description>Address/Command Word Error: Indicates the number of word errors on the address/command lane. An error on any bit of the address/command bus increments the error count.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTBER0</name>
          <description>BIST Bit Error Register 0-3 (BISTBER0-3)</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ABER</name>
              <description>Address Bit Error: Each group of two bits indicate the bit error count on each of the</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTBER1</name>
          <description>BIST Bit Error Register 0-3 (BISTBER0-3)</description>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ODTBER</name>
              <description>ODT Bit Error: Each group of two bits indicates the bit error count on each of the up to 4 ODT bits. [1:0] is the error count for ODT[0], [3:2] for ODT[1], and so on.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSBER</name>
              <description>CS# Bit Error: Each group of two bits indicate the bit error count on each of the up to 4 CS# bits. [1:0] is the error count for CS#[0], [3:2] for CS#[1], and so on.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CKEBER</name>
              <description>CKE Bit Error: Each group of two bits indicate the bit error count on each of the up to 4 CKE bits. [1:0] is the error count for CKE[0], [3:2] for CKE[1], and so on.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WEBER</name>
              <description>WE# Bit Error: Indicates the number of bit errors on WE#.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BABER</name>
              <description>Bank Address Bit Error: Each group of two bits indicate the bit error count on each of the up to 3 bank address bits. [1:0] is the error count for BA[0], [3:2] for BA[1], and so on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTBER2</name>
          <description>BIST Bit Error Register 0-3 (BISTBER0-3)</description>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DQBER0</name>
              <description>Data Bit Error: The error count for even DQS cycles. The first 16 bits indicate the error count for the first data beat (i.e. the data driven out on DQ[7:0] on the rising edge of DQS). The second 16 bits indicate the error on the second data beat (i.e. the error count of the data driven out on DQ[7:0] on the falling edge of DQS). For each of the 16-bit group, the first 2 bits are for DQ[0], the second for DQ[1], and so on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTBER3</name>
          <description>BIST Bit Error Register 0-3 (BISTBER0-3)</description>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DQBER1</name>
              <description>Data Bit Error: The error count for odd DQS cycles. The first 16 bits indicate the error count for the first data beat (i.e. the data driven out on DQ[7:0] on the rising edge of DQS). The second 16 bits indicate the error on the second data beat (i.e. the error count of the data driven out on DQ[7:0] on the falling edge of DQS). For each of the 16-bit group, the first 2 bits are for DQ[0], the second for DQ[1], and so on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTWCSR</name>
          <description>BIST Word Count Status Register (BISTWCSR) on page 141</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DXWCNT</name>
              <description>Byte Word Count: Indicates the number of words received from the byte lane.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACWCNT</name>
              <description>Address/Command Word Count: Indicates the number of words received from the address/command lane.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTFWR0</name>
          <description>BIST Fail Word Register 0-2 (BISTFWR0-2)</description>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ODTWEBS</name>
              <description>Bit status during a word error for each of the up to 4 ODT bits.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CSWEBS</name>
              <description>Bit status during a word error for each of the up to 4 CS# bits.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CKEWEBS</name>
              <description>Bit status during a word error for each of the up to 4 CKE bits.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WEWEBS</name>
              <description>Bit status during a word error for the WE#.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BAWEBS</name>
              <description>Bit status during a word error for each of the up to 3 bank address bits.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>AWEBS</name>
              <description>Bit status during a word error for each of the up to 16 address bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTFWR1</name>
          <description>BIST Fail Word Register 0-2 (BISTFWR0-2)</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMWEBS</name>
              <description>Bit status during a word error for the data mask (DM) bit. DMWEBS [0] is for the first DM beat, DMWEBS [1] is for the second DM beat, and so on.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARWEBS</name>
              <description>Bit status during a word error for the PAR_IN. Only for DIMM parity support</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CASWEBS</name>
              <description>Bit status during a word error for the CAS.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RASWEBS</name>
              <description>Bit status during a word error for the RAS.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BISTFWR2</name>
          <description>BIST Fail Word Register 0-2 (BISTFWR0-2)</description>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DQWEBS</name>
              <description>Bit status during a word error for each of the 8 data (DQ) bits. The first 8 bits indicate the status of the first data beat (i.e. the status of the data driven out on DQ[7:0] on the rising edge of DQS). The second 8 bits indicate the status of the second data beat (i.e. the status of the data driven out on DQ[7:0] on the falling edge of DQS), and so on. For each of the 8-bit group, the first bit is for DQ[0], the second bit is for DQ[1], and so on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AACR</name>
          <description>Anti-Aging Control Register (AACR) on page 143</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AAOENC</name>
              <description>Anti-Aging PAD Output Enable Control: Enables, if set, anti-aging toggling on the pad output enable signal ctl_oe_n going into the DATX8s. This will increase power consumption for the anti-aging feature.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AAENC</name>
              <description>Anti-Aging Enable Control: Enables, if set, the automatic toggling of the data going to the DATX8 when the data channel from the controller/PUB to DATX8 is idle for programmable number of clock cycles.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AATR</name>
              <description>Anti-Aging Toggle Rate: Defines the number of controller clock (ctl_clk) cycles after which the PUB will toggle the data going to DATX8 if the data channel between the controller/PUB and DATX8 has been idle for this long.
The default value correspond to a toggling count of 4096 ctl_clk cycles. For a ctl_clk running at 533MHz the toggle rate will be approximately 7.68us.
The default value may also be overridden by the macro DWC_AACR_AATR_DFLT.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>30</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR0</name>
          <description>General Purpose Register 0-1 (GPR0-1)</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR0</name>
              <description>General Purpose Register 0: General purpose register bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPR1</name>
          <description>General Purpose Register 0-1 (GPR0-1)</description>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPR1</name>
              <description>General Purpose Register 1: General purpose register bits.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>0,1,2,3</dimIndex>
          <name>ZQ[%s]</name>
          <description>no description available</description>
          <addressOffset>0x180</addressOffset>
          <register>
            <name>CR0</name>
            <description>Impedance Control Register 0-1 (ZQnCR0-1)</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ZQPD</name>
                <description>ZQ Power Down: Powers down, if set, the PZQ cell.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ZCALEN</name>
                <description>Impedance Calibration Enable: Enables, if set, the impedance calibration of this ZQ control block when impedance calibration is triggered using either the ZCAL bit of PIR register or the DFI update interface.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ZCALBYP</name>
                <description>Impedance Calibration Bypass: Bypasses, if set, impedance calibration of this ZQ control block when impedance calibration is already in progress. Impedance calibration can be disabled prior to trigger by using the ZCALEN bit.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ZDEN</name>
                <description>Impedance Over-ride Enable: When this bit is set, it allows users to directly drive the impedance control using the data programmed in the ZDATA field. Otherwise, the control is generated automatically by the impedance control logic.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ZDATA</name>
                <description>Impedance Over-Ride Data: Data used to directly drive the impedance control.
ZDATA field mapping for D3F I/Os is as follows:
ZDATA[27:21] is used to select the pull-up on-die termination impedance ZDATA[20:14] is used to select the pull-down on-die termination impedance ZDATA[13:7] is used to select the pull-up output impedance
ZDATA[6:0] is used to select the pull-down output impedance
ZDATA field mapping for D3A/B/R I/Os is as follows: ZDATA[27:20] is reserved and returns zeros on reads
ZDATA[19:15] is used to select the pull-up on-die termination impedance ZDATA[14:10] is used to select the pull-down on-die termination impedance ZDATA[9:5] is used to select the pull-up output impedance
ZDATA[4:0] is used to select the pull-down output impedance
The default value is 0x000014A for I/O type D3C/R and 0x0001830 for I/O type D3F.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR1</name>
            <description>Impedance Control Register 0-1 (ZQnCR0-1)</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DFIPU1</name>
                <description>DFI Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 1 (channel 1) requests an update. Only valid in shared-AC mode.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFIPU0</name>
                <description>DFI Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 0 (channel 0) requests an update.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFICCU</name>
                <description>DFI Concurrent Controller Update Interface: Sets this impedance controller to be enabled for calibration when both of the DFI controller update interfaces request an update on the same clock. This provides the ability to enable impedance calibration updates for the Address/Command lane. Only valid in shared-AC mode.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFICU1</name>
                <description>DFI Controller Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 1 (channel 1) requests an update. Only valid in shared-AC mode.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DFICU0</name>
                <description>DFI Controller Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 0 (channel 0) requests an update.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ZPROG</name>
                <description>Impedance Divide Ratio: Selects the external resistor divide ratio to be used to set the output impedance and the on-die termination as follows:
ZPROG[7:4] = On-die termination divide select ZPROG[3:0] = Output impedance divide select</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SR0</name>
            <description>Impedance Status Register 0-1 (ZQnSR0-1)</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ZDONE</name>
                <description>Impedance Calibration Done: Indicates that impedance calibration has completed.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ZERR</name>
                <description>Impedance Calibration Error: If set, indicates that there was an error during impedance calibration.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ZCTRL</name>
                <description>Impedance Control: Current value of impedance control. ZCTRL field mapping for D3F I/Os is as follows:
ZCTRL[27:21] is used to select the pull-up on-die termination impedance ZCTRL[20:14] is used to select the pull-down on-die termination impedance ZCTRL[13:7] is used to select the pull-up output impedance
ZCTRL[6:0] is used to select the pull-down output impedance
ZCTRL field mapping for D3A/B/R I/Os is as follows: ZCTRL[27:20] is reserved and returns zeros on reads
ZCTRL[19:15] is used to select the pull-up on-die termination impedance ZCTRL[14:10] is used to select the pull-down on-die termination impedance ZCTRL[9:5] is used to select the pull-up output impedance
ZCTRL[4:0] is used to select the pull-down output impedance
Note: The default value is 0x000014A for I/O type D3C/D3R and 0x0001839 for I/O type D3F.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>28</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SR1</name>
            <description>Impedance Status Register 0-1 (ZQnSR0-1)</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>OPU</name>
                <description>On-die termination (ODT) pull-up calibration status. Similar status encodings as ZPD.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>OPD</name>
                <description>On-die termination (ODT) pull-down calibration status. Similar status encodings as ZPD.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ZPU</name>
                <description>Output impedance pull-up calibration status. Similar status encodings as ZPD.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ZPD</name>
                <description>Output impedance pull-down calibration status. Valid status encodings are: 00 = Completed with no errors
01 = Overflow error 10 = Underflow error
11 = Calibration in progress</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>9</dim>
          <dimIncrement>0x40</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7,8</dimIndex>
          <name>DX[%s]</name>
          <description>no description available</description>
          <addressOffset>0x1c0</addressOffset>
          <register>
            <name>GCR</name>
            <description>DATX8 General Configuration Register (DXnGCR) on page 148</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CALBYP</name>
                <description>Calibration Bypass: Prevents, if set, period measurement calibration from automatically triggering after PHY initialization.</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MDLEN</name>
                <description>Master Delay Line Enable: Enables, if set, the DATX8 master delay line calibration to perform subsequent period measurements following the initial period measurements that are performed after reset or when calibration is manually triggered. These additional measurements are accumulated and filtered as long as this bit remains high. This bit is ANDed with the common DATX8 MDL enable bit.</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WLRKEN</name>
                <description>Write Level Rank Enable: Specifies the ranks that should be write leveled for this byte. Write leveling responses from ranks that are not enabled for write leveling for a particular byte are ignored and write leveling is flagged as done for these ranks.
WLRKEN[0] enables rank 0, [1] enables rank 1, [2] enables rank 2, and [3] enables
rank 3.</description>
                <bitOffset>26</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PLLBYP</name>
                <description>PLL Bypass: Puts the byte PLL in bypass mode by driving the PLL bypass pin. This bit is not self-clearing and a '0' must be written to de-assert the bypass. This bit is ORed with the global BYP configuration bit (see Table 3-10 on page 91).</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>GSHIFT</name>
                <description>Gear Shift: Enables, if set, rapid locking mode on the byte PLL. This bit is ORed with the global GSHIFT configuration bit (see Table 3-10 on page 91).</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PLLPD</name>
                <description>PLL Power Down: Puts the byte PLL in power down mode by driving the PLL power down pin. This bit is not self-clearing and a '0' must be written to de-assert the power-down. This bit is ORed with the global PLLPD configuration bit (see
Table 3-10 on page 91).</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>PLLRST</name>
                <description>PLL Rest: Resets the byte PLL by driving the PLL reset pin. This bit is not self- clearing and a '0' must be written to de-assert the reset. This bit is ORed with the global PLLRST configuration bit (see Table 3-10 on page 91).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DXOEO</name>
                <description>Data Byte Output Enable Override: Specifies whether the output I/O output enable for the byte lane should be set to a fixed value. Valid values are:
00 = No override. Output enable is controlled by DFI transactions 01 = output enable is asserted (I/O is forced to output mode).
10 = Output enable is de-asserted (I/O is forced to input mode) 11 = Reserved</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTTOAL</name>
                <description>RTT On Additive Latency: Indicates when the ODT control of DQ/DQS SSTL I/Os is set to the value in DQODT/DQSODT during read cycles. Valid values are:
0 = ODT control is set to DQSODT/DQODT almost two cycles before read data preamble
1 = ODT control is set to DQSODT/DQODT almost one cycle before read data preamble</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTTOH</name>
                <description>RTT Output Hold: Indicates the number of clock cycles (from 0 to 3) after the read data postamble for which ODT control should remain set to DQSODT for DQS or DQODT for DQ/DM before disabling it (setting it to 0) when using dynamic ODT control. ODT is disabled almost RTTOH clock cycles after the read postamble.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQRTT</name>
                <description>DQ Dynamic RTT Control: If set, the on die termination (ODT) control of the DQ/DM SSTL I/O is dynamically generated to enable the ODT during read operation and disabled otherwise. By setting this bit to '0' the dynamic ODT feature is disabled. To control ODT statically this bit must be set to '0' and DXnGCR0[2] (DQODT) is used to enable ODT (when set to '1') or disable ODT(when set to '0').</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQSRTT</name>
                <description>DQS Dynamic RTT Control: If set, the on die termination (ODT) control of the DQS/DQS# SSTL I/O is dynamically generated to enable the ODT during read operation and disabled otherwise. By setting this bit to '0' the dynamic ODT feature is disabled. To control ODT statically this bit must be set to '0' and DXnGCR0[1] (DQSODT) is used to enable ODT (when set to '1') or disable ODT(when set to '0').</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSEN</name>
                <description>Write DQS Enable: Controls whether the write DQS going to the SDRAM is enabled (toggling) or disabled (static value) and whether the DQS is inverted. DQS# is always the inversion of DQS. These values are valid only when DQS/DQS# output enable is on, otherwise the DQS/DQS# is tristated. Valid settings are:
00 = Reserved
01 = DQS toggling with normal polarity (This should be the default setting) 10 = Reserved
11 = Reserved</description>
                <bitOffset>7</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQSRPD</name>
                <description>DQSR Power Down: Powers down, if set, the PDQSR cell. This bit is ORed with the common PDR configuration bit (see DATX8 Common Configuration Register (DXCCR) on page 99)</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DXPDR</name>
                <description>Data Power Down Receiver: Powers down, when set, the input receiver on I/O for DQ, DM, and DQS/DQS# pins of the byte. This bit is ORed with the common PDR configuration bit (see DATX8 Common Configuration Register (DXCCR) on page 99).</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DXPDD1</name>
                <description>Data Power Down Driver: Powers down, when set, the output driver on I/O for DQ, DM, and DQS/DQS# pins of the byte. This bit is ORed with the common PDD configuration bit (see DATX8 Common Configuration Register (DXCCR) on page 99).</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DXIOM</name>
                <description>Data I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DQ, DM, and DQS/DQS# pins of the byte. This bit is ORed with the IOM configuration bit of the individual DATX8(see DATX8 Common Configuration Register (DXCCR) on page 99).</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQODT</name>
                <description>Data On-Die Termination: Enables, when set, the on-die termination on the I/O for DQ and DM pins of the byte. This bit is ORed with the common DATX8 ODT configuration bit (see DATX8 Common Configuration Register (DXCCR) on page 99).
Note: This bit is only valid when DXnGCR0[10] is '0'.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQSODT</name>
                <description>DQS On-Die Termination: Enables, when set, the on-die termination on the I/O for DQS/DQS# pin of the byte. This bit is ORed with the common DATX8 ODT configuration bit (see DATX8 Common Configuration Register (DXCCR) on page 99).
Note: This bit is only valid when DXnGCR0[9] is '0'.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DXEN</name>
                <description>Data Byte Enable: Enables, if set, the data byte. Setting this bit to '0' disables the byte, i.e. the byte is not used in PHY initialization or training and is ignored during SDRAM read/write operations.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GSR0</name>
            <description>DATX8 General Status Registers 0-2 (DXnGSR0-2)</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WLDQ</name>
                <description>Write Leveling DQ Status: Captures the write leveling DQ status from the DRAM during software write leveling.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>QSGERR</name>
                <description>DQS Gate Training Error: Indicates, if set, that there is an error in DQS gate training. One bit for each of the up to 4 ranks.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>GDQSPRD</name>
                <description>Read DQS gating Period: Returns the DDR clock period measured by the read DQS gating LCDL during calibration. This value is PVT compensated.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DPLOCK</name>
                <description>DATX8 PLL Lock: Indicates, if set, that the DATX8 PLL has locked. This is a direct status of the DATX8 PLL lock pin.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WLPRD</name>
                <description>Write Leveling Period: Returns the DDR clock period measured by the write leveling LCDL during calibration. The measured period is used to generate the control of the write leveling pipeline which is a function of the write-leveling delay and the clock period. This value is PVT compensated.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WLERR</name>
                <description>Write Leveling Error: Indicates, if set, that there is a write leveling error in the DATX8.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WLDONE</name>
                <description>Write Leveling Done: Indicates, if set, that the DATX8 has completed write leveling.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WLCAL</name>
                <description>Write Leveling Calibration: Indicates, if set, that the DATX8 has finished doing period measurement calibration for the write leveling slave delay line.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>GDQSCAL</name>
                <description>Read DQS gating Calibration: Indicates, if set, that the DATX8 has finished doing period measurement calibration for the read DQS gating LCDL.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RDQSNCAL</name>
                <description>Read DQS# Calibration (Type B/B1 PHY Only): Indicates, if set, that the DATX8 has finished doing period measurement calibration for the read DQS# LCDL.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>RDQSCAL</name>
                <description>Read DQS Calibration: Indicates, if set, that the DATX8 has finished doing period measurement calibration for the read DQS LCDL.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>WDQCAL</name>
                <description>Write DQ Calibration: Indicates, if set, that the DATX8 has finished doing period measurement calibration for the write DQ LCDL.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GSR1</name>
            <description>DATX8 General Status Registers 0-2 (DXnGSR0-2)</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DLTCODE</name>
                <description>Delay Line Test Code: Returns the code measured by the PHY control block that corresponds to the period of the DATX8 delay line digital test output.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>24</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>DLTDONE</name>
                <description>Delay Line Test Done: Indicates, if set, that the PHY control block has finished doing period measurement of the DATX8 delay line digital test output.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BDLR0</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0xc</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DQ4WBD</name>
                <description>DQ4 Write Bit Delay: Delay select for the BDL on DQ4 write path.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ3WBD</name>
                <description>DQ3 Write Bit Delay: Delay select for the BDL on DQ3 write path</description>
                <bitOffset>18</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ2WBD</name>
                <description>DQ2 Write Bit Delay: Delay select for the BDL on DQ2 write path.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ1WBD</name>
                <description>DQ1 Write Bit Delay: Delay select for the BDL on DQ1 write path.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ0WBD</name>
                <description>DQ0 Write Bit Delay: Delay select for the BDL on DQ0 write path.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BDLR1</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSWBD</name>
                <description>DQS Write Bit Delay: Delay select for the BDL on DQS write path</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DMWBD</name>
                <description>DM Write Bit Delay: Delay select for the BDL on DM write path.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ7WBD</name>
                <description>DQ7 Write Bit Delay: Delay select for the BDL on DQ7 write path.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ6WBD</name>
                <description>DQ6 Write Bit Delay: Delay select for the BDL on DQ6 write path.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ5WBD</name>
                <description>DQ5 Write Bit Delay: Delay select for the BDL on DQ5 write path.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BDLR2</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DSNRBD</name>
                <description>DQSN Read Bit Delay (Type B/B1 PHY Only): Delay select for the BDL on DQSN read path</description>
                <bitOffset>18</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSRBD</name>
                <description>DQS Read Bit Delay: Delay select for the BDL on DQS read path</description>
                <bitOffset>12</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQOEBD</name>
                <description>DQ Output Enable Bit Delay: Delay select for the BDL on DQ/DM output enable path.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DSOEBD</name>
                <description>DQS Output Enable Bit Delay: Delay select for the BDL on DQS output enable path</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BDLR3</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DQ4RBD</name>
                <description>DQ4 Read Bit Delay: Delay select for the BDL on DQ4 read path.</description>
                <bitOffset>24</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ3RBD</name>
                <description>DQ3 Read Bit Delay: Delay select for the BDL on DQ3 read path</description>
                <bitOffset>18</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ2RBD</name>
                <description>DQ2 Read Bit Delay: Delay select for the BDL on DQ2 read path.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ1RBD</name>
                <description>DQ1 Read Bit Delay: Delay select for the BDL on DQ1 read path.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ0RBD</name>
                <description>DQ0 Read Bit Delay: Delay select for the BDL on DQ0 read path.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BDLR4</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x1c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DMRBD</name>
                <description>DM Read Bit Delay: Delay select for the BDL on DM read path.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ7RBD</name>
                <description>DQ7 Read Bit Delay: Delay select for the BDL on DQ7 read path.</description>
                <bitOffset>12</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ6RBD</name>
                <description>DQ6 Read Bit Delay: Delay select for the BDL on DQ6 read path.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DQ5RBD</name>
                <description>DQ5 Read Bit Delay: Delay select for the BDL on DQ5 read path.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>6</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LCDLR0</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>R3WLD</name>
                <description>Rank 3 Write Leveling Delay: Rank 3 delay select for the write leveling (WL) LCDL</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R2WLD</name>
                <description>Rank 2 Write Leveling Delay: Rank 2 delay select for the write leveling (WL) LCDL</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R1WLD</name>
                <description>Rank 1 Write Leveling Delay: Rank 1 delay select for the write leveling (WL) LCDL</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R0WLD</name>
                <description>Rank 0 Write Leveling Delay: Rank 0 delay select for the write leveling (WL) LCDL</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LCDLR1</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RDQSND</name>
                <description>Read DQSN Delay (Type B/B1 PHY Only): Delay select for the read DQSN (RDQS) LCDL</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RDQSD</name>
                <description>Read DQS Delay: Delay select for the read DQS (RDQS) LCDL</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDQD</name>
                <description>Write Data Delay: Delay select for the write data (WDQ) LCDL</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LCDLR2</name>
            <description>DATX8 Bit Delay Line Register 0-4 (DXnBDLR0-4)</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>R3DQSGD</name>
                <description>Rank 3 Read DQS Gating Delay: Rank 3 delay select for the read DQS gating (DQSG) LCDL</description>
                <bitOffset>24</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R2DQSGD</name>
                <description>Rank 2 Read DQS Gating Delay: Rank 2 delay select for the read DQS gating (DQSG) LCDL</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R1DQSGD</name>
                <description>Rank 1 Read DQS Gating Delay: Rank 1 delay select for the read DQS gating (DQSG) LCDL</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R0DQSGD</name>
                <description>Rank 0 Read DQS Gating Delay: Rank 0 delay select for the read DQS gating (DQSG) LCDL</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MDLR</name>
            <description>DATX8 Master Delay Line Register (DXnMDLR) on page 157</description>
            <addressOffset>0x2c</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MDLD</name>
                <description>MDL Delay: Delay select for the LCDL for the Master Delay Line.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>TPRD</name>
                <description>Target Period: Target period measured by the master delay line calibration for VT drift compensation. This is the current measured value of the period and is continuously updated if the MDL is enabled to do so.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>IPRD</name>
                <description>Initial Period: Initial period measured by the master delay line calibration for VT drift compensation. This value is used as the denominator when calculating the ratios of updates during VT compensation.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>8</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GTR</name>
            <description>DATX8 General Timing Register (DXnGTR) on page 159</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x000FFFFF</resetMask>
            <fields>
              <field>
                <name>R3WLSL</name>
                <description>No description available</description>
                <bitOffset>18</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R2WLSL</name>
                <description>No description available</description>
                <bitOffset>16</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R1WLSL</name>
                <description>No description available</description>
                <bitOffset>14</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R0WLSL</name>
                <description>Rank n Write Leveling System Latency: This is used to adjust the write latency after write leveling. Power-up default is 01 (i.e. no extra clock cycles required). The SL fields are initially set by the PUB during automatic write leveling but these values can be overwritten by a direct write to this register. Every two bits of this register control the latency of each of the (up to) four ranks. R0WLSL controls the latency of rank 0, R1WLSL controls rank 1, and so on. Valid values:
00 = Write latency = WL - 1 01 = Write latency = WL
10 = Write latency = WL + 1 11 = Reserved</description>
                <bitOffset>12</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R3DGSL</name>
                <description>No description available</description>
                <bitOffset>9</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R2DGSL</name>
                <description>No description available</description>
                <bitOffset>6</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R1DGSL</name>
                <description>No description available</description>
                <bitOffset>3</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>R0DGSL</name>
                <description>Rank n DQS Gating System Latency: This is used to increase the number of clock cycles needed to expect valid DDR read data by up to seven extra clock cycles.
This is used to compensate for board delays and other system delays. Power-up default is 000 (i.e. no extra clock cycles required). The SL fields are initially set by the PUB during automatic DQS data training but these values can be overwritten by a direct write to this register. Every three bits of this register control the latency of each of the (up to) four ranks. R0DGSL controls the latency of rank 0, R1DGSL controls rank 1, and so on. Valid values are 0 to 7:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GSR2</name>
            <description>DATX8 General Status Register 2 (DXnGSR2) on page 152</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ESTAT</name>
                <description>Error Status: If an error occurred for this lane as indicated by RDERR, WDERR, REERR or WEERR the error status code can provide additional information regard when the error occurred during the algorithm execution.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WEWN</name>
                <description>Write Data Eye Training Warning: Indicates, if set, that the DATX8 has encountered a warning during execution of the write data eye training.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WEERR</name>
                <description>Write Data Eye Training Error: Indicates, if set, that the DATX8 has encountered an error during execution of the write data eye training.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REWN</name>
                <description>Read Data Eye Training Warning: Indicates, if set, that the DATX8 has encountered a warning during execution of the read data eye training.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>REERR</name>
                <description>Read Data Eye Training Error: Indicates, if set, that the DATX8 has encountered an error during execution of the read data eye training.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDWN</name>
                <description>Write Bit Deskew Warning: Indicates, if set, that the DATX8 has encountered a warning during execution of the write bit deskew training.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>WDERR</name>
                <description>Write Bit Deskew Error: Indicates, if set, that the DATX8 has encountered an error during execution of the write bit deskew training.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RDWN</name>
                <description>Read Bit Deskew Warning: Indicates, if set, that the DATX8 has encountered a warning during execution of the read bit deskew training.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RDERR</name>
                <description>Read Bit Deskew Error: Indicates, if set, that the DATX8 has encountered an error during execution of the read bit deskew training.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSNS</name>
      <description>TSNS</description>
      <groupName>TSNS</groupName>
      <baseAddress>0xf4154000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>T</name>
          <description>Temperature</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Signed number of temperature in 256 x celsius degree</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TMAX</name>
          <description>Maximum Temperature</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0xFF800000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>maximum temperature ever found</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TMIN</name>
          <description>Minimum Temperature</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x007FFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>minimum temperature ever found</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AGE</name>
          <description>Sample age</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AGE</name>
              <description>age of T register in 24MHz clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>indicate value in T is valid or not
0: not valid
1:valid</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TRIGGER</name>
              <description>Software trigger for sensing in trigger mode, trigger will be ignored if in sensing or other mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>Configuration</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00600300</resetValue>
          <resetMask>0xC3FF0713</resetMask>
          <fields>
            <field>
              <name>IRQ_EN</name>
              <description>Enable interrupt</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RST_EN</name>
              <description>Enable reset</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_MIN_EN</name>
              <description>Enable compare for minimum temperature</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COMPARE_MAX_EN</name>
              <description>Enable compare for maximum temperature</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPEED</name>
              <description>cycles of a progressive step in 24M clock, valid from 24-255, default 96
24: 24 cycle for a step
25: 25 cycle for a step
26: 26 cycle for a step
...
255: 255 cycle for a step</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AVERAGE</name>
              <description>Average time, default in 3
0: measure and return
1: twice and average
2: 4 times and average
. . .
7: 128 times and average</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>continuous mode that keep sampling temperature peridically
0: trigger mode
1: continuous mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ASYNC</name>
              <description>Acynchronous mode, this mode can work without clock, only available function ios compare to certain ADC value
0: active mode
1: Async mode</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable temperature
0: disable, temperature sensor is shut down
1: enable. Temperature sensor enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VALIDITY</name>
          <description>Sample validity</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x016E3600</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALIDITY</name>
              <description>time for temperature values to expire in 24M clock cycles</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLAG</name>
          <description>Temperature flag</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00330001</resetMask>
          <fields>
            <field>
              <name>RECORD_MIN_CLR</name>
              <description>Clear minimum recorder of temerature, write 1 to clear</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RECORD_MAX_CLR</name>
              <description>Clear maximum recorder of temerature, write 1 to clear</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDER_TEMP</name>
              <description>Clear under temperature status, write 1 to clear</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP</name>
              <description>Clear over temperature status, write 1 to clear</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ</name>
              <description>IRQ flag, write 1 to clear</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_LIM_IRQ</name>
          <description>Maximum temperature to interrupt</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Maximum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOWER_LIM_IRQ</name>
          <description>Minimum temperature to interrupt</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Minimum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPPER_LIM_RST</name>
          <description>Maximum temperature to reset</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Maximum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LOWER_LIM_RST</name>
          <description>Minimum temperature to reset</description>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>T</name>
              <description>Minimum temperature for compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ASYNC</name>
          <description>Configuration in asynchronous mode</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x010107FF</resetMask>
          <fields>
            <field>
              <name>ASYNC_TYPE</name>
              <description>Compare hotter than or colder than in asynchoronous mode
0: hotter than
1: colder than</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Polarity of internal comparator</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALUE</name>
              <description>Value of async mode to compare</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADVAN</name>
          <description>Advance configuration</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x03010003</resetMask>
          <fields>
            <field>
              <name>ASYNC_IRQ</name>
              <description>interrupt status of asynchronous mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE_IRQ</name>
              <description>interrupt status of active mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SAMPLING</name>
              <description>temperature sampling is working</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>NEG_ONLY</name>
              <description>use negative compare polarity only</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_ONLY</name>
              <description>use positive compare polarity only</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACC</name>
      <description>BACC</description>
      <groupName>BACC</groupName>
      <baseAddress>0xf4200000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Access timing for access</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x3000FFFF</resetMask>
          <fields>
            <field>
              <name>FAST_WRITE</name>
              <description>Use fast write
0: Write normally
1: boost write</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_READ</name>
              <description>Use fast read
0: Read normally
1: boost read</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMING</name>
              <description>Time in APB clock cycles, for battery timing penerate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRE_TIME</name>
          <description>Timing gap before rising edge</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>PRE_RATIO</name>
              <description>Ratio of guard band before rising edge
0: 0
1: 1/32768 of low level width
2: 1/16384 of low level width
14: 1/4 of low level width
15: 1/2 of low level width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRE_OFFSET</name>
              <description>guard band before rising edge
this value will be added to ratio number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POST_TIME</name>
          <description>Timing gap after rising edge</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000FFFFF</resetMask>
          <fields>
            <field>
              <name>POST_RATIO</name>
              <description>Ratio of guard band after rising edge
0: 0
1: 1/32768 of high level width
2: 1/16384 of high level width
14: 1/4 of high level width
15: 1/2 of high level width</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POST_OFFSET</name>
              <description>guard band after rising edge
this value will be added to ratio number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BPOR</name>
      <description>BPOR</description>
      <groupName>BPOR</groupName>
      <baseAddress>0xf4204000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>POR_CONFIG</name>
          <description>Power on reset config</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>RETENTION</name>
              <description>retention battery domain setting
0: battery reset on reset pin reset happen
1: battery domain retention when reset pin reset happen</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BCFG</name>
      <description>BCFG</description>
      <groupName>BCFG</groupName>
      <baseAddress>0xf4208000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VBG_CFG</name>
          <description>Bandgap config</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x811F1F1F</resetMask>
          <fields>
            <field>
              <name>VBG_TRIMMED</name>
              <description>Bandgap trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: bandgap is not trimmed
1: bandgap is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_SAVE</name>
              <description>Bandgap works in power save mode
0: not in power save mode
1: bandgap work in power save mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_1P0</name>
              <description>Bandgap 1.0V output trim</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P65</name>
              <description>Bandgap 0.65V output trim</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VBG_P50</name>
              <description>Bandgap 0.50V output trim</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRC32K_CFG</name>
          <description>On-chip 32k oscillator config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80C001FF</resetMask>
          <fields>
            <field>
              <name>IRC_TRIMMED</name>
              <description>IRC32K trim happened, this bit set by hardware after trim value loaded, and stop load, write 0 will clear this bit and reload trim value
0: irc is not trimmed
1: irc is trimmed</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX7_TRIM</name>
              <description>IRC32K bit 7</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPEX6_TRIM</name>
              <description>IRC32K bit 6</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CAP_TRIM</name>
              <description>capacitor trim bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>XTAL32K_CFG</name>
          <description>XTAL 32K config</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00001313</resetMask>
          <fields>
            <field>
              <name>HYST_EN</name>
              <description>crystal 32k hysteres enable</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GMSEL</name>
              <description>crystal 32k gm selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFG</name>
              <description>crystal 32k config</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>AMP</name>
              <description>crystal 32k amplifier</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CFG</name>
          <description>Clock config</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x10010010</resetMask>
          <fields>
            <field>
              <name>XTAL_SEL</name>
              <description>crystal selected</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>KEEP_IRC</name>
              <description>force irc32k run</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FORCE_XTAL</name>
              <description>force switch to crystal</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BUTN</name>
      <description>BUTN</description>
      <groupName>BUTN</groupName>
      <baseAddress>0xf420c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0xc</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BTN_STATUS</name>
          <description>Button status</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77770FFF</resetMask>
          <fields>
            <field>
              <name>XWCLICK</name>
              <description>wake button click status when power button held, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WCLICK</name>
              <description>wake button click status, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XPCLICK</name>
              <description>power button click status when wake button held, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLICK</name>
              <description>power button click status, write 1 to clear flag
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBTN</name>
              <description>Dual button press status, write 1 to clear flag
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WBTN</name>
              <description>Wake button press status, write 1 to clear flag
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBTN</name>
              <description>Power button press status, write 1 to clear flag
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BTN_IRQ_MASK</name>
          <description>Button interrupt mask</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x77770FFF</resetMask>
          <fields>
            <field>
              <name>XWCLICK</name>
              <description>wake button click status when power button held interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WCLICK</name>
              <description>wake button click interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>XPCLICK</name>
              <description>power button click status when wake button held interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PCLICK</name>
              <description>power button click interrupt enable
bit0: clicked
bit1: double clicked
bit2: tripple clicked</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBTN</name>
              <description>Dual button press interrupt enable
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WBTN</name>
              <description>Wake button press interrupt enable
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PBTN</name>
              <description>Power button press interrupt enable
bit0: button pressed
bit1: button confirmd
bit2: button long pressed
bit3: button long long pressed</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LED_INTENSE</name>
          <description>Debounce setting</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x000F000F</resetMask>
          <fields>
            <field>
              <name>RLED</name>
              <description>Rbutton brightness 0</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PLED</name>
              <description>Pbutton brightness 0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BGPR</name>
      <description>BGPR</description>
      <groupName>BGPR</groupName>
      <baseAddress>0xf4218000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <dim>8</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
          <name>GPR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Generic control</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTCSHW</name>
      <description>RTCSHW</description>
      <groupName>RTC</groupName>
      <baseAddress>0xf421c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECOND</name>
          <description>Second counter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SECOND</name>
              <description>second counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUBSEC</name>
          <description>Sub-second counter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBSEC</name>
              <description>sub second counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEC_SNAP</name>
          <description>Second counter snap shot</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SEC_SNAP</name>
              <description>second snap shot, write to take snap shot</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SUB_SNAP</name>
          <description>Sub-second counter snap shot</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUB_SNAP</name>
              <description>sub second snap shot, write to take snap shot</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM0</name>
          <description>RTC alarm0</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALARM</name>
              <description>Alarm time for second counter, on each alarm match, alarm increase ALARM0_INC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM0_INC</name>
          <description>Alarm0 incremental</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREASE</name>
              <description>adder when ARLAM0 happen, helps to create periodical alarm</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM1</name>
          <description>RTC alarm1</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ALARM</name>
              <description>Alarm time for second counter, on each alarm match, alarm increase ALARM0_INC</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM1_INC</name>
          <description>Alarm1 incremental</description>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INCREASE</name>
              <description>adder when ARLAM0 happen, helps to create periodical alarm</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_FLAG</name>
          <description>RTC alarm flag</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>alarm1 happen</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM0</name>
              <description>alarm0 happen</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALARM_EN</name>
          <description>RTC alarm enable</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000003</resetMask>
          <fields>
            <field>
              <name>ENABLE1</name>
              <description>alarm1 mask
0: alarm1 disabled
1: alarm1 enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE0</name>
              <description>alarm0 mask
0: alarm0 disabled
1: alarm0 enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="RTCSHW">
      <name>RTC</name>
      <description>RTC</description>
      <groupName>RTC</groupName>
      <baseAddress>0xf4244000</baseAddress>
    </peripheral>
    <peripheral>
      <name>BSEC</name>
      <description>BSEC</description>
      <groupName>BSEC</groupName>
      <baseAddress>0xf4240000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SECURE_STATE</name>
          <description>Secure state</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0003000F</resetMask>
          <fields>
            <field>
              <name>ALLOW_NSC</name>
              <description>Non-secure state allow
0: system is not healthy to enter non-secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter non-secure state</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ALLOW_SEC</name>
              <description>Secure state allow
0: system is not healthy to enter secure state, request to enter non-secure state will cause a fail state
1: system is healthy to enter secure state</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_FAIL</name>
              <description>BATT secure state one hot indicator
0: secure state is not in fail state
1: secure state is in fail state</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_NSC</name>
              <description>BATT secure state one hot indicator
0: secure state is not in non-secure state
1: secure state is in non-secure state</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_SEC</name>
              <description>BATT secure state one hot indicator
0: secure state is not in secure state
1: secure state is in secure state</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BATT_INS</name>
              <description>BATT secure state one hot indicator
0: secure state is not in inspect state
1: secure state is in inspect state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SECURE_STATE_CONFIG</name>
          <description>secure state configuration</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000009</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>Lock bit of allow restart setting, once locked, lock bit itself and configuration register will keep value until next reset
0: not locked, register can be modified
1: register locked, write access to the register is ignored</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ALLOW_RESTART</name>
              <description>allow secure state restart from fail state
0: restart is not allowed, only hardware reset can recover secure state
1: software is allowed to switch to inspect state from fail state</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VIOLATION_CONFIG</name>
          <description>Security violation config</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure violation setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state violations, each bit represents one security event
0: event is not a security violation
1: event is a security violation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ESCALATE_CONFIG</name>
          <description>Escalate behavior on security event</description>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOCK_NSC</name>
              <description>Lock bit non-secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified
1: register locked, write access to the configuration is ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NSC_VIO_CFG</name>
              <description>configuration of non-secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_SEC</name>
              <description>Lock bit secure escalate setting, once locked, lock bit itself and configuration will keep value until next reset
0: not locked, configuration can be modified1: register locked, write access to the configuration is ignored</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEC_VIO_CFG</name>
              <description>configuration of secure state escalates, each bit represents one security event
0: event is not a security escalate
1: event is a security escalate</description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EVENT</name>
          <description>Event and escalate status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>EVENT</name>
              <description>local event statue, each bit represents one security event</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_ESC_NSC</name>
              <description>BATT is escalating non-secure event</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BATT_ESC_SEC</name>
              <description>BATT is escalting ssecure event</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BKEY</name>
      <description>BKEY</description>
      <groupName>BKEY</groupName>
      <baseAddress>0xf4248000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x4c</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x20</dimIncrement>
          <dimIndex>0,1</dimIndex>
          <name>KEY[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>0x4</dimIncrement>
            <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
            <name>DATA[%s]</name>
            <description>no description available</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>security key data</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>2</dim>
          <dimIncrement>0x4</dimIncrement>
          <dimIndex>KEY0,KEY1</dimIndex>
          <name>ECC[%s]</name>
          <description>no description available</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>WLOCK</name>
              <description>write lock to key0
0: write enable
1: write ignored</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RLOCK</name>
              <description>read lock to key0
0: key read enable
1: key always read as 0</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC</name>
              <description>Parity check bits for key0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SELECT</name>
          <description>Key selection</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000001</resetMask>
          <fields>
            <field>
              <name>SELECT</name>
              <description>select key, key0 treated as secure key, in non-scure mode, only key1 can be selected
0: select key0 in secure mode, key1 in non-secure mode
1: select key1 in secure or nonsecure mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BMON</name>
      <description>BMON</description>
      <groupName>BMON</groupName>
      <baseAddress>0xf424c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>glitch0,clock0</dimIndex>
          <name>MONITOR[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Glitch and clock monitor control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000011</resetMask>
            <fields>
              <field>
                <name>ACTIVE</name>
                <description>select glitch works in active mode or passve mode.
0: passive mode, depends on power glitch destroy DFF value
1: active mode, check glitch by DFF chain</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable glitch detector
0: detector disabled
1: detector enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Glitch and clock monitor status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x00000001</resetMask>
            <fields>
              <field>
                <name>FLAG</name>
                <description>flag for glitch detected, write 1 to clear this flag
0: glitch not detected
1: glitch detected</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TAMP</name>
      <description>TAMP</description>
      <groupName>TAMP</groupName>
      <baseAddress>0xf4250000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x88</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>4</dim>
          <dimIncrement>0x10</dimIncrement>
          <dimIndex>tamp0,tamp1,tamp2,tamp3</dimIndex>
          <name>TAMP[%s]</name>
          <description>no description available</description>
          <addressOffset>0x0</addressOffset>
          <register>
            <name>CONTROL</name>
            <description>Tamper n control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0x801F03F7</resetMask>
            <fields>
              <field>
                <name>LOCK</name>
                <description>lock tamper setting
0: tamper setting can be changed
1: tamper setting will last to next battery domain power cycle</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS</name>
                <description>bypass tamper violation filter
0: filter applied
1: filter not used</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER</name>
                <description>filter length
0: 1 cycle
1: 2 cycle
15: 65526 cycle</description>
                <bitOffset>16</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>VALUE</name>
                <description>pin value for passive tamper</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>SPEED</name>
                <description>tamper speed selection, (2^SPEED) changes per second
0: 1 shift per second
1: 2 shifts per second
. . .
15: 32768 shifts per second</description>
                <bitOffset>4</bitOffset>
                <bitWidth>4</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RECOVER</name>
                <description>tamper will recover itself if tamper LFSR goes wrong
0: tamper will not recover
1: tamper will recover</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE</name>
                <description>select active or passive tamper
0: passive tamper
1: active tamper</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>enable tamper
0: tamper disableed
1: tamper enabled</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>POLY</name>
            <description>Tamper n Polynomial of LFSR</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>POLY</name>
                <description>tamper LFSR polyminal, this is a write once register, once write content is locked, and readout value is "1"</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LFSR</name>
            <description>Tamper n LFSR shift register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <resetValue>0x00000000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LFSR</name>
                <description>LFSR for active tamper, write only register, always read 0</description>
                <bitOffset>0</bitOffset>
                <bitWidth>32</bitWidth>
                <access>write-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>TAMP_FLAG</name>
          <description>Tamper flag</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000FFF</resetMask>
          <fields>
            <field>
              <name>FLAG</name>
              <description>tamper flag, each bit represents one tamper pin, write 1 to clear the flag
Note, clear can only be cleared when tamper disappeared</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ_EN</name>
          <description>Tamper interrupt enable</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x80000FFF</resetMask>
          <fields>
            <field>
              <name>LOCK</name>
              <description>lock bit for IRQ enable
0: enable bits can be changed
1: enable bits hold until next battery domain power cycle</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQ_EN</name>
              <description>interrupt enable, each bit represents one tamper pin
0: interrupt disabled
1: interrupt enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MONO</name>
      <description>MONO</description>
      <groupName>MONO</groupName>
      <baseAddress>0xf4254000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MONOL</name>
          <description>Low part of monotonic counter</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>low part of monotonica counter, write to this counter will cause counter increase by 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONOH</name>
          <description>High part of monotonic counter</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EPOCH</name>
              <description>Fuse value for high part of monotonica</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER</name>
              <description>high part of monotonica counter, write to this counter will cause counter increase by 1 if low part overflow</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
