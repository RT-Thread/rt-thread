<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>psoc6_04</name>
  <series>PSoC6_04</series>
  <version>1.0</version>
  <description>PSoC6_04</description>
  <licenseText>(c) (2016-2021), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM4</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>1</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of clock cycles (clk_slow). If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB-Lite bus error and a fault is generated (and possibly recorded in the fault report structure(s)).
'0x0000'-'0xfffe': Number of clock cycles.
'0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated and a fault will never be generated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.
SW MUST NOT set ACTIVATE bit to '1' while updating the other register bits simultaneously. At first the SW MUST update the other register bits as needed, and then set ACTIVATE to '1' with a new register write.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF03FF</resetValue>
          <resetMask>0xC3FF03FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_DIV_SEL</name>
              <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_peri' is used as reference.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_TYPE_SEL</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_peri' (typical usage) or to ANY enabled divider.
 
The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_peri'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_peri' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLOCK_CTL[%s]</name>
          <description>Clock control</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control (for 8.0 divider)</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control (for 16.0 divider)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control (for 16.5 divider)</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>255</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control (for 24.5 divider)</description>
          <addressOffset>0x1C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFF0507FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for PERI protection structure SRAM.
When '1', the parity (PARITY) is used when a write is done to the WORD_ADDR word address of the SRAM.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>10</dim>
          <dimIncrement>32</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. 
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED_0</name>
                <description>Peripheral group, slave 0 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_1</name>
                <description>Peripheral group, slave 1 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect, master interface MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_8</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_9</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_10</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_11</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_12</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_13</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_14</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_15</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_0</name>
                <description>Peripheral group, slave 0 permanent disable. Setting this bit to 1 has the same effect as setting ENABLED_0 to 0.  However, once set to 1, this bit cannot be changed back to 0 anymore.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_8</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_9</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_10</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_11</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_12</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_13</name>
                <description>N/A</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_14</name>
                <description>N/A</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_15</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>12</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>9</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_MS</name>
      <description>Peripheral interconnect, master interface</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_PR[%s]</name>
          <description>Programmable protection structure pair</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>227</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_FX[%s]</name>
          <description>Fixed protection structure pair</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFC</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU subsystem (CPUSS)</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO Port Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO Port Interrupt #2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO Port Interrupt #3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_5</name>
        <description>GPIO Port Interrupt #5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_6</name>
        <description>GPIO Port Interrupt #6</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_7</name>
        <description>GPIO Port Interrupt #7</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_8</name>
        <description>GPIO Port Interrupt #8</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_9</name>
        <description>GPIO Port Interrupt #9</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_10</name>
        <description>GPIO Port Interrupt #10</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_11</name>
        <description>GPIO Port Interrupt #11</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_12</name>
        <description>GPIO Port Interrupt #12</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_14</name>
        <description>GPIO Port Interrupt #14</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_vdd</name>
        <description>GPIO Supply Detect Interrupt</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>Low Power Comparator Interrupt</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>scb_6_interrupt</name>
        <description>Serial Communication Block #6 (DeepSleep capable)</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_0</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_1</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_backup</name>
        <description>Backup domain interrupt</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt</name>
        <description>Other combined Interrupts for SRSS (LVD, WDT, CLKCAL)</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_0</name>
        <description>CPUSS Inter Process Communication Interrupt #0</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_1</name>
        <description>CPUSS Inter Process Communication Interrupt #1</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_2</name>
        <description>CPUSS Inter Process Communication Interrupt #2</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_3</name>
        <description>CPUSS Inter Process Communication Interrupt #3</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_4</name>
        <description>CPUSS Inter Process Communication Interrupt #4</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_5</name>
        <description>CPUSS Inter Process Communication Interrupt #5</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_6</name>
        <description>CPUSS Inter Process Communication Interrupt #6</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_7</name>
        <description>CPUSS Inter Process Communication Interrupt #7</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_8</name>
        <description>CPUSS Inter Process Communication Interrupt #8</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_9</name>
        <description>CPUSS Inter Process Communication Interrupt #9</description>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_10</name>
        <description>CPUSS Inter Process Communication Interrupt #10</description>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_11</name>
        <description>CPUSS Inter Process Communication Interrupt #11</description>
        <value>34</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_12</name>
        <description>CPUSS Inter Process Communication Interrupt #12</description>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_13</name>
        <description>CPUSS Inter Process Communication Interrupt #13</description>
        <value>36</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_14</name>
        <description>CPUSS Inter Process Communication Interrupt #14</description>
        <value>37</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_15</name>
        <description>CPUSS Inter Process Communication Interrupt #15</description>
        <value>38</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_0</name>
        <description>SAR ADC0 interrupt</description>
        <value>39</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar_1</name>
        <description>SAR ADC1 interrupt</description>
        <value>40</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_ctbs</name>
        <description>individual interrupt per CTB</description>
        <value>41</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_fifo_0</name>
        <description>PASS FIFO0</description>
        <value>43</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_fifo_1</name>
        <description>PASS FIFO1</description>
        <value>44</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>Serial Communication Block #0</description>
        <value>45</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>Serial Communication Block #1</description>
        <value>46</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>Serial Communication Block #2</description>
        <value>47</value>
      </interrupt>
      <interrupt>
        <name>scb_4_interrupt</name>
        <description>Serial Communication Block #4</description>
        <value>49</value>
      </interrupt>
      <interrupt>
        <name>scb_5_interrupt</name>
        <description>Serial Communication Block #5</description>
        <value>50</value>
      </interrupt>
      <interrupt>
        <name>csd_interrupt</name>
        <description>CSD (Capsense) interrupt</description>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_0</name>
        <description>CPUSS DMAC, Channel #0</description>
        <value>52</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_1</name>
        <description>CPUSS DMAC, Channel #1</description>
        <value>53</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_0</name>
        <description>CPUSS DataWire #0, Channel #0</description>
        <value>56</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_1</name>
        <description>CPUSS DataWire #0, Channel #1</description>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_2</name>
        <description>CPUSS DataWire #0, Channel #2</description>
        <value>58</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_3</name>
        <description>CPUSS DataWire #0, Channel #3</description>
        <value>59</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_4</name>
        <description>CPUSS DataWire #0, Channel #4</description>
        <value>60</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_5</name>
        <description>CPUSS DataWire #0, Channel #5</description>
        <value>61</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_6</name>
        <description>CPUSS DataWire #0, Channel #6</description>
        <value>62</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_7</name>
        <description>CPUSS DataWire #0, Channel #7</description>
        <value>63</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_8</name>
        <description>CPUSS DataWire #0, Channel #8</description>
        <value>64</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_9</name>
        <description>CPUSS DataWire #0, Channel #9</description>
        <value>65</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_10</name>
        <description>CPUSS DataWire #0, Channel #10</description>
        <value>66</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_11</name>
        <description>CPUSS DataWire #0, Channel #11</description>
        <value>67</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_12</name>
        <description>CPUSS DataWire #0, Channel #12</description>
        <value>68</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_13</name>
        <description>CPUSS DataWire #0, Channel #13</description>
        <value>69</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_14</name>
        <description>CPUSS DataWire #0, Channel #14</description>
        <value>70</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_15</name>
        <description>CPUSS DataWire #0, Channel #15</description>
        <value>71</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_16</name>
        <description>CPUSS DataWire #0, Channel #16</description>
        <value>72</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_17</name>
        <description>CPUSS DataWire #0, Channel #17</description>
        <value>73</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_18</name>
        <description>CPUSS DataWire #0, Channel #18</description>
        <value>74</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_19</name>
        <description>CPUSS DataWire #0, Channel #19</description>
        <value>75</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_20</name>
        <description>CPUSS DataWire #0, Channel #20</description>
        <value>76</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_21</name>
        <description>CPUSS DataWire #0, Channel #21</description>
        <value>77</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_22</name>
        <description>CPUSS DataWire #0, Channel #22</description>
        <value>78</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_23</name>
        <description>CPUSS DataWire #0, Channel #23</description>
        <value>79</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_24</name>
        <description>CPUSS DataWire #0, Channel #24</description>
        <value>80</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_25</name>
        <description>CPUSS DataWire #0, Channel #25</description>
        <value>81</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_26</name>
        <description>CPUSS DataWire #0, Channel #26</description>
        <value>82</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_27</name>
        <description>CPUSS DataWire #0, Channel #27</description>
        <value>83</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_28</name>
        <description>CPUSS DataWire #0, Channel #28</description>
        <value>84</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_0</name>
        <description>CPUSS DataWire #1, Channel #0</description>
        <value>85</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_1</name>
        <description>CPUSS DataWire #1, Channel #1</description>
        <value>86</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_2</name>
        <description>CPUSS DataWire #1, Channel #2</description>
        <value>87</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_3</name>
        <description>CPUSS DataWire #1, Channel #3</description>
        <value>88</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_4</name>
        <description>CPUSS DataWire #1, Channel #4</description>
        <value>89</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_5</name>
        <description>CPUSS DataWire #1, Channel #5</description>
        <value>90</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_6</name>
        <description>CPUSS DataWire #1, Channel #6</description>
        <value>91</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_7</name>
        <description>CPUSS DataWire #1, Channel #7</description>
        <value>92</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_8</name>
        <description>CPUSS DataWire #1, Channel #8</description>
        <value>93</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_9</name>
        <description>CPUSS DataWire #1, Channel #9</description>
        <value>94</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_10</name>
        <description>CPUSS DataWire #1, Channel #10</description>
        <value>95</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_11</name>
        <description>CPUSS DataWire #1, Channel #11</description>
        <value>96</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_12</name>
        <description>CPUSS DataWire #1, Channel #12</description>
        <value>97</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_13</name>
        <description>CPUSS DataWire #1, Channel #13</description>
        <value>98</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_14</name>
        <description>CPUSS DataWire #1, Channel #14</description>
        <value>99</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_15</name>
        <description>CPUSS DataWire #1, Channel #15</description>
        <value>100</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_16</name>
        <description>CPUSS DataWire #1, Channel #16</description>
        <value>101</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_17</name>
        <description>CPUSS DataWire #1, Channel #17</description>
        <value>102</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_18</name>
        <description>CPUSS DataWire #1, Channel #18</description>
        <value>103</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_19</name>
        <description>CPUSS DataWire #1, Channel #19</description>
        <value>104</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_20</name>
        <description>CPUSS DataWire #1, Channel #20</description>
        <value>105</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_21</name>
        <description>CPUSS DataWire #1, Channel #21</description>
        <value>106</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_22</name>
        <description>CPUSS DataWire #1, Channel #22</description>
        <value>107</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_23</name>
        <description>CPUSS DataWire #1, Channel #23</description>
        <value>108</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_24</name>
        <description>CPUSS DataWire #1, Channel #24</description>
        <value>109</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_25</name>
        <description>CPUSS DataWire #1, Channel #25</description>
        <value>110</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_26</name>
        <description>CPUSS DataWire #1, Channel #26</description>
        <value>111</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_27</name>
        <description>CPUSS DataWire #1, Channel #27</description>
        <value>112</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_28</name>
        <description>CPUSS DataWire #1, Channel #28</description>
        <value>113</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_0</name>
        <description>CPUSS Fault Structure Interrupt #0</description>
        <value>114</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_1</name>
        <description>CPUSS Fault Structure Interrupt #1</description>
        <value>115</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_crypto</name>
        <description>CRYPTO Accelerator Interrupt</description>
        <value>116</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fm</name>
        <description>FLASH Macro Interrupt</description>
        <value>117</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_fp</name>
        <description>Floating Point operation fault</description>
        <value>118</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_0</name>
        <description>CM0+ CTI #0</description>
        <value>119</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_1</name>
        <description>CM0+ CTI #1</description>
        <value>120</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_0</name>
        <description>CM4 CTI #0</description>
        <value>121</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_1</name>
        <description>CM4 CTI #1</description>
        <value>122</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>123</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>124</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>125</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>126</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_256</name>
        <description>TCPWM #0, Counter #256</description>
        <value>131</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_257</name>
        <description>TCPWM #0, Counter #257</description>
        <value>132</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_258</name>
        <description>TCPWM #0, Counter #258</description>
        <value>133</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_259</name>
        <description>TCPWM #0, Counter #259</description>
        <value>134</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_260</name>
        <description>TCPWM #0, Counter #260</description>
        <value>135</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_261</name>
        <description>TCPWM #0, Counter #261</description>
        <value>136</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_262</name>
        <description>TCPWM #0, Counter #262</description>
        <value>137</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_263</name>
        <description>TCPWM #0, Counter #263</description>
        <value>138</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_dacs</name>
        <description>Consolidated interrrupt for all DACs</description>
        <value>146</value>
      </interrupt>
      <interrupt>
        <name>smif_interrupt</name>
        <description>Serial Memory Interface interrupt</description>
        <value>160</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_hi</name>
        <description>USB Interrupt</description>
        <value>161</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_med</name>
        <description>USB Interrupt</description>
        <value>162</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_lo</name>
        <description>USB Interrupt</description>
        <value>163</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupt0</name>
        <description>Can #0, Consolidated interrupt #0</description>
        <value>168</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts0_0</name>
        <description>CAN #0, Interrupt #0, Channel #0</description>
        <value>169</value>
      </interrupt>
      <interrupt>
        <name>canfd_0_interrupts1_0</name>
        <description>CAN #0, Interrupt #1, Channel #0</description>
        <value>170</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_29</name>
        <description>CPUSS DataWire #1, Channel #29</description>
        <value>171</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_30</name>
        <description>CPUSS DataWire #1, Channel #30</description>
        <value>172</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_31</name>
        <description>CPUSS DataWire #1, Channel #31</description>
        <value>173</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_29</name>
        <description>CPUSS DataWire #0, Channel #29</description>
        <value>174</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x13</resetValue>
          <resetMask>0x13</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
Note: this flag can also change as a result of  a change in debug power up req</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CLOCK_CTL</name>
          <description>CM4 clock control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>FAST_INT_DIV</name>
              <description>Specifies the fast clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_fast'). Integer division by (1+FAST_INT_DIV). Allows for integer divisions in the range [1, 256] (FAST_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CTL</name>
          <description>CM4 control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F000000</resetMask>
          <fields>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields a provide by this register (CM7_0_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.DZC 'divide by zero' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.OFC 'overflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.UFC 'underflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IXC 'inexact' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the 'inexact' condition is set as a result of rounding. Rounding may occur frequently and is typically not an error condition. To prevent frequent CPU FPU interrupts as a result of rounding, this field is typically set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IDC 'input denormalized' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: if the CPU FPCSR.FZ field is set to '1', denormalized inputs are 'flushed to zero'. Dependent on the FPU algorithm, this may or may not occur frequently. To prevent frequent CPU FPU interrupts as a result of denormalized inputs, this field may be set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT0_STATUS</name>
          <description>CM4 interrupt 0 status</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 0.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT1_STATUS</name>
          <description>CM4 interrupt 1 status</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT2_STATUS</name>
          <description>CM4 interrupt 2 status</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT3_STATUS</name>
          <description>CM4 interrupt 3 status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT4_STATUS</name>
          <description>CM4 interrupt 4 status</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT5_STATUS</name>
          <description>CM4 interrupt 5 status</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT6_STATUS</name>
          <description>CM4 interrupt 6 status</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT7_STATUS</name>
          <description>CM4 interrupt 7 status</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_VECTOR_TABLE_BASE</name>
          <description>CM4 vector table base</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFC00</resetMask>
          <fields>
            <field>
              <name>ADDR22</name>
              <description>Address of CM4 vector table. This register is used for CM4 warm and cold boot purposes: the CM0+ CPU initializes the CM4_VECTOR_TABLE_BASE register and the CM4 boot code uses the register to initialize the CM4 internal VTOR register.

Note: the CM4 vector table is at an address that is a 1024 B multiple.</description>
              <bitRange>[31:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_NMI_CTL[%s]</name>
          <description>CM4 NMI control</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set Power mode for UDBs</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_DELAY_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CTL</name>
          <description>CM0+ control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>SLV_STALL</name>
              <description>Processor debug access control:
'0': Access.
'1': Stall access.

This field is used to stall/delay debug accesses. This is useful to protect execution of code that needs to be protected from debug accesses.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM0+ reset, followed by a CM0+ warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the CM4 while the CM0+ is in Sleep or DeepSleep power mode. If this field is cleared to '0' by the CM0+ itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM0+ CPU has a AIRCR.SYSRESETREQ register field that allows the CM0+ to reset the complete device (ENABLED only disables/enables the CM0+), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this CM0_CTL register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CLOCK_CTL</name>
          <description>CM0+ clock control</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF00</resetMask>
          <fields>
            <field>
              <name>SLOW_INT_DIV</name>
              <description>Specifies the slow clock divider (from the peripheral clock 'clk_peri' to the slow clock 'clk_slow'). Integer division by (1+SLOW_INT_DIV). Allows for integer divisions in the range [1, 256] (SLOW_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERI_INT_DIV</name>
              <description>Specifies the peripheral clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_peri'). Integer division by (1+PERI_INT_DIV). Allows for integer divisions in the range [1, 256] (PERI_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.

Note that Fperi &lt;= Fperi_max. Fperi_max is likely to be smaller than Fhf_max. In other words, if Fhf = Fhf_max, PERI_INT_DIV should not be set to '0'.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT0_STATUS</name>
          <description>CM0+ interrupt 0 status</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 0.

Multiple system interrupts can be mapped on the same CPU interrupt. The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1'). 

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT1_STATUS</name>
          <description>CM0+ interrupt 1 status</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT2_STATUS</name>
          <description>CM0+ interrupt 2 status</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT3_STATUS</name>
          <description>CM0+ interrupt 3 status</description>
          <addressOffset>0x110C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT4_STATUS</name>
          <description>CM0+ interrupt 4 status</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT5_STATUS</name>
          <description>CM0+ interrupt 5 status</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT6_STATUS</name>
          <description>CM0+ interrupt 6 status</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT7_STATUS</name>
          <description>CM0+ interrupt 7 status</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_VECTOR_TABLE_BASE</name>
          <description>CM0+ vector table base</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Address of CM0+ vector table. This register is used for CM0+ warm boot purposes: the CM0+ warm boot code uses the register to initialize the CM0+ internal VTOR register.

Note: the CM0+ vector table is at an address that is a 256 B multiple.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_NMI_CTL[%s]</name>
          <description>CM0+ NMI control</description>
          <addressOffset>0x1140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Switch CM4 off
Power off, clock off, isolate, reset and no retain.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset CM4
Clock off, no isolated, no retain and reset.

Note: The CM4 CPU has a AIRCR.SYSRESETREQ register field that allows the CM4 to reset the complete device (RESET only resets the CM4), resulting in a warm boot.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM4 in Retained mode
This can only become effective if CM4 is in SleepDeep mode. Check PWR_DONE flag to see if CM4 RETAINED state has been reached.
Power off, clock off, isolate, no reset and retain.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Switch CM4 on.
Power on, clock on, no isolate, no reset and no retain.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_DELAY_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_CTL0</name>
          <description>RAM 0 control</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for system SRAM 0.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of system SRAM 0.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_STATUS</name>
          <description>RAM 0 status</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>RAM0_PWR_MACRO_CTL[%s]</name>
          <description>RAM 0 power control</description>
          <addressOffset>0x1340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>SRAM Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Turn OFF the SRAM. This will trun OFF both array and periphery power of the SRAM and SRAM memory contents are lost.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Keep SRAM in Retained mode. This will turn OFF the SRAM periphery power, but array power is ON to retain memory contents.
The SRAM contents will be retained in DeepSleep system power mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable SRAM for regular operation. 
The SRAM contents will be retained in DeepSleep system power mode.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL0</name>
          <description>RAM 1 control</description>
          <addressOffset>0x1380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM 1 status</description>
          <addressOffset>0x1384</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_PWR_CTL</name>
          <description>RAM 1 power control</description>
          <addressOffset>0x1388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See RAM0_PWR_MACRO_CTL.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_CTL0</name>
          <description>RAM 2 control</description>
          <addressOffset>0x13A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_STATUS</name>
          <description>RAM 2 status</description>
          <addressOffset>0x13A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_PWR_CTL</name>
          <description>RAM 2 power control</description>
          <addressOffset>0x13A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See RAM0_PWR_MACRO_CTL.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>Power up delay used for all SRAM power domains</description>
          <addressOffset>0x13C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control</description>
          <addressOffset>0x13C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.

Timing paths to and from the memory have a (fixed) minimum duration  that always needs to be considered/met. The 'clk_hf' clock domain frequency determines this field's value such that the timing paths minimum duration is met. A table/formula will be provided for this field's values for different 'clk_hf' frequencies.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x13C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the corresponding RAM0/RAM1/RAM2_CTL0.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.
This field needs to be written with the offset address within the memory, divided by 4.
For example, if the RAM1 start address is 0x08010000, and an error is to be injected to address 0x08010040, then this field needs to configured to 0x000010.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID a.k.a. Partnumber a.k.a. Silicon ID</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minor Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
'0': SWD selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AP_CTL</name>
          <description>Access port control</description>
          <addressOffset>0x1414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>CM0_ENABLE</name>
              <description>Enables the CM0 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM4_ENABLE</name>
              <description>Enables the CM4 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_ENABLE</name>
              <description>Enables the system AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM0_DISABLE</name>
              <description>Disables the CM0 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM4_DISABLE</name>
              <description>Disables the CM4 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM4_DISABLE is '0' and CM4_ENABLE is '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_DISABLE</name>
              <description>Disables the system AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_CTL</name>
          <description>SysTick timer control</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided. 
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MBIST_STAT</name>
          <description>Memory BIST status</description>
          <addressOffset>0x1704</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SFP_READY</name>
              <description>Flag indicating the BIST run is done. Note that after starting a BIST run this flag must be set before a new run can be started. For the first BIST run this will be 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFP_FAIL</name>
              <description>Report status of the BIST run, only valid if SFP_READY=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit 
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC_CTL</name>
          <description>CM0+ protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM0_PCi_HANDLER registers:
Bit 0: Valid field for CM0_PC0_HANDLER.
Bit 1: Valid field for CM0_PC1_HANDLER.
Bit 2: Valid field for CM0_PC2_HANDLER.
Bit 3: Valid field for CM0_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC0_HANDLER</name>
          <description>CM0+ protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC1_HANDLER</name>
          <description>CM0+ protection context 1 handler</description>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC2_HANDLER</name>
          <description>CM0+ protection context 2 handler</description>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC3_HANDLER</name>
          <description>CM0+ protection context 3 handler</description>
          <addressOffset>0x204C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x20C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
'0': UNKNOWN.
'1': VIRGIN.
'2': NORMAL.
'3': SECURE.
'4': DEAD.

The following state transitions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
- NORMAL =&gt; DEAD
- SECURE =&gt; DEAD
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ROM_CTL</name>
          <description>ROM trim control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM_CTL</name>
          <description>RAM trim control</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_SYSTEM_INT_CTL[%s]</name>
          <description>CM0+ system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 7]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_SYSTEM_INT_CTL[%s]</name>
          <description>CM4 system interrupt control</description>
          <addressOffset>0xA000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA3).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA3 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below.

Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. STATUS.IDX, DATA0, ..., DATA3 specify the fault.

Note: Typically, HW sets this field to '1' (on an activated HW fault source that is 'enabled' by the MASK registers) and SW clears this field to '0' (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, ..., DATA3 when the VALID field is set to '1'. 

An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to '1' with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds:
- STATUS.IDX, DATA0, ..., DATA3 can only be written when STATUS.VALID is '0'; the fault structure is not in use yet. Writing STATUS.VALID to '1' effectively locks the fault structure (until SW clears STATUS.VALID to '0'). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register.

Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be 'interrupted' by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: CM0 MPU.
Bit 1: CRYPTO MPU.
Bit 2: DW 0 MPU.
Bit 3: DW 1 MPU.
Bit 4: DMA controller MPU.
...
Bit 15: DAP MPU.
Bit 16: CM4 system bus MPU.
Bit 17: CM4 code bus MPU (for non FLASH controller accesses).
Bit 18: CM4 code bus MPU (for FLASH controller accesses).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING1</name>
            <description>Fault pending 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: Peripheral group 0 PPU.
Bit 1: Peripheral group 1 PPU.
Bit 2: Peripheral group 2 PPU.
Bit 3: Peripheral group 3 PPU.
Bit 4: Peripheral group 4 PPU.
Bit 5: Peripheral group 5 PPU.
Bit 6: Peripheral group 6 PPU.
Bit 7: Peripheral group 7 PPU.
...
Bit 15: Peripheral group 15 PPU.

Bit 16 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING2</name>
            <description>Fault pending 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK1</name>
            <description>Fault mask 1</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 63 to 32.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK2</name>
            <description>Fault mask 2</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 95 to 64.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0/MASK1/MASK2) pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA3 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROT</name>
      <description>Protection</description>
      <baseAddress>0x40230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>SMPU</name>
          <description>SMPU</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>MS0_CTL</name>
            <description>Master 0 protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Security setting ('0': secure mode; '1': non-secure mode).

Notes:
This field is ONLY used for masters that do NOT provide their own secure/non-secure access control attribute.
Note that the default/reset field value provides non-secure mode access capabilities to all masters.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Device wide bus arbitration priority setting ('0': highest priority, '3': lowest priority).

Notes: 
The AHB-Lite interconnect performs arbitration on the individual  beats/transfers of a burst (this optimizes latency over locality/bandwidth).
The AXI-Lite interconnects performs a single arbitration for the complete burst (this optimizes locality/bandwidth over latency).
Masters with the same priority setting form a 'priority group'. Within a 'priority group', round robin arbitration is performed.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>Protection context mask for protection context '0'. This field is a constant '0':
- PC_MASK_0 is '0': MPU MS_CTL.PC[3:0] can NOT be set to '0' and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>Protection context mask for protection contexts '15' down to '1'. Bit PC_MASK_15_TO_1[i] indicates if the MPU MS_CTL.PC[3:0] protection context field can be set to the value 'i+1':
- PC_MASK_15_TO_1[i] is '0': MPU MS_CTL.PC[3:0] can NOT be set to 'i+1'; and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.
- PC_MASK_15_TO_1[i] is '1': MPU MS_CTL.PC[3:0] can be set to 'i+1'.

Note: When CPUSS_CM0_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK_15_TO_1[i-1] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 1, 2 or 3 through (HW modifies MPU MS_CTL.PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts (SW modifies MPU MS_CTL.PC[3:0]).</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS1_CTL</name>
            <description>Master 1 protection context control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS2_CTL</name>
            <description>Master 2 protection context control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS3_CTL</name>
            <description>Master 3 protection context control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS4_CTL</name>
            <description>Master 4 protection context control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS5_CTL</name>
            <description>Master 5 protection context control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS6_CTL</name>
            <description>Master 6 protection context control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS7_CTL</name>
            <description>Master 7 protection context control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS8_CTL</name>
            <description>Master 8 protection context control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS9_CTL</name>
            <description>Master 9 protection context control</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS10_CTL</name>
            <description>Master 10 protection context control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS11_CTL</name>
            <description>Master 11 protection context control</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS12_CTL</name>
            <description>Master 12 protection context control</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS13_CTL</name>
            <description>Master 13 protection context control</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS14_CTL</name>
            <description>Master 14 protection context control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS15_CTL</name>
            <description>Master 15 protection context control</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>64</dimIncrement>
            <name>SMPU_STRUCT[%s]</name>
            <description>SMPU structure</description>
            <addressOffset>0x00002000</addressOffset>
            <register>
              <name>ADDR0</name>
              <description>SMPU region address 0 (slave structure)</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (ATT0.REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by ATT0 applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT0.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT0</name>
              <description>SMPU region attributes 0 (slave structure)</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x80000100</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ADDR1</name>
              <description>SMPU region address 1 (master structure)</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.

Two out of a total of eight 32 B subregions are enabled. These subregions includes region structures 0 and 1. 

Note: this field is read-only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region.

'ADDR_DEF1': base address of structure.

Note: this field is read-only.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT1</name>
              <description>SMPU region attributes 1 (master structure)</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7000109</resetValue>
              <resetMask>0x9F00012D</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).

Note that this register is constant '1'; i.e. user read accesses are ALWAYS allowed.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).

Note that this register is constant '0'; i.e. user execute accesses are NEVER allowed.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).

Note that this register is constant '1'; i.e. privileged read accesses are ALWAYS allowed.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).

Note that this register is constant '0'; i.e. privileged execute accesses are NEVER allowed.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'7': 256 B region (8 32 B subregions)

Note: this field is read-only.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>1024</dimIncrement>
          <name>MPU[%s]</name>
          <description>MPU</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>MS_CTL</name>
            <description>Master control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields. In addition, a write transfer with protection context '0' can change this field (protection context 0 has unrestricted access).

The CM0+ MPU MS_CTL register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the MPU MS_CTL.PC field is modifiable by SW ONLY. For CM0+ PC field HW modifications, the following holds:
* On entry of a CM0_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_CTL.PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM0_PC_CTL.VALID[MS_CTL.PC])
       An AHB-Lite bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).

Note that the CM0_PC0/1/2/3_HANDLER and CM0_PC_CTL registers are part of repecitve CPUSS MMIO registers.

Note: this field is NOT used by the DW controllers, DMA controller, AXI DMA controller, CRYPTO component and VIDEOSS.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Saved protection context. Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields.

Note: this field is ONLY used by the CM0+.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>127</dim>
            <dimIncrement>4</dimIncrement>
            <name>MS_CTL_READ_MIR[%s]</name>
            <description>Master control read mirror</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Read-only mirror of MS_CTL.PC</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Read-only mirror of MS_CTL.PC_SAVED</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>32</dimIncrement>
            <name>MPU_STRUCT[%s]</name>
            <description>MPU structure</description>
            <addressOffset>0x00000200</addressOffset>
            <register>
              <name>ADDR</name>
              <description>MPU region address</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by MPU_REGION_ATT applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT</name>
              <description>MPU region attrributes</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASHC</name>
      <description>Flash controller</description>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLASH_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x110000</resetValue>
          <resetMask>0x77330F</resetMask>
          <fields>
            <field>
              <name>MAIN_WS</name>
              <description>FLASH macro main interface wait states:
'0': 0 wait states.
...
'15': 15 wait states</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_MAP</name>
              <description>Specifies mapping of FLASH macro main array.
0: Mapping A.
1: Mapping B. 

This field is only used when MAIN_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_MAP</name>
              <description>Specifies mapping of FLASH macro work array.
0: Mapping A.
1: Mapping B. 

This field is only used when WORK_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro main array.
0: Single bank mode.
1: Dual bank mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro work array.
0: Single bank mode.
1: Dual bank mode.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_EN</name>
              <description>Enable ECC checking for FLASH main interface:
0: Disabled. ECC checking/reporting on FLASH main interface is disabled. No correctable or non-correctable faults are reported.
1: Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH main interface.
When'1', the parity (ECC_CTL.PARITY[7:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error, a FLASH macro main interface internal error, a FLASH macro main interface memory hole access):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU (and debug i.e. SYS_AP/CM0_AP/CM4_AP) bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS and CM4_STATUS) to register the occurrence of FLASH macro main interface internal errors (non-correctable ECC errors and memory hole errors are NOT registered).

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro main interface internal error. 
- FLASH macro main interface non-recoverable ECC error.
- FLASH macro main interface recoverable ECC error.
- FLASH macro main interface memory hole error.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_EN</name>
              <description>Enable ECC checking for FLASH work interface:
0: Disabled. ECC checking/reporting on FLASH work interface is disabled. No correctable or non-correctable faults are reported.
1: Enabled.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH work interface.
When'1', the parity (ECC_CTL.PARITY[6:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro work interface (either a non-correctable ECC error, a FLASH macro work interface internal error, a FLASH macro work interface memory hole access):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU (and debug i.e. SYS_AP/CM0_AP/CM4_AP) bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS and CM4_STATUS) to register the occurrence of FLASH macro work interface internal errors (non-correctable ECC errors and memory hole errors are NOT registered).

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro work interface internal error. 
- FLASH macro work interface non-recoverable ECC error.
- FLASH macro work interface recoverable ECC error.
- FLASH macro work interface memory hole error.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PWR_CTL</name>
          <description>Flash power control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Controls 'enable' pin of the Flash memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_HV</name>
              <description>Controls 'enable_hv' pin of the Flash memory.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CMD</name>
          <description>Command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of ALL caches (for CM0+ and CM4) and ALL buffers. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The caches' LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of ALL buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks.

Note: the caches only capture FLASH macro main array data. Therefore, invalidating just the buffers (BUFF_INV) does not invalidate captures main array data in the caches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For cache SRAM ECC, the word address WORD_ADDR[23:0] is device address A[25:2]. On a FLASH macro refill to this word address and when the corresponding CM0/4_CA_CTL.RAM_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) is injected and stored in the cache.
- For FLASH main interface ECC, the word address WORD_ADDR[23:0] is device address A[26:3]. On a FLASH main interface read and when FLASH_CTL.MAIN_ECC_INJ_EN bit is '1', the parity (PARITY[7:0]) replaces the FLASH macro parity (FLASH main interface read path is manipulated).
- For FLASH work interface ECC, the word address WORD_ADDR[23:0] is device address A[24:2]. On a FLASH work interface read and when FLASH_CTL.WORK_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) replaces the FLASH macro parity (FLASH work interface read path is manipulated).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. 
- For cache SRAM ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.
- For FLASH main interface ECC, the 8-bit parity PARITY[7:0] is for a 64-bit word.
- For FLASH work interface ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL0</name>
          <description>eCT Flash SRAM ECC control 0</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_DATA</name>
              <description>32-bit data for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL1</name>
          <description>eCT Flash SRAM ECC control 1</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_PARITY</name>
              <description>7-bit parity for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL2</name>
          <description>eCT Flash SRAM ECC control 2</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CORRECTED_DATA</name>
              <description>32-bit corrected data output of the ECC syndrome logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL3</name>
          <description>eCT Flash SRAM ECC control 3</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x111</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>ECC generation/check enable for eCT Flash SRAM memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>eCT Flash SRAM ECC error injection test enable. Follow the steps below for ECC logic test:
1. Write corrupted or uncorrupted 39-bit data to FM_SRAM_ECC_CTL0/1 registers.
2. Set the ECC_INJ_EN bit to '1'.
3. Confirm that the bit ECC_TEST_FAIL is '0'. If this is not the case, start over at item 1 because the eCT Flash was not idle.
4. Check the corrected data in FM_SRAM_ECC_CTL2.
5. Confirm that fault was reported to fault structure, and check syndrome (only applicable if
corrupted data was written in step 1).
6. If not finished, start over at 1 with different data.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_TEST_FAIL</name>
              <description>Status of ECC test.
1 : ECC test failed because eCT Flash macro is busy and using the SRAM.
0: ECC was performed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL0</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
0: Disabled.
1: Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a refill is done from the FLASH macro to the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL1</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM0 cache.
The following sequnece should be followed for turning OFF/ON the cache SRAM.
Turn OFF sequence:
a) Write CM0_CA_CTL0 to disable cache.
b) Write CM0_CA_CTL1 to turn OFF cache SRAM.
Turn ON sequence:
a) Write CM0_CA_CTL1 to turn ON cache SRAM.
b) Delay to allow power up of cache SRAM. Delay should be at a minimum of CM0_CA_CTL2.PWRUP_DELAY CLK_SLOW clock cycles.
c) Write CM0_CA_CTL0 to enable cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Power OFF the CM0 cache SRAM.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM0 cache SRAM in retained mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable/Turn ON the CM0 cache SRAM.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL2</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS0</name>
          <description>CM0+ cache status 0</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS1</name>
          <description>CM0+ cache status 1</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS2</name>
          <description>CM0+ cache status 2</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CM0_CA_CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ interface status</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM0+ access (or debug access via SYS_AP/CM0_AP). 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL0</name>
          <description>CM4 cache control</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL1</name>
          <description>CM4 cache control</description>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM4 cache. Refer CM0_CA_CTL1 for more details.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL2</name>
          <description>CM4 cache control</description>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS0</name>
          <description>CM4 cache status 0</description>
          <addressOffset>0x4C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>See CM0_CA_STATUS0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS1</name>
          <description>CM4 cache status 1</description>
          <addressOffset>0x4C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>See CM0_CA_STATUS1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS2</name>
          <description>CM4 cache status 2</description>
          <addressOffset>0x4C8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>See CM0_CA_STATUS2.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 interface status</description>
          <addressOffset>0x4E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM4 access (or debug access via SYS_AP/CM4_AP). 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM4_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_BUFF_CTL</name>
          <description>Cryptography buffer control</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.
A prefetch will be done when there is read 'hit' on the last 32-bit word of the buffer.
For eCT work Flash, prefetch will not be done.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW0_BUFF_CTL</name>
          <description>Datawire 0 buffer control</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW1_BUFF_CTL</name>
          <description>Datawire 1 buffer control</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_BUFF_CTL</name>
          <description>DMA controller buffer control</description>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS0_BUFF_CTL</name>
          <description>External master 0 buffer control</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS1_BUFF_CTL</name>
          <description>External master 1 buffer control</description>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>FM_CTL</name>
          <description>Flash Macro Registers</description>
          <addressOffset>0x0000F000</addressOffset>
          <register>
            <name>FM_CTL</name>
            <description>Flash macro control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x37F030F</resetMask>
            <fields>
              <field>
                <name>FM_MODE</name>
                <description>Requires (IF_SEL|WR_EN)=1
Flash macro mode selection</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_SEQ</name>
                <description>Requires (IF_SEL|WR_EN)=1
Flash macro sequence selection</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAA_MUX_SEL</name>
                <description>Direct memory cell access address.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_SEL</name>
                <description>Interface selection. Specifies the interface that is used for flash memory read operations:
0: R interface is used (default value). In this case, the flash memory address is provided as part of the R signal interface.
1: C interface is used. In this case, the flash memory address is provided by FM_MEM_ADDR (the page address) and by the C interface access offset in the FM_MEM_DATA structure.
Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_EN</name>
                <description>0: normal mode
1: Fm Write Enable
Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x1800</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_ENABLED</name>
                <description>This is the timer_en bit set by writing a '1' in the TIMER_CTL bit 31. It is reset by HW when the timer expires
0: timer not running
1: Timer is enabled and not expired yet</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HV_REGS_ISOLATED</name>
                <description>Indicates the isolation status at HV trim and redundancy registers inputs
0: Not isolated, writing permitted
1: isolated writing disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ILLEGAL_HVOP</name>
                <description>Indicates a bulk, sector erase, program has been requested when axa=1
0: no error
1: illegal HV operation error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TURBO_N</name>
                <description>After FM power up indicates the analog blocks currents are boosted to faster reach their functional state.. 
Used in the testchip boot only as an 'FM READY' flag.  
0: turbo mode 
1: normal mode</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_EN_MON</name>
                <description>FM_CTL.WR_EN bit after being synchronized in clk_r domain</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IF_SEL_MON</name>
                <description>FM_CTL.IF_SEL bit after being synchronized in clk_r domain</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMER_STATUS</name>
                <description>The actual timer state sync-ed in clk_c domain:
0: timer is not running:
1: timer is running;</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>R_GRANT_DELAY_STATUS</name>
                <description>0: R_GRANT_DELAY timer is not running
1: R_GRANT_DELAY timer is running</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_BUSY</name>
                <description>0': FM not busy 
1: FM BUSY : R_GRANT is 0 as result of a busy request from FM ready, or from HV operations.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_READY</name>
                <description>0: FM not ready
1: FM ready</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POS_PUMP_VLO</name>
                <description>POS pump VLO</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NEG_PUMP_VHI</name>
                <description>NEG pump VHI</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWW</name>
                <description>FM Type  (Read While Write or Not Read While Write):
0: Non RWW FM Type
1:  RWW FM Type</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_DOUT_WIDTH</name>
                <description>Internal memory core max data out size 
(number of data out bits per column):
0: x128 bits
1: x256 bits</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECTOR0_SR</name>
                <description>0:  Sector 0 does not contain special rows. The special rows are located in separate special sectors.
1:  Sector 0 contains special rows</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESET_MM</name>
                <description>Test_only, internal node: mpcon  reset_mm</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_ODD</name>
                <description>Test_only, internal node: mpcon  row_odd</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_EVEN</name>
                <description>Test_only, internal node: mpcon  row_even</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SUB_SECTOR_N</name>
                <description>Test_only, internal node: mpcon  bk_subb</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SECTOR</name>
                <description>Test_only, internal node: mpcon  bk_sec</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_BULK_ALL</name>
                <description>Test_only, internal node: mpcon  bk_all</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RA_MATCH</name>
                <description>Test_only, internal node: mpcon  ra match</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RED_ROW_EN</name>
                <description>Test_only, internal node: mpcon  red_row_en</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RQ_ERROR</name>
                <description>Test_only, internal node:  rq_error  sync-de in clk_c domain</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_PDAC</name>
                <description>Test_only, internal node: regif pdac outputs to pos pump</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_NDAC</name>
                <description>Test_only, internal node: regif ndac outputs to pos pump</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_ADDR</name>
            <description>Flash macro address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Row address.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BA</name>
                <description>Bank address.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AXA</name>
                <description>Auxiliary address field:
0: regular flash memory.
1: supervisory flash memory.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOKMARK</name>
            <description>Bookmark register - keeps the current FW HV seq</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BOOKMARK</name>
                <description>Used by FW. Keeps the Current HV cycle sequence</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY</name>
            <description>Regular flash geometry</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1):
0: 1 row
1: 2 rows
2: 3 rows
...
'65535': 65536 rows</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1):
0: 1 bank
1: 2 banks
...
'255': 256 banks</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). A word is defined as the data that is read from the flash macro over the R interface with a single read access:
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
3: 128 Bytes

The currently planned flash macros have a word size of either 32-bit, 64-bit or 128-bit, resulting in WORD_SIZE_LOG2 settings of 2, 3 and 4 respectively.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2):
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
15: 32768 Bytes

The currently planned flash macros have a page size of either 256 Byte or 512 Byte, resulting in PAGE_SIZE_LOG2 settings of 8 and 9 respectively.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY_SUPERVISORY</name>
            <description>Supervisory flash geometry</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1). ROW_COUNT is typically less than GEOMETRY.ROW_COUNT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1). BANK_COUNT is less or equal to GEOMETRY.BANK_COUNT.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). See GEOMETRY.WORD_SIZE_LOG2. Typically, WORD_SIZE_LOG2 equals GEOMETRY.WORD_SIZE_LOG2.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2). See GEOMETRY.PAGE_SIZE_LOG2. Typically, PAGE_SIZE_LOG2 equals GEOMETRY.PAGE_SIZE_LOG2.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL0</name>
            <description>Analog control 0</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MDAC</name>
                <description>Trimming of the output margin Voltage as a function of Vpos and Vneg.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CSLDAC</name>
                <description>Trimming of common source line DAC.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIP_AMUXBUS_AB</name>
                <description>Flips amuxbusa and amuxbusb 
0: amuxbusa, amuxbusb
1:  amuxbusb, amuxbusb</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_MIN</name>
                <description>NDAC staircase min value</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MIN</name>
                <description>PDAC staircase min value</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_SEQ30</name>
                <description>PROG&amp;PRE_PROG&amp; ERASE: Scale for R_GRANT_DELAY on seq3-seq0 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL1</name>
            <description>Analog control 1</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xD32FAFA</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDAC_MAX</name>
                <description>Ndac Max Value.Trimming of negative pump output Voltage.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_STEP</name>
                <description>Ndac step increment</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MAX</name>
                <description>Pdac Max Value.Trimming of positive pump output Voltage:</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_STEP</name>
                <description>Pdac step increment</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_STEP_TIME</name>
                <description>Ndac/Pdac step duration: (1uS .. 255uS) * 8
When = 0 N/PDAC_MAX control the pumps</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_ZERO_TIME</name>
                <description>Ndac/Pdac LO duration: (1uS .. 255uS) * 8
When 0, N/PDAC don't return to 0</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WAIT_CTL</name>
            <description>Wait State control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x30B09</resetValue>
            <resetMask>0x3F070F0F</resetMask>
            <fields>
              <field>
                <name>WAIT_FM_MEM_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the memory</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the high Voltage page latches.
Common for reading HV Page Latches and the DATA_COMP_RESULT bit</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_WR</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a write to the high Voltage page latches.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_RWW_MODE</name>
                <description>00: Full CBUS MODE
01: RWW
10: RWW. R_GRANT is stalling r_bus for the whole program/erase duration</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LV_SPARE_1</name>
                <description>Spare register</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRMM</name>
                <description>0: Normal
1: Test mode to enable Margin mode for 2 rows at a time</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MBA</name>
                <description>0: Normal
1: Test mode to enable Master Bulk Access which allows both normal rows and redundant rows to be erased / programmed in one HV cycle (Bulk / Sector Erase and Sector Program).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PL_SOFT_SET_EN</name>
                <description>Page latch soft set enable, 0 = disabled, 1 = enabled (at end of seq_2), taken care in API</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CLK_CTL</name>
            <description>Timer prescaler (clk_t to timer clock frequency divider)</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_CLOCK_FREQ</name>
                <description>Clk_t frequency divider to provide the 1MHz reference clock for the Regif Timer.
Equal to the frequency in MHz of the timer clock 'clk_t'.
Example: if 'clk_t' has a frequency of 4 MHz then this field value is '4'
Max clk_t frequency = 100MHz.
This field is updated at runtime with the  'SW_TIMER_CLOCK_FREQ ' value from the HV parameters table</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CTL</name>
            <description>Timer control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4000001</resetValue>
            <resetMask>0xE700FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Timer period in either microseconds (SCALE is '0') or 100's of microseconds (SCALE is '1') multiples.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE</name>
                <description>Timer tick scale:
0: 1 microsecond.
1: 100 microseconds.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_SEQUENCE</name>
                <description>1': Starts1 the HV automatic sequencing 
Cleared by HW</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG</name>
                <description>1 during pre-program operation</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG_CSL</name>
                <description>0: CSL lines driven by CSL_DAC
1: CSL lines driven by VNEG_G</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PUMP_EN</name>
                <description>Pump enable:
0: disabled
1: enabled (also requires FM_CTL.IF_SEL to be'1', this additional restriction is required to prevent non intentional clearing of the FM).
SW sets this field to '1' to generate a single PE pulse. 
HW clears this field when timer is expired.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACLK_EN</name>
                <description>ACLK enable (generates a single cycle pulse for the FM):
0: disabled
1: enabled. SW set this field to '1' to generate a single cycle pulse. HW sets this field to '0' when the pulse is generated.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_EN</name>
                <description>Timer enable:
0: disabled
1: enabled. SW sets this field to '1' to start the timer. HW sets this field to '0' when the timer is expired.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACLK_CTL</name>
            <description>MPCON clock</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACLK_GEN</name>
                <description>A write to this register generates the clock pulse for HV control registers (mpcon outputs)</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Logical and of corresponding request and mask fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL0</name>
            <description>Cal control BG LO trim bits</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x38F8F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_LO_HV</name>
                <description>LO Temperature compensated trim DAC. To control Vcstat slope for Vpos.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage trim control.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage Temperature Compensation trim control</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_LO_HV</name>
                <description>LO Bandgap Current Temperature Compensation trim control</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_LO_HV</name>
                <description>Adds 100-150nA boost on IPREF_LO</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL1</name>
            <description>Cal control BG HI trim bits</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x38F8F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_HI_HV</name>
                <description>HI Temperature compensated trim DAC. To control Vcstat slope for Vpos.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage trim control.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_HI_HV</name>
                <description>HI Bandgap Current Temperature Compensation trim control.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_HI_HV</name>
                <description>Adds 100-150nA boost on IPREF_HI</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL2</name>
            <description>Cal control BG LO&amp;HI trim bits</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x7BE10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ICREF_TRIM_LO_HV</name>
                <description>LO Bandgap Current  trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TRIM_HI_HV</name>
                <description>HI Bandgap Current  trim control.</description>
                <bitRange>[9:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_LO_HV</name>
                <description>LO Bandgap IPTAT trim control.</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_HI_HV</name>
                <description>HI  Bandgap IPTAT trim control.</description>
                <bitRange>[19:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL3</name>
            <description>Cal control osc trim bits, idac, sdac, itim</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2004</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>OSC_TRIM_HV</name>
                <description>Flash macro pump clock trim control.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OSC_RANGE_TRIM_HV</name>
                <description>0: Oscillator High Frequency Range
1: Oscillator Low Frequency range</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VPROT_ACT_HV</name>
                <description>Forces VPROT in active mode all the time</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TC_HV</name>
                <description>0: Increases the IPREF Tempco by subtracting ICREF from IPREF - IPREF internal will be 0.5uA
1: Reduces the IPREF Tempco without subtracting ICREF from IPREF - IPREF internal will be 1uA</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL_HV</name>
                <description>Voltage reference:
0: internal bandgap reference
1: external voltage reference</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IREF_SEL_HV</name>
                <description>Current reference:
0: internal current reference
1: external current reference</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REG_ACT_HV</name>
                <description>0: VBST regulator will operate in active/standby mode based on control signal.
1: Forces the VBST regulator in active mode all the time</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FDIV_TRIM_HV</name>
                <description>FDIV_TRIM_HV[1:0]: Assuming oscillator frequency of 8MHz in standby.
Following are the clock frequencies seen by doubler
00: F = 1MHz 
01: F = 0.5MHz 
10: F = 2MHz
11: F = 4MHz</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VDDHI_HV</name>
                <description>0: vdd &lt; 2.3V 
1: vdd &gt;= 2.3V
'0' setting can used for vdd &gt; 2.3V also, but with a current penalty.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_PULSEW_HV</name>
                <description>Turbo pulse width trim (Typical)
00: 40 us
01: 20 us
10: 15 us 
11: 8 us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGLO_EN_HV</name>
                <description>0: Normal (Automatic change over from HI to LO)
1: Force enable LO Bandgap</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGHI_EN_HV</name>
                <description>0: Normal (Automatic change over from HI to LO)
1: Force enable HI Bandgap 
When both BGLO_EN_HV and BGHI_EN_HV are HIGH, only BGHI output is used and turbo_hv_n pulse is active</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CL_ISO_DIS_HV</name>
                <description>0: The internal logic controls the CL isolation
1: Forces CL bypass</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>R_GRANT_EN_HV</name>
                <description>0: r_grant handshake disabled, r_grant always 1.
1: r_grand handshake  enabled</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LP_ULP_SW_HV</name>
                <description>LP&lt;--&gt;ULP switch for trim signals:
0: LP
1: ULP</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL4</name>
            <description>Cal Control Vlim, SA, fdiv, reg_act</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x12AE0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_ULP_HV</name>
                <description>VLIM_TRIM[1:0]: 
00: V2 = 650mV
01: V2 = 600mV
10: V2 = 750mV
11: V2 = 700mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_ULP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_ULP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_ULP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_ULP_HV</name>
                <description>00: Default : delay 1ns
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE451_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>READY_RESTART_N_HV</name>
                <description>Toggle: 1--&gt;0, ready goes low, ready will remain low as long as the bit is low. Toggle the bit back to 1 to activate the ready logic. To be used by API only.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBST_S_DIS_HV</name>
                <description>0: VBST_S voltage for each sector to allow VBST level to be dropped to VCC during Erase in the selected sector, reducing coupling to GBL. 
1: VBST_S voltage for each sector stays at VBST level during Erase in the selected sector.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_HVPULSE_HV</name>
                <description>0: HV Pulse controlled by FW
1: HV Pulse controlled by Hardware</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UGB_EN_HV</name>
                <description>UGB enable in TM control</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL5</name>
            <description>Cal control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2AE0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_LP_HV</name>
                <description>VLIM_TRIM[1:0]: 
00: V2 = 650mV
01: V2 = 600mV
10: V2 = 750mV
11: V2 = 700mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_LP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_LP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_LP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_LP_HV</name>
                <description>00: Delayed by 1us
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE451_LP_HV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE52_HV</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AMUX_SEL_HV</name>
                <description>Amux Select in AMUX_UGB
00: Bypass UGB for both amuxbusa and amuxbusb
01: Bypass UGB for amuxbusb while passing amuxbusa through UGB.
10: Bypass UGB for amuxbusa while passing amuxbusb through UGB.
11: UGB Calibrate mode</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL6</name>
            <description>SA trim LP/ULP</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x36F7F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>SA_CTL_TRIM_T1_ULP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_ULP_HV</name>
                <description>SA_CTL_TRIM_T4_ULP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_ULP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_ULP_HV</name>
                <description>SA_CTL_TRIM_T5_ULP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_ULP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_ULP_HV</name>
                <description>SA_CTL_TRIM_T6_ULP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_ULP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[8:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_ULP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T1_LP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_LP_HV</name>
                <description>SA_CTL_TRIM_T4_LP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_LP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[13:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_LP_HV</name>
                <description>SA_CTL_TRIM_T5_LP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_LP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[16:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_LP_HV</name>
                <description>SA_CTL_TRIM_T6_LP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_LP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[18:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_LP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL7</name>
            <description>Cal control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ERSX8_CLK_SEL_HV</name>
                <description>Clock frequency into the ersx8 shift register block 
00: Oscillator clock
01: Oscillator clock / 2
10: Oscillator clock / 4
11: Oscillator clock</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_ACTIVE_HV</name>
                <description>0: Normal operation
1: Forces FM SYS in active mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_EXT_HV</name>
                <description>0: Normal operation
1: Uses external turbo pulse</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_HWCTL_DIS_HV</name>
                <description>0': ndac, pdac staircase hardware controlled
1: ndac, pdac staircase disabled. Enables FW control.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DIS_HV</name>
                <description>0': fm ready is enabled 
1: fm ready is disabled (fm_ready is always '1')</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERSX8_EN_ALL_HV</name>
                <description>0': Staggered turn on/off of GWL
1: GWL are turned on/off at the same time (old FM legacy)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_LOAD_ONCE_HV</name>
                <description>0: Load common HV params during API HV operations depends on the HV_PARAMS_LOADED bit in RGRANT_DELAY_PRG register.
1: All HV params are loaded during every API HV operation irrespective of HV_PARAMS_LOADED bit in the RGRANT_DELAY_PRG register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_HV</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_LP_HV</name>
                <description>N/A</description>
                <bitRange>[19:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL01</name>
            <description>Redundancy Control normal sectors 0,1</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_0</name>
                <description>Bad Row Pair Address for Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_0</name>
                <description>1: Redundancy Enable for Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_1</name>
                <description>Bad Row Pair Address for Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_1</name>
                <description>1: Redundancy Enable for Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL23</name>
            <description>Redundancy Control normal sectors 2,3</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_2</name>
                <description>Bad Row Pair Address for Sector 2</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_2</name>
                <description>1: Redundancy Enable for Sector 2</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_3</name>
                <description>Bad Row Pair Address for Sector 3</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_3</name>
                <description>1: Redundancy Enable for Sector 3</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL45</name>
            <description>Redundancy Control normal sectors 4,5</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_4</name>
                <description>Bad Row Pair Address for Sector 4</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_4</name>
                <description>1: Redundancy Enable for Sector 4</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_5</name>
                <description>Bad Row Pair Address for Sector 5</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_5</name>
                <description>1: Redundancy Enable for Sector 5</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL67</name>
            <description>Redundancy Control normal sectors 6,7</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_6</name>
                <description>Bad Row Pair Address for Sector 6</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_6</name>
                <description>1: Redundancy Enable for Sector 6</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_7</name>
                <description>Bad Row Pair Address for Sector 7</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_7</name>
                <description>1: Redundancy Enable for Sector 7</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL_SM01</name>
            <description>Redundancy Control special sectors 0,1</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_SM0</name>
                <description>Bad Row Pair Address for Special Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_SM0</name>
                <description>Redundancy Enable for Special Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_SM1</name>
                <description>Bad Row Pair Address for Special Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_SM1</name>
                <description>Redundancy Enable for Special Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_PRG</name>
            <description>R-grant delay for program</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1000000</resetValue>
            <resetMask>0x8FFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_SEQ30</name>
                <description>PROG&amp;PRE_PROG &amp; ERASE: R-grant blocking delay on seq3-seq0 transition. Scale = ANA_CTL0.SCALE_SEQ30
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_CLK</name>
                <description>Frequency divider from clk_t  to create the 8MHz reference clock for R_grant delay
The value of this field is the integer result of 'clk_t frequency / 8'.
Example: for clk_t=100 this field is INT(100/8) =12.
This field is updated at runtime with the  'SW_RGRANT_DELAY_CLK ' value from the HV parameters table</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HV_PARAMS_LOADED</name>
                <description>0: HV Pulse common params not loaded
1: HV Pulse common params  loaded: r-grant delays, r-grant scale, prescaler, timer values for seq1,seq2_pre, seq2_post, seq3</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ12</name>
            <description>HV Pulse Delay for seq 1&amp;2 pre</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ1</name>
                <description>Seq1 delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ2_PRE</name>
                <description>Seq2 pre delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ23</name>
            <description>HV Pulse Delay for seq2 post &amp; seq3</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ2_POST</name>
                <description>Seq2 post  delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ3</name>
                <description>Seq3 delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_SCALE_ERS</name>
            <description>R-grant delay scale for erase</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF03FF</resetMask>
            <fields>
              <field>
                <name>SCALE_ERS_SEQ01</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ12</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ23</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEON</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEOFF</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEON</name>
                <description>ERASE: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEOFF</name>
                <description>ERASE: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_ERS</name>
            <description>R-grant delay for erase</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ01</name>
                <description>ERASE: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ12</name>
                <description>ERASE: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ23</name>
                <description>ERASE: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_PL_WRDATA_ALL</name>
            <description>Flash macro write page latches all</description>
            <addressOffset>0x7FC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Write all high Voltage page latches with the same 32-bit data in a single write cycle
Read always returns 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_PL_DATA[%s]</name>
            <description>Flash macro Page Latches data</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Four page latch Bytes 
When reading the page latches it requires FM_CTL.IF_SEL to be '1'
Note: the high Voltage page latches are readable for test mode functionality.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_MEM_DATA[%s]</name>
            <description>Flash macro memory sense amplifier and column decoder data</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Sense amplifier and column multiplexer structure Bytes. The read data is dependent on FM_CTL.IF_SEL:
- IF_SEL is 0: data as specified by the R interface address
- IF_SEL is 1: data as specified by FM_MEM_ADDR and the offset of the accessed FM_MEM_DATA register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers</description>
      <baseAddress>0x40260000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFC0033</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active, and current consumption may be higher than datasheet specification.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after XRES/POR/BOD/HIBERNATE wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IREF_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Current reference generator operates in normal mode.
1: Current reference generator operates in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting VREFBUF_DIS=1.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Disable the DeepSleep regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: DeepSleep Regulator is on.
1: DeepSleep Regulator is off.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Disable the Retention regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Retention Regulator is on.
1: Retention Regulator is off.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Disable the Nwell regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Nwell Regulator is on.
1: Nwell Regulator is off.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_DIS</name>
              <description>Disable the linear Core Regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Linear regulator is on.
1: Linear regulator is off.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Linear Regulator operates in normal mode.
1: Linear Regulator operates in low power mode.  Load current capability is reduced, and firmware must ensure the current is kept within the limit for this operating mode.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: POR/BOD circuits operate in normal mode.
1: POR/BOD circuits operate in low power mode.  Response time is reduced to save current.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the power mode of the Bandgap Voltage and Current References.  This applies to voltage and current generation and is different than the reference voltage buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.  When lower power mode is used, the Active Reference circuit can be disabled to reduce current.  Firmware is responsible to ensure ACT_REF_OK==1 before changing back to normal mode.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Active Bandgap Voltage and Current Reference operates in normal mode.
1: Active Bandgap Voltage and Current Reference operates in low power mode.  Power supply rejection is reduced to save current.  The Active Reference may be disabled using ACT_REF_DIS=0.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_LPMODE</name>
              <description>Control the power mode of the 800mV voltage reference buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.
0: Voltage Reference Buffer operates in normal mode. This register is only reset by XRES/POR/BOD/HIBERNATE.
1: Voltage Reference Buffer operates in low power mode.  Power supply rejection is reduced to save current.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_DIS</name>
              <description>Disable the 800mV voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_DIS</name>
              <description>Disables the Active Reference.  Firmware must ensure that LPM_READY==1 and BGREF_LPMODE==1 for at least 1us before disabling the Active Reference.  When enabling the Active Reference, use ACT_REF_OK indicator to know when it is ready.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Active Reference is enabled
1: Active Reference is disabled</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_OK</name>
              <description>Indicates that the normal mode of the Active Reference is ready.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Controls whether mode and state of GPIOs and SIOs in the system are frozen.  This is intended to be used as part of the HIBERNATE entry and exit sequences.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>When set, HIBERNATE will wakeup for a RTC interrupt</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>When set, HIBERNATE will wakeup if WDT matches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>Each bit sets the active polarity of the corresponding wakeup pin.
0: Pin input of 0 will wakeup the part from HIBERNATE
1: Pin input of 1 will wakeup the part from HIBERNATE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>When set, HIBERNATE will wakeup if the corresponding pin input matches the POLARITY_HIBPIN setting.  Each bit corresponds to one of the HIBERNATE wakeup pins.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>Low Voltage Detector (LVD) Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1.  Disable the LVD (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  When the LVD is enabled, it takes 20us for it to settle.  There is no hardware stabilization counter, and it may falsely trigger during settling.  It is recommended that firmware keep the interrupt masked for at least 8us, write a 1'b1 to the corresponding SRSS_INTR field to any falsely pended interrupt, and then optionally unmask the interrupt.  After enabling, it is further recommended to read the related PWR_LVD_STATUS field, since the interrupt only triggers on edges.  This bit is cleared (LVD is disabled) when entering DEEPSLEEP to prevent false interrupts during wakeup.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>Buck Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES/POR/BOD/HIBERNATE.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 0.95V
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES/POR/BOD/HIBERNATE.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The TRM specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>Buck Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>Low Voltage Detector (LVD) Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OK</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTL</name>
          <description>Watchdog Counter Control Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Enable this watchdog timer.  This field is retained during DEEPSLEEP and HIBERNATE modes.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_LOCK</name>
              <description>Prohibits writing to WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers when not equal 0.  Requires at least two different writes to unlock.  A change in WDT_LOCK takes effect beginning with the next write cycle.
Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all those registers at the same time.  WDT will lock on any reset.  This field is not retained during DEEPSLEEP or HIBERNATE mode, so the WDT will be locked after wakeup from these modes.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CNT</name>
          <description>Watchdog Counter Count Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter.  The write feature of this register is for engineering use (DfV), have no synchronization, and can only be applied when the WDT is fully off.  When writing, the value is updated immediately in the WDT counter, but it will read back as the old value until this register resynchronizes just after the negedge of ILO.  Writes will be ignored if they occur when the WDT is enabled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Counter Match Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_BITS</name>
              <description>The number of MSB bits of the watchdog timer that are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  Up to 12 MSB can be ignored.  Settings &gt;12 behave like a setting of 12.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>64</dimIncrement>
          <name>MCWDT_STRUCT[%s]</name>
          <description>Multi-Counter Watchdog Timer</description>
          <headerStructName>MCWDT_STRUCT</headerStructName>
          <addressOffset>0x00000200</addressOffset>
          <register>
            <name>MCWDT_CNTLOW</name>
            <description>Multi-Counter Watchdog Sub-counters 0/1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR0</name>
                <description>Current value of sub-counter 0 for this MCWDT.  Software writes are ignored when the sub-counter is enabled.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CTR1</name>
                <description>Current value of sub-counter 1 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CNTHIGH</name>
            <description>Multi-Counter Watchdog Sub-counter 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR2</name>
                <description>Current value of sub-counter 2 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_MATCH</name>
            <description>Multi-Counter Watchdog Counter Match Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MATCH0</name>
                <description>Match value for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1</name>
                <description>Match value for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CONFIG</name>
            <description>Multi-Counter Watchdog Counter Configuration</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F010F0F</resetMask>
            <fields>
              <field>
                <name>WDT_MODE0</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR0=WDT_MATCH0).</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR0</name>
                <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH0 is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE0_1</name>
                <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE1</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR1=WDT_MATCH1).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR1</name>
                <description>Clear Watchdog Counter when WDT_CTR1==WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH1 is 1.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE1_2</name>
                <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE2</name>
                <description>Watchdog Counter 2 Mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Free running counter with no interrupt requests</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Free running counter with interrupt request that occurs one LFCLK cycle after the specified bit in CTR2 toggles (see WDT_BITS2).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_BITS2</name>
                <description>Bit to observe for WDT_INT2:
0: Assert after bit0 of WDT_CTR2 toggles (one int every tick)
...
31: Assert after bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CTL</name>
            <description>Multi-Counter Watchdog Counter Control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xB0B0B</resetMask>
            <fields>
              <field>
                <name>WDT_ENABLE0</name>
                <description>Enable subcounter 0.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED0</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to two LFCLK cycles.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET0</name>
                <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE1</name>
                <description>Enable subcounter 1.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED1</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to two LFCLK cycles.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET1</name>
                <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE2</name>
                <description>Enable subcounter 2.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED2</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to two LFCLK cycles.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET2</name>
                <description>Resets counter 2 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR</name>
            <description>Multi-Counter Watchdog Counter Interrupt Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE0=3.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE1=3.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE2=3.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_SET</name>
            <description>Multi-Counter Watchdog Counter Interrupt Set Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASK</name>
            <description>Multi-Counter Watchdog Counter Interrupt Mask Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Mask for sub-counter 0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Mask for sub-counter 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Mask for sub-counter 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASKED</name>
            <description>Multi-Counter Watchdog Counter Interrupt Masked Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOCK</name>
            <description>Multi-Counter Watchdog Counter Lock Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC0000000</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.  LFCLK settings are locked by the global WDT_LOCK register, and this register has no effect on that.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_PATH_SELECT register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_PATH_SELECT[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0 (can be configured for FLL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Selects predivider value for this clock root and DSI input.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF03</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, it works in DEEPSLEEP and higher modes.  Does not work in HIBERNATE mode.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following: 
1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.  
2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.  
3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TIMER_CTL</name>
          <description>Timer Clock Control Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70000</resetValue>
          <resetMask>0x80FF0301</resetMask>
          <fields>
            <field>
              <name>TIMER_SEL</name>
              <description>Select source for TIMERCLK.  The output of this mux can be further divided using TIMER_DIV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal Main Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HF0_DIV</name>
                  <description>Select the output of the predivider configured by TIMER_HF0_DIV.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_HF0_DIV</name>
              <description>Predivider used when HF0_DIV is selected in TIMER_SEL.  If HFCLK0 frequency is less than 100MHz and has approximately 50 percent duty cycle, then no division is required (NO_DIV).  Otherwise, select a divide ratio of 2, 4, or 8 before selected HF0_DIV as the timer clock.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing or correcting duty cycle.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide HFCLK0 by 2.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide HFCLK0 by 4.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide HFCLK0 by 8.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_DIV</name>
              <description>Divide selected timer clock source by (1+TIMER_DIV).  The output of this divider is TIMERCLK  Allows for integer divisions in the range [1, 256].  Do not change this setting while the timer is enabled.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for TIMERCLK.
0: TIMERCLK is off
1: TIMERCLK is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that ILO should stay enabled for use by backup domain during XRES, HIBERNATE mode, and through power-related resets like BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: ILO turns off at XRES/BOD event or HIBERNATE entry.
1: ILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  After enabling, it takes at most two cycles to reach the accuracy spec.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during HIBERNATE and XRES.  It will automatically disable during DEEPSLEEP if CLK_MFO_CONFIG.DPSLP_ENABLE==0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.  0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.  0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast clock output #0 (see CLK_OUTPUT_FAST). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete.  A stalled counter can be recovered by selecting valid clocks, waiting until the measurement completes, and discarding the first result.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast clock output  #1 (see CLK_OUTPUT_FAST). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x80000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by ECO_TRIM0.ATRIM.  When low, the amplitude is not explicitly controlled and can be as high as the vddd supply.  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has had enough time to fully stabilize.  This is the output of a counter since ECO was enabled, and it does not check the ECO output.  It is recommended to also confirm ECO_OK==1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x53C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xE00003FF</resetMask>
          <fields>
            <field>
              <name>PILO_FFREQ</name>
              <description>Fine frequency trim allowing +/-250ppm accuracy with periodic calibration.  The nominal step size of the LSB is 8Hz.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_CLK_EN</name>
              <description>Enable the PILO clock output.  See PILO_EN field for required sequencing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RESET_N</name>
              <description>Reset the PILO.  See PILO_EN field for required sequencing.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  When enabling PILO, set PILO_EN=1, wait 1ms, then PILO_RESET_N=1 and PILO_CLK_EN=1.  When disabling PILO, clear PILO_EN=0, PILO_RESET_N=0, and PLO_CLK_EN=0 in the same write cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MF_SELECT</name>
          <description>Medium Frequency Clock Select Register</description>
          <addressOffset>0x544</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF07</resetMask>
          <fields>
            <field>
              <name>MFCLK_SEL</name>
              <description>Select source for MFCLK (clk_mf).  Note that not all products support all clock sources.  Selecting a clock source that is not supported results in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MFO</name>
                  <description>MFO - medium frequency oscillator</description>
                  <value>0</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFCLK_DIV</name>
              <description>Divide selected clock source by (1+MFCLK_DIV).  The output of this divider is MFCLK (clk_mf).  Allows for integer divisions in the range [1, 256].  Do not change this setting while ENABLE==1.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for MFCLK (clk_mf).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_MFO_CONFIG</name>
          <description>MFO Configuration Register</description>
          <addressOffset>0x548</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DPSLP_ENABLE</name>
              <description>Enable for MFO during DEEPSLEEP.  This bit is ignored when ENABLE==0.  When ENABLE==1:
0: MFO is automatically disabled during DEEPSLEEP and enables upon wakeup;
1: MFO is kept enabled throughout DEEPSLEEP</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for MFO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  The FLL requires firmware sequencing when enabling, disabling, and entering/exiting DEEPSLEEP.

To enable the FLL, first enable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=1 and wait until CLK_FLL_STATUS.CCO_READY==1.  Next, ensure the reference clock has stabilized and CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF.  Next, write FLL_ENABLE=1 and wait until CLK_FLL_STATUS.LOCKED==1.  Finally, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_OUT to switch to the FLL output.  It takes seven reference clock cycles plus four FLL output cycles to switch to the FLL output.  Do not disable the FLL before this time completes.

To disable the FLL, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF and (optionally) read the same register to ensure the write completes.  Then, wait at least seven FLL reference clock cycles before disabling it with FLL_ENABLE=0.  Lastly, disable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=0.

Before entering DEEPSLEEP, either disable the FLL using above sequence or use the following procedure to deselect/select it before/after DEEPSLEEP.  Before entering DEEPSLEEP, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF to change the FLL to use its reference clock.  After DEEPSLEEP wakeup, wait until CLK_FLL_STATUS.LOCKED==1 and then write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_OUT to switch to the FLL output.

0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0x1FF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or to track a less accurate source.  The tolerance should be set so that the FLL does not unlock under normal conditions.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
511: tolerate error of 512 count values</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Gain Setting #1.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Gain Setting #2.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  See FLL_ENABLE description for instructions on how to use this field when enabling/disabling the FLL.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x58C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x590</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator.  LOCKED is high when FLL is within CLK_FLL_CONFIG2.LOCK_TOL.  If FLL is outside LOCK_TOL, LOCKED goes low.  Note that this can happen during normal operation, if FLL needs to recalculate due to a change in the reference clock, change in voltage, or change in temperature.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xB81F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>Same as AUTO</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  To disable the PLL, first deselect it using .BYPASS_SEL=PLL_REF, wait at least six PLL clock cycles, and then disable it with .ENABLE=0.

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  W1C also feeds the watch dog.  Missing 2 interrupts in a row will generate a reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Set interrupt for low voltage detector WDT_MATCH</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.  When WDT resets the chip, it also internally pends an interrupt that survives the reset.  To prevent unintended ISR execution, clear SRSS_INTR.WDT_MATCH before setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x70C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_CFG</name>
          <description>SRSS Interrupt Configuration Register</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an IRQ for HVLVD1</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>Fault logging system requested a reset from its Active logic.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>Fault logging system requested a reset from its DeepSleep logic.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_WCO_LOSS</name>
              <description>Clock supervision logic requested a reset due to loss of a watch-crystal clock.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>Multi-Counter Watchdog timer reset #0 has occurred since last power cycle.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>Multi-Counter Watchdog timer reset #1 has occurred since last power cycle.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2 has occurred since last power cycle.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3 has occurred since last power cycle.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF_LOSS</name>
              <description>Clock supervision logic requested a reset due to loss of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_HF_FREQ</name>
              <description>Clock supervision logic requested a reset due to frequency error of high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_REF_CTL</name>
          <description>Reference Trim Register</description>
          <addressOffset>0x7F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70F00000</resetValue>
          <resetMask>0xF1FF5FFF</resetMask>
          <fields>
            <field>
              <name>ACT_REF_TCTRIM</name>
              <description>Active-Reference temperature trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_ITRIM</name>
              <description>Active-Reference current trim.   This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_ABSTRIM</name>
              <description>Active-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_IBOOST</name>
              <description>Active-Reference current boost.   This register is only reset by XRES/POR/BOD/HIBERNATE.
0: normal operation
others: risk mitigation</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_TCTRIM</name>
              <description>DeepSleep-Reference temperature trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_ABSTRIM</name>
              <description>DeepSleep-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_ITRIM</name>
              <description>DeepSleep current reference trim.   This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_BODOVP_CTL</name>
          <description>BOD/OVP Trim Register</description>
          <addressOffset>0x7F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40D04</resetValue>
          <resetMask>0xFDFF7</resetMask>
          <fields>
            <field>
              <name>HVPORBOD_TRIPSEL</name>
              <description>HVPORBOD trip point selection.  Monitors vddd.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVPORBOD_OFSTRIM</name>
              <description>HVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVPORBOD_ITRIM</name>
              <description>HVPORBOD current trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[9:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_TRIPSEL</name>
              <description>LVPORBOD trip point selection.  Monitors vccd.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[12:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_OFSTRIM</name>
              <description>LVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[16:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_ITRIM</name>
              <description>LVPORBOD current trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_CCO_CTL</name>
          <description>CCO Trim Register</description>
          <addressOffset>0x7F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA7000020</resetValue>
          <resetMask>0xBF00003F</resetMask>
          <fields>
            <field>
              <name>CCO_RCSTRIM</name>
              <description>CCO reference current source trim.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_STABLE_CNT</name>
              <description>Terminal count for the stabilization counter from CCO_ENABLE until stable.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_CNT</name>
              <description>Enables the automatic stabilization counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_CCO_CTL2</name>
          <description>CCO Trim Register 2</description>
          <addressOffset>0x7F0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x884110</resetValue>
          <resetMask>0x1FFFFFF</resetMask>
          <fields>
            <field>
              <name>CCO_FCTRIM1</name>
              <description>CCO frequency 1st range calibration</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM2</name>
              <description>CCO frequency 2nd range calibration</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM3</name>
              <description>CCO frequency 3rd range calibration</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM4</name>
              <description>CCO frequency 4th range calibration</description>
              <bitRange>[19:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM5</name>
              <description>CCO frequency 5th range calibration</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_WAKE_CTL</name>
          <description>Wakeup Trim Register</description>
          <addressOffset>0x7F30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>WAKE_DELAY</name>
              <description>Wakeup holdoff.  Spec (fastest) wake time is achieved with a setting of 0.  Additional delay can be added for debugging or workaround.  The delay is counted by the IMO.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_LVD_CTL</name>
          <description>LVD Trim Register</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OFSTRIM</name>
              <description>HVLVD1 offset trim</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_ITRIM</name>
              <description>HVLVD1 current trim</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO_CTL</name>
          <description>ILO Trim Register</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ILO_FTRIM</name>
              <description>ILO frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x17</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ACT_REG_TRIM</name>
              <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES/POR/BOD/HIBERNATE.  The nominal output voltage is vccd=812.5mV + ACT_REG_TRIM*12.5mV.  The actual output voltage will vary depending on conditions and load.  The following settings are explicitly shown for convenience, and other values may be calculated using the formula:
5'h07: 900mV (nominal)
5'h17: 1100mV (nominal)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REG_BOOST</name>
              <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
2'b00: 50uA
2'b01: 100uA
2'b10: 150uA
2'b11: 200uA

The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
50mA chip: 2'b00 (default);
100mA chip: 2'b00 (default);
150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);

This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ECO_CTL</name>
          <description>ECO Trim Register</description>
          <addressOffset>0xFF20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F0003</resetValue>
          <resetMask>0x3F3FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below steady state level
0x0 - 50mV
0x1 - 75mV
0x2 - 100mV
0x3 - 125mV
0x4 - 150mV
0x5 - 175mV
0x6 - 200mV
0x7 - 225mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 150mV
0x1 - 175mV
0x2 - 200mV
0x3 - 225mV
0x4 - 250mV
0x5 - 275mV
0x6 - 300mV
0x7 - 325mV
0x8 - 350mV
0x9 - 375mV
0xA - 400mV
0xB - 425mV
0xC - 450mV
0xD - 475mV
0xE - 500mV
0xF - 525mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITRIM</name>
              <description>Current Trim</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL</name>
          <description>PILO Trim Register</description>
          <addressOffset>0xFF24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108500F</resetValue>
          <resetMask>0x7DFF703F</resetMask>
          <fields>
            <field>
              <name>PILO_CFREQ</name>
              <description>Coarse frequency trim to meet 32.768kHz +/-2 percent across PVT without calibration.  The nominal step size of the LSB is 1kHz.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_OSC_TRIM</name>
              <description>Trim for current in oscillator block.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_COMP_TRIM</name>
              <description>Trim for comparator bias current.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_NBIAS_TRIM</name>
              <description>Trim for biasn by trimming sub-Vth NMOS width in beta-multiplier</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RES_TRIM</name>
              <description>Trim for beta-multiplier branch current</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_ISLOPE_TRIM</name>
              <description>Trim for beta-multiplier current slope</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_VTDIFF_TRIM</name>
              <description>Trim for VT-DIFF output (internal power supply)</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL2</name>
          <description>PILO Trim Register 2</description>
          <addressOffset>0xFF28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xDA10E0</resetValue>
          <resetMask>0xFF1FFF</resetMask>
          <fields>
            <field>
              <name>PILO_VREF_TRIM</name>
              <description>Trim for voltage reference</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREFBM_TRIM</name>
              <description>Trim for beta-multiplier current reference</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREF_TRIM</name>
              <description>Trim for current reference</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL3</name>
          <description>PILO Trim Register 3</description>
          <addressOffset>0xFF2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4800</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PILO_ENGOPT</name>
              <description>Engineering options for PILO circuits
0: Short vdda to vpwr
1: Beta:mult current change
2: Iref generation Ptat current addition
3: Disable current path in secondary Beta:mult startup circuit
4: Double oscillator current
5: Switch between deep:sub:threshold and sub:threshold stacks in Vref generation block
6: Spare
7: Ptat component increase in Iref
8: vpwr_rc and vpwr_dig_rc shorting testmode
9: Switch b/w psub connection for cascode nfet for vref generation
10: Switch between sub:threshold and deep:sub:threshold stacks in comparator.
15-11: Frequency fine trim.  See AKK-444 for an overview of the trim strategy.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACKUP</name>
      <description>SRSS Backup Domain</description>
      <baseAddress>0x40270000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0F3308</resetMask>
          <fields>
            <field>
              <name>WCO_EN</name>
              <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.  Follow the procedure in BACKUP_RTC_RW to access this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock select for BAK clock</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-crystal oscillator input.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTBAK</name>
                  <description>This allows to use the LFCLK selection as an alternate backup domain clock.  Note that LFCLK is not available in all power modes, and clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WCO_BYPASS</name>
              <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDBAK_CTL</name>
              <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBACKUP_MEAS</name>
              <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled to 10 percent of vbackup, so it is within the supply range of the ADC.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CHARGE_KEY</name>
              <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_RW</name>
          <description>RTC Read Write register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>Read bit
When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE</name>
              <description>Write bit
Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set. 
The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers. 
Only user RTC registers that were written to will get copied, others will not be affected. 
When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CTL</name>
          <description>Oscillator calibration for absolute frequency</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>CALIB_VAL</name>
              <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)).
Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field)

Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_SIGN</name>
              <description>Calibration sign:
0= Negative sign: remove pulses (it takes more clock ticks to count one second)
1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_OUT</name>
              <description>Output enable for 512Hz signal for calibration and allow CALIB_VAL to be written. Note that calibration does not affect the 512Hz output signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x5</resetMask>
          <fields>
            <field>
              <name>RTC_BUSY</name>
              <description>pending RTC write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WCO_OK</name>
              <description>Indicates that output has transitioned.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TIME</name>
          <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77F7F7F</resetMask>
          <fields>
            <field>
              <name>RTC_SEC</name>
              <description>Calendar seconds in BCD, 0-59</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MIN</name>
              <description>Calendar minutes in BCD, 0-59</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_HOUR</name>
              <description>Calendar hours in BCD, value depending on 12/24HR mode
0=24HR: [21:16]=0-23
1=12HR: [21]:0=AM, 1=PM, [20:16]=1-12</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_12HR</name>
              <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_DAY</name>
              <description>Calendar Day of the week in BCD, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DATE</name>
          <description>Calendar Day of Month, Month,  Year</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF1F3F</resetMask>
          <fields>
            <field>
              <name>RTC_DATE</name>
              <description>Calendar Day of the Month in BCD, 1-31
Automatic Leap Year Correction</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MON</name>
              <description>Calendar Month in BCD, 1-12</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_YEAR</name>
              <description>Calendar year in BCD, 0-99</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_TIME</name>
          <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x87BFFFFF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds in BCD, 0-59</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes in BCD, 0-59</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours in BCD, value depending on 12/24HR mode
12HR: [5]:0=AM, 1=PM, [4:0]=1-12
24HR: [5:0]=0-23</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week in BCD, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_DATE</name>
          <description>Alarm 1 Day of Month, Month</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80009FBF</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month in BCD, 1-31
Leap Year corrected</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month in BCD, 1-12</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 1.
0: Alarm 1 is disabled.  Fields for date and time are ignored.
1: Alarm 1 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_TIME</name>
          <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x87BFFFFF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds in BCD, 0-59</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes in BCD, 0-59</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours in BCD, value depending on 12/24HR mode
12HR: [5]:0=AM, 1=PM, [4:0]=1-12
24HR: [5:0]=0-23</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week in BCD, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_DATE</name>
          <description>Alarm 2 Day of Month, Month</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80009FBF</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month in BCD, 1-31
Leap Year corrected</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month in BCD, 1-12</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 2.
0: Alarm 2 is disabled.  Fields for date and time are ignored.
1: Alarm 2 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Alarm 1 Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Alarm 2 Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Century overflow interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSCCNT</name>
          <description>32kHz oscillator counter</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT32KHZ</name>
              <description>32kHz oscillator count (msb=128Hz), calibration can cause bit 6 to skip.  Reset when RTC_TIME.RTC_SEC fields is written.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TICKS</name>
          <description>128Hz tick counter</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CNT128HZ</name>
              <description>128Hz counter (msb=2Hz)
When SECONDS is written this field will be reset.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_CTL</name>
          <description>PMIC control register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0000000</resetValue>
          <resetMask>0xE001FF00</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for PMIC to be disabled.  When the UNLOCK code is not present: writes to PMIC_EN field are ignored and the hardware ignores the value in PMIC_EN.  Do not change PMIC_EN in the same write cycle as setting/clearing the UNLOCK code; do these in separate write cycles.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN_OUTEN</name>
              <description>Output enable for the output driver in the PMIC_EN pad.
0: Output pad is tristate for PMIC_EN pin.  This can allow this pin to be used for another purpose. Tristate condition is kept only if the UNLOCK key (0x3A) is present
1: Output pad is enabled for PMIC_EN pin.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_ALWAYSEN</name>
              <description>Override normal PMIC controls to prevent accidentally turning off the PMIC by errant firmware.
0: Normal operation, PMIC_EN and PMIC_OUTEN work as described
1: PMIC_EN and PMIC_OUTEN are ignored and the output pad is forced enabled.
Note: This bit is a write-once bit until the next backup reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable for external PMIC that supplies vddd (if present).  This bit will only clear if UNLOCK was written correctly in a previous write operation and PMIC_ALWAYSEN=0.  When PMIC_EN=0, the system functions normally until vddd is no longer present (OFF w/Backup mode).  Firmware can set this bit, if it does so before vddd is actually removed.  This bit is also set by any RTC alarm or PMIC pin wakeup event regardless of UNLOCK setting.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET</name>
          <description>Backup reset register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG[%s]</name>
          <description>Backup register region</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM</name>
          <description>Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>WCO trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>Datawire Controller</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x40280000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller. 
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present: 
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_SRC of the currently active descriptor.

Base address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_DST of the currently active descriptor.

Base address of destination location. 

Note: For a CRC transfer descriptor, this field should be programmed with the address of the CRC_LFSR_CTL register. The calculated CRC LFSR state is written to this address (through the CRYPTO AHB-Lite master interface) when the input trigger is processed. The write transfer will be submitted to the CPUSS and PERI protection schemes.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_X_CTL of the currently active descriptor.

[11:0] SRC_X_INCR
Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.

[23:12] DST_X_INCR
Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.

Note: this field is not used for CRC transfer descriptors and must be set to '0'.

[31:24] X_COUNT
Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For a single transfer descriptor type, descriptor will not have X_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_Y_CTL of the currently active descriptor.

[11:0] SRC_Y_INCR
Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[23:12] DST_Y_INCR
Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-2048, 2047].

[31:24] Y_COUNT
Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 255], representing 1 through 256 iterations.

For single, 1D and CRC transfer descriptor types, descriptor will not have Y_CTL.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.

[31:2] ADDR
Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>Current address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>Current address of destination location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE0003FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM word address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>32</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000300</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register;  i.e.  the 'write data' is ignored and instead the context is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, round robin arbitration is applied. Round robin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>Specifies if the channel is preemptable.
'0': Not preemptable.
'1': Preemptable. This field allows higher priority pending channels (from a higher priority group; i.e. an active channel can NOT be preempted by a pending channel in the same priority group) to preempt the active channel in between 'single transfers' (a 1D transfer consists out of X_COUNT single transfers; a 2D transfer consists out of X_COUNT*Y_COUNT single transfers). Preemption will NOT affect the pending status of channel. As a result, after completion of a higher priority activated channel, the current channel may be reactivated.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' on an error interrupt cause (the specific error is specified by CH_STATUS.INTR_CAUSE).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>Specifies the source of the interrupt cause:
'0': No interrupt generated
'1': Interrupt based on transfer complettion configuration based on INTR_TYPE
'2': Source transfer bus error
'3': Destination transfer bus error
'4': Source address misalignment
'5': Destination address misalignment
'6': Current descriptor pointer is null
'7': Active channel is disabled
'8': Descriptor bus error
'9'-'15': Not used.

For error related interrupt causes (INTR_CAUSE is '2', '3', ..., '8'), the channel is disabled (HW sets CH_CTL.ENABLED to '0').</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: Typically, when SW updates the current descriptor pointer CH_CURR_PTR, it also sets CH_IDX.X_IDX and CH_IDX.Y_IDX to '0'.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Set to '1', when event (as specified by CH_STATUS.INTR_CAUSE) is detected. Write INTR.CH field with '1', to clear bit. Write INTR_SET.CH field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR.CH field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DW0">
      <name>DW1</name>
      <baseAddress>0x40290000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC</description>
      <baseAddress>0x402A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTIVE</name>
          <description>Active channels</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Specifies active channels; i.e. enabled channels whose trigger got activated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>DMA controller channel</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x800003F7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group and within this priority group, the following 'roundrobin' arbitration is applied. 
A 'round' consists of a contiguous sequence of channel activations, within this priority group, without any repetition. Within a round, higher priority is given to the lower channel indices. The notion of a round guarantees that within a group, higher channel indices do not yield to lower indices indefinitely.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' when an error interrupt cause is activated.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>Y</name>
                <description>Specifies the Y loop index, with Y_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor..</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRC</name>
            <description>Channel current source address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DST</name>
            <description>Channel current destination address</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channle software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_STATUS</name>
            <description>Channel descriptor status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>Indicates whether the descriptor information present in DESCR_CTL, DESCR_SRC, DESCR_DST, DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE, DESCR_Y_INCR, DESCR_NEXT status registers is valid or not.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_CTL</name>
            <description>Channel descriptor control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>Specifies whether the controller should wait for the input trigger to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller with the agent that generated the trigger. This field is ONLY used at the completion of the transfer as specified by TR_IN. E.g., a TX FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the controller AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW controller performance.
'0': Do not wait for trigger de-activation (for pulse sensitive triggers).
'1': Wait for up to 4 cycles.
'2': Wait for up to 16 cycles.
'3': Wait indefinitely. This option may result in controller lockup if the trigger is not de-activated.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTR_TYPE</name>
                <description>Specifies when a completion interrupt is generated (CH_STATUS.INTR_CAUSE is set to COMPLETION):
'0': An interrupt is generated after a single transfer. 
'1': An interrupt is generated after a single 1D transfer or a memory copy transfer
- If the descriptor type is 'single', the interrupt is generated after a single transfer.
- If the descriptor type is '1D' or '2D', the interrupt is generated after the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the interrupt is generated after the execution of a memory copy transfer.
- If the descriptor type is 'scatter' the interrupt is generated after the execution of a scatter transfer.
'2': An interrupt is generated after the execution of the current descriptor (independent of the value of DESCR_NEXT_PTR.ADDR of the current descriptor).
'3': An interrupt is generated after the execution of the current descriptor and the current descriptor's DESCR_NEXT_PTR.ADDR is '0'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_OUT_TYPE</name>
                <description>Specifies when an output trigger is generated:
'0': An output trigger is generated after a single transfer. 
'1': An output trigger is generated after a single 1D transfer or a memory copy transfer.
- If the descriptor type is 'single', the output trigger is generated after a single transfer.
- If the descriptor type is '1D' or '2D', the output trigger is generated after the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the output trigger is generated after the execution of a memory copy transfer.
- If the descriptor type is 'scatter', the output trigger is generated after the execution of a scatter transfer.
'2': An output trigger is generated after the execution of the current descriptor. 
'3': An output trigger is generated after the execution of a descriptor list: after the execution of the current descriptor AND the current descriptor's DESCR_NEXT_PTR.ADDR is '0'.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_IN_TYPE</name>
                <description>Specifies the input trigger type (not to be confused with the descriptor type):
'0': A trigger results in the execution of a single transfer. The descriptor type can be single, 1D or 2D.
'1': A trigger results in the execution of a single 1D transfer.
- If the descriptor type is 'single', the trigger results in the execution of a single transfer.
- If the descriptor type is '1D' or '2D', the trigger results in the execution of a 1D transfer.
- If the descriptor type is 'memory copy', the trigger results in the execution of a memory copy transfer.
- If the descriptor type is 'scatter', the trigger results in the execution of an scatter transfer.
'2': A trigger results in the execution of the current descriptor. 
'3': A trigger results in the execution of the current descriptor and continues (without requiring another input trigger) with the execution of the next descriptor using the next descriptor's information.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_PREFETCH</name>
                <description>Source data prefetch:
'0': No source data prefetch. Source data transfers are only initiated AFTER the input trigger is activated.
'1': Source data prefetch. Source data transfers are initiated as soon as the channel is enabled, the current descriptor pointer is NOT '0' and there is space available in the channel's data FIFO. When the input trigger is activated, the trigger can initiate destination data transfers with data that is already in the channel's data FIFO. This effectively shortens the initial delay of the data transfer.

Note: data prefetch should be used with care, to ensure that data coherency is guaranteed and that prefetches do not cause undesired side effects.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>Specifies the data element size:
'0': Byte (8 bits).
'1': Halfword (16 bits).
'2': Word (32 bits).
DATA_SIZE, SRC_TRANSFER_SIZE and DST_TRANSFER_SIZE together determine how data elements are transferred. The following are the 9 legal settings:
- DATA is 8 bit, SRC is 8 bit, DST is 8 bit.
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 8 bit.
- DATA is 8 bit, SRC is 8 bit, DST is 32 bit (higher 24 bits are made '0').
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 32 bit (higher 24 bits are made '0').
- DATA is 16 bit, SRC is 16 bit, DST is 16 bit.
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 16 bit.
- DATA is 16 bit, SRC is 16 bit, DST is 32 bit (higher 16 bits are made '0').
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 32 bit (higher 16 bits are made '0').
- DATA is 32 bit, SRC is 32 bit, DST is 32 bit.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '2' for a 'initialization' descriptor type.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_DISABLE</name>
                <description>Specifies whether the channel is disabled or not after completion of the current descriptor (independent of the value of the DESCR_NEXT_PTR value):
'0': Channel is not disabled.
'1': Channel is disabled.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the source location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for source components with data elements that are smaller than their 32-bit bus interface width. E.g., an ADC source has a 32-bit bus transfer size, but only provides a 16-bit data element.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '1' for a 'scatter' descriptor type.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the destination location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for destination components with data elements that are smaller than their 32-bit bus interface width. E.g., a DAC destination has a 32-bit bus transfer size, but only requires a 16-bit data element.

Note: this field is not used for a 'memory copy' descriptor type. Note: this field must be set to '1' for a 'scatter' descriptor type.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_TYPE</name>
                <description>Specifies the descriptor type (not to be confused with the trigger type):
'0': Single transfer.
The DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR registers are NOT present. The DESCR_NEXT_PTR is at offset 0x0c.
'1': 1D transfer.
The DESCR_X_SIZE and DESCR_X_INCR registers are present, the DESCR_Y_SIZE and DESCR_Y_INCR are NOT present. A 1D transfer consists out of DESCR_X_SIZE.X_COUNT+1 single transfers. The DESCR_NEXT_PTR is at offset 0x14.
'2': 2D transfer.
The DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR registers are present. A 2D transfer consists of (DESCR_X_SIZE.X_COUNT+1)*(DESCR_Y_SIZE.Y_COUNT+1) single transfers. The DESCR_NEXT_PTR is at offset 0x1c.
'3': Memory copy.
The DESCR_X_SIZE register is present, the DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR are NOT present. A memory copy transfer copies DESCR_X_SIZE.X_COUNT+1 Bytes and may use Byte, halfword and word transfers. The DESCR_NEXT_PTR is at offset 0x10.
'4': Scatter transfer. The DESCR_X_SIZE register is present, the DESCR_DST, DESCR_X_INCR, DESCR_Y_SIZE and DESCR_Y_INCR are NOT present.
'5'-'7': Undefined.

After the execution of the current descriptor, the DESCR_NEXT_PTR address is copied to the channel's CH_CURR_PTR address and CH_STATUS.X_IDX and CH_STATUS.Y_IDX are set to '0'.</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_SRC</name>
            <description>Channel descriptor source</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_DST</name>
            <description>Channel descriptor destination</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_SIZE</name>
            <description>Channel descriptor X size</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_COUNT</name>
                <description>Number of iterations (minus 1) of the 'X loop' (X_COUNT+1 is the number of single transfers in a 1D transfer). This field is an unsigned number in the range [0, 65535], representing 1 through 65536 iterations.

For the 'memory copy' descriptor type, (X_COUNT + 1) is the number of transferred Bytes. For the 'scatter' descriptor type, ceiling(X_COUNT/2) is the number of (address, write data) initialization pairs processed.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_INCR</name>
            <description>Channel descriptor X increment</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_X</name>
                <description>Specifies increment of source address for each X loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number (sign-magnitude format) in the range [-32768, 32767]. If this field is '0', the source address is not incremented. This is useful for reading from RX FIFO structures.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_X</name>
                <description>Specifies increment of destination address for each X loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number (sign-magnitude format) in the range [-32768, 32767]. If this field is '0', the destination address is not incremented. This is useful for writing to TX FIFO structures.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_SIZE</name>
            <description>Channel descriptor Y size</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>Y_COUNT</name>
                <description>Number of iterations (minus 1) of the 'Y loop' (X_COUNT+1)*(Y_COUNT+1) is the number of single transfers in a 2D transfer). This field is an unsigned number in the range [0, 65535], representing 1 through 65536 iterations.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_INCR</name>
            <description>Channel descriptor Y increment</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_Y</name>
                <description>Specifies increment of source address for each Y loop iteration (in multiples of SRC_TRANSFER_SIZE). This field is a signed number in the range [-32768, 32767].</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_Y</name>
                <description>Specifies increment of destination address for each Y loop iteration (in multiples of DST_TRANSFER_SIZE). This field is a signed number in the range [-32768, 32767].</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_NEXT</name>
            <description>Channel descriptor next pointer</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of next descriptor in descriptor list. When this field is '0', this is the last descriptor in the descriptor list.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Activated (set to '1') on completion of data transfer(s) as specified by the descriptor's CH_DESCR_CTL.INTR_TYPE.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load from the source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a store to the destination.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the source address.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the destination address.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Activated (set to '1') when the channel is enabled (CH_CTL.ENABLED is '1') and CH_CURR_PTR is '0'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Activated (set to '1') if the channel is disabled by SW (accidentally/incorrectly) when the data transfer engine is busy.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load of the descriptor.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Write this field with '1' to set INTR.COMPLETION field to '1' (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.SRC_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.DST_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Write this field with '1' to set INTR.SRC_MISAL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Write this field with '1' to set INTR.DST_MISAL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Write this field with '1' to set INTR.CURR_PTR_NULL field to '1' (a write of '0' has no effect).</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Write this field with '1' to set INTR.ACT_CH_DISABLED field to '1' (a write of '0' has no effect).</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Write this field with '1' to set INTR.DESCR_BUS_ERROR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Mask for INTR.COMPLETION interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Mask for INTR.SRC_BUS_ERROR interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Mask for INTR.DST_BUS_ERROR interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Mask for INTR.SRC_MISAL interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Mask for INTR.DST_MISAL interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Mask for INTR.CURR_PTR_NULL interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Mask for INTR.ACTIVE_CH_DISABLED interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Mask for INTR.DESCR_BUS_ERROR interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Logical and of corresponding INTR.COMPLETION and INTR_MASK.COMPLETION fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.SRC_BUS_ERROR and INTR_MASK.SRC_BUS_ERROR fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.DST_BUS_ERROR and INTR_MASK.DST_BUS_ERROR fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Logical and of corresponding INTR.SRC_MISAL and INTR_MASK.SRC_MISAL fields.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Logical and of corresponding INTR.DST_MISAL and INTR_MASK.DST_MISAL fields.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Logical and of corresponding INTR.CURR_PTR_NULL and INTR_MASK.CURR_PTR_NULL fields.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Logical and of corresponding INTR.ACTIVE_CH_DISABLED and INTR_MASK.ACTIVE_CH_DISABLED fields.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Logical and of corresponding INTR.DESCR_BUS_ERROR and INTR_MASK.DESCR_BUS_ERROR fields.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x402C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields. This bit is a don't care for the MXS40 Macro.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540003</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x220020</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310005</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80350006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x803D0019</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>15</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pin 0 route.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pin 1 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pin 2 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pin 3 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pin 4 route.
See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pin 5 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pin 6 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pin 7 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALT_JTAG_EN</name>
          <description>Alternate JTAG IF selection register</description>
          <addressOffset>0x2240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Provides the selection for alternate JTAG IF connectivity.
0: Primary JTAG interface is selected
1: Secondary (alternate) JTAG interface is selected.

This connectivity works ONLY in ACTIVE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40310000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>15</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.
On reset assertion , IN register will get reset. The Pad value takes 2 clock cycles to be reflected into IN Register.  It's value then depends on the external pin value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Weak/resistive pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull up
   D_OUT = '1': Weak/resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Weak/resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': High Impedance
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': High Impedance
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = '0':
    GPIO_DSI_OUT = '0': Weak/resistive pull down
    GPIO_DSI_OUT = '1': Weak/resistive pull up
where 'GPIO_DSI_OUT' is a function of PORT_SEL, OUT &amp; DSI_DATA_OUT.

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
    D_OUT = '0': Weak/resistive pull down
    D_OUT = '1': Weak/resistive pull up</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>Configures the pin 0 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>PSoC 6:: Input buffer compatible with CMOS and I2C interfaces
Traveo II: Full encoding is shown in CFG_IN_AUTOLVL.VTRIP_SEL0_1</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>PSoC 6:: Input buffer compatible with TTL and MediaLB interfaces
Traveo II: full encoding is shown in CFG_IN_AUTOLVL.VTRIP_SEL0_1</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>Configures the pin 1 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>Configures the pin 2 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>Configures the pin 3 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>Configures the pin 4 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>Configures the pin 5 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>Configures the pin 6 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>Configures the pin 7 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ZERO</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: Full drive strengh: GPIO drives current at its max rated spec.
Traveo II:_GPIO_SMC: GPIO_SMC default mode.
Traveo II:_HSIO_STD: HSIO default mode.
PSoC 6: GPIO cells and HSIO_STD cells: Full drive strength: GPIO drives current at its max rated spec.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ONE</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: Full drive strengh: GPIO drives current at its max rated spec.
Traveo II:_GPIO_SMC: GPIO full drive strength.
Traveo II:_HSIO_STD: GPIO full drive strength.
PSoC 6: GPIO cells and HSIO_STD cells: 1/2 drive strength: GPIO drives current at 1/2 of its max rated spec</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_TWO</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: 1/2 drive strength: GPIO drives current at 1/2 of its max rated spec.
Traveo II:_GPIO_SMC: GPIO 1/2 drive strength.
Traveo II:_HSIO_STD: GPIO 1/2 drive strength.
PSoC 6: GPIO cells and HSIO_STD cells: 1/4 drive strength. GPIO drives current at 1/4 of its max rated spec.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_THREE</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
Traveo II:_GPIO_SMC: GPIO 1/4 drive strength.
Traveo II:_HSIO_STD: GPIO 1/4 drive strength.
PSoC 6: GPIO cells and HSIO_STD cells: 1/8 drive strength. GPIO drives current at 1/8 of its max rated spec.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>Selects the output buffer mode:
'0': Unregulated output buffer
'1': Regulated output buffer
The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode. If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>Selects the input buffer mode:
0: Singled ended input buffer
1: Differential input buffer</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>Selects the input buffer trip-point in single ended input buffer mode (IBUF_SEL = '0'):
'0': Input buffer functions as a CMOS input buffer.
'1': Input buffer functions as a TTL input buffer.
In differential input buffer mode (IBUF_SEL = '1')
'0': Trip-point is 0.5*Vddio or 0.5*Voh (depends on VREF_SEL/VOH_SEL)
'1': Trip-point is 0.4*Vddio or 1.0*Vref  (depends on VREF_SEL)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>Selects reference voltage (Vref) trip-point of the input buffer:
'0': Trip-point reference from pin_ref
'1': Trip-point reference of SRSS internal reference Vref (1.2 V)
'2': Trip-point reference of AMUXBUS_A
'3': Trip-point reference of AMUXBUS_B</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects the regulated Voh output level and trip point of the input buffer for a specific SIO pin pair. Voh depends on the selected reference voltage (VREF_SEL). 
'0': Voh = 1*reference; e.g. reference at 1.2V -&gt; Voh = 1.2V 
'1': Voh = 1.25*reference; e.g. reference at 1.2V -&gt; Voh = 1.5V
'2': Voh = 1.49*reference; e.g. reference at 1.2V -&gt; Voh = ~1.8V
'3': Voh = 1.67*reference; e.g. reference at 1.2V -&gt; Voh = 2V
'4': Voh = 2.08*reference; e.g. reference at 1.2V -&gt; Voh = 2.5V
'5': Voh = 2.5*reference; e.g. reference at 1.2V -&gt; Voh = 3V
'6': Voh = 2.78*reference; e.g. reference at 1.2V -&gt; Voh = ~3.3V
'7': Voh = 4.16*reference; e.g. reference at 1.2V -&gt; Voh = 5.0V
Note: The upper value on Voh is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port input buffer AUTOLVL configuration register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for GPIO upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_AUTOLVL.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automotive.
1,1: input buffer is compatible with automotvie</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Input buffer compatible with AUTO (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE1</name>
          <description>Interrupt port cause register 1</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE2</name>
          <description>Interrupt port cause register 2</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE3</name>
          <description>Interrupt port cause register 3</description>
          <addressOffset>0x400C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x4010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup, 
1: vddio_0, 
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x4014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x4018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x401C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transition detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMARTIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40320000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>10</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed.
'0': No bypass (programmable SMARTIO fabric is exposed). 
'1': Bypass (programmable SMARTIOIO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality.  
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': asynchronous mode/'1'.  Select this when clockless operation is configured.

NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset).  In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The SMARTIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x40350000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>LPREF_EN</name>
              <description>Enable the local reference generator circuit to generate the local Vref and ibias. This bit must be set for DeepSleep or Hibernate operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: IP disabled (put analog in power down, open all switches, all clocks off, leakage power only)
- 1: IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>LPCOMP Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OUT0</name>
              <description>Current output value of the comparator 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator 1.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_CTRL</name>
          <description>Comparator 0 control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCE3</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP</name>
                  <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST0</name>
              <description>Add 30mV hysteresis to the comparator
0= Disable Hysteresis
1= Enable Hysteresis</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE0</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_BYPASS0</name>
              <description>Asynchronous: bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async).
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL0</name>
              <description>Synchronous comparator DSI (trigger) output  : 0=pulse, 1=level</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_SW</name>
          <description>Comparator 0 switch control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP0_IP0</name>
              <description>Comparator 0 positive terminal isolation switch to GPIO</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AP0</name>
              <description>Comparator 0 positive terminal  switch to amuxbusA</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BP0</name>
              <description>Comparator 0 positive terminal  switch to amuxbusB</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_IN0</name>
              <description>Comparator 0 negative terminal isolation switch to GPIO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AN0</name>
              <description>Comparator 0 negative terminal  switch to amuxbusA</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BN0</name>
              <description>Comparator 0 negative terminal  switch to amuxbusB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_VN0</name>
              <description>Comparator 0 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_SW_CLEAR</name>
          <description>Comparator 0 switch control clear</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP0_IP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_IN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_VN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_CTRL</name>
          <description>Comparator 1 control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCE3</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP</name>
                  <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add 30mV hysteresis to the comparator
0= Disable Hysteresis
1= Enable Hysteresis</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Asynchronous: bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async).
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Synchronous comparator DSI (trigger) output  : 0=pulse, 1=level</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_SW</name>
          <description>Comparator 1 switch control</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP1_IP1</name>
              <description>Comparator 1 positive terminal isolation switch to GPIO</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AP1</name>
              <description>Comparator 1 positive terminal  switch to amuxbusA</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BP1</name>
              <description>Comparator 1 positive terminal  switch to amuxbusB</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_IN1</name>
              <description>Comparator 1 negative terminal isolation switch to GPIO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AN1</name>
              <description>Comparator 1 negative terminal  switch to amuxbusA</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BN1</name>
              <description>Comparator 1 negative terminal  switch to amuxbusB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_VN1</name>
              <description>Comparator 1 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_SW_CLEAR</name>
          <description>Comparator 1 switch control clear</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP1_IP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_IN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_VN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CSD0</name>
      <description>Capsense Controller</description>
      <headerStructName>CSD</headerStructName>
      <baseAddress>0x40360000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration and Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4000000</resetValue>
          <resetMask>0xCF0E1DF1</resetMask>
          <fields>
            <field>
              <name>IREF_SEL</name>
              <description>Select Iref supply.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IREF_SRSS</name>
                  <description>select SRSS Iref (default)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_PASS</name>
                  <description>select PASS.AREF Iref, only available if PASS IP is on the chip.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTER_DELAY</name>
              <description>This value determines the number of cycles that the digital filter makes the CSDCMP output ignored while the counter counts and IDAC is on. 
When set to 0 the digital filter is off. When set to any other value the ignoring will last for FILTER_DELAY clk_csd cycles after the start of each measurement and from the first comparator trip to the end of each measurement.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SHIELD_DELAY</name>
              <description>Selects the delay by which csd_shield is delayed relative to csd_sense.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Delay line is off, csd_shield=csd_sense</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D5NS</name>
                  <description>Introduces a 5ns delay (typ)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D10NS</name>
                  <description>Introduces a 10ns delay (typ)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D20NS</name>
                  <description>Introduces a 20ns delay (typ)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SENSE_EN</name>
              <description>Enables the sense modulator output. 
0: all switches, static or dynamic, are open and IDAC in CSD mode is off
1: switches and IDAC can be closed/on as per MMIO setting and CSD sequencer.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_WAVE</name>
              <description>Enables full wave cap sensing mode</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALFWAVE</name>
                  <description>Half Wave mode (normal).
In this mode the comparator always trips in the same direction (positive or negative edge) and the same Vref, i.e. no polarity change.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FULLWAVE</name>
                  <description>Full Wave mode.
In this mode the comparator trips in opposite direction and with different Vref in each phase, i.e. the polarity flips.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MUTUAL_CAP</name>
              <description>Enables mutual cap sensing mode</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SELFCAP</name>
                  <description>Self-cap mode (configure sense line as CSD_SENSE)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MUTUALCAP</name>
                  <description>Mutual-cap mode (configure Tx line as CSD_SENSE, inverted Tx line as CSD_SHIELD and Rx Line as AMUXA). In this mode the polarity bit of the IDAC is controlled by csd_sense.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSX_DUAL_CNT</name>
              <description>Enable the use of two counters for MUTUAL cap sensing mode (CSX), do not use when MUTUAL_CAP=0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ONE</name>
                  <description>Use one counter for both phases (source and sink).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TWO</name>
                  <description>Use two counters, separate count for when csd_sense is high and when csd_sense is low.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_COUNT_SEL</name>
              <description>Select what to output  on the dsi_count bus.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CSD_RESULT</name>
                  <description>depending on the dsi_count_val_sel input either output  RESULT_VAL1.VALUE (0) or RESULT_VAL2.VALUE (1) on the dsi_count bus. Note that dsi_count_val_sel is not synchronized, i.e. it controls the mux combinatorially.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_RESULT</name>
                  <description>output ADC_RES.VIN_CNT on the dsi_count bus</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_SAMPLE_EN</name>
              <description>Enables the use of the dsi_sample_in input instead of the comparator output to strobe COUNTER.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_SYNC</name>
              <description>Enables double synchronizing of sample input from DSI (only relevant when DSI_SAMPLE_EN=1).</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SENSE_EN</name>
              <description>Enables the use of the dsi_sense_in input instead of the internally generated modulation signal to drive csd_sense and csd_shield signals.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>Select the power mode for the CSD components (REFGEN, AMBUF, CSDCMP, HSCMP):
0: High Power mode
1: Low Power mode</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable of the CSDv2 IP.  Must be set to 1 for any CSDv2, ADC or IDAC operation to function.
When 0 all analog components will be off and all switches will be open.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPARE</name>
          <description>Spare MMIO</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>Spare MMIO</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE</resetMask>
          <fields>
            <field>
              <name>CSD_SENSE</name>
              <description>Signal used to drive the Cs switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HSCMP_OUT</name>
              <description>Output of reference buffer comparator used to charge up Cmod and/or Csh_tank (synchronized)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>C_LT_VREF</name>
                  <description>Vin &lt; Vref</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>C_GT_VREF</name>
                  <description>Vin &gt; Vref</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSDCMP_OUT</name>
              <description>Output of main sensing comparator (synchronized)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_SEQ</name>
          <description>Current Sequencer status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>SEQ_STATE</name>
              <description>CSD sequencer state</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_STATE</name>
              <description>ADC sequencer state (only relevant after SEQ_STATE has reached SAMPLE_NORM and ADC sequencer has started)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_CNTS</name>
          <description>Current status counts</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_CONV</name>
              <description>Current number of conversions remaining when in Sample_* states (note that in AutoZero* states the same down counter is reused to count the cycles)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_HCNT</name>
          <description>Current count of the HSCMP counter</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Current value of HSCMP counter</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VAL1</name>
          <description>Result CSD/CSX accumulation counter value 1</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Accumulated counter value for this result. In case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt) this counter counts when csd_sense is high.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAD_CONVS</name>
              <description>Number of 'bad' conversion for which the CSD comparator did not trigger within the normal time window, either because Vref was not crossed at all, or if the Vref was already crossed before the window started. This counter is reset when the sequencer is started and will saturate at 255 when more than 255 conversions are bad.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VAL2</name>
          <description>Result CSX accumulation counter value 2</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Only used in case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt), this counter counts when csd_sense is low.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RES</name>
          <description>ADC measurement</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC001FFFF</resetMask>
          <fields>
            <field>
              <name>VIN_CNT</name>
              <description>Count to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HSCMP_POL</name>
              <description>Polarity used for IDACB for this last ADC result, 0= source, 1= sink</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_OVERFLOW</name>
              <description>This flag is set when the ADC counter overflows. This is an indication to the firmware that the IDACB current level is too low.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_ABORT</name>
              <description>This flag is set when the ADC sequencer was aborted before tripping HSCMP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>CSD Interrupt Request Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>A normal sample is complete</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Coarse initialization complete or Sample initialization complete (the latter is typically ignored)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>ADC Result ready</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>CSD Interrupt set register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>CSD Interrupt mask register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>CSD Interrupt masked register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSCMP</name>
          <description>High Speed Comparator configuration</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000011</resetMask>
          <fields>
            <field>
              <name>HSCMP_EN</name>
              <description>High Speed Comparator enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable comparator, output is zero</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSCMP_INVERT</name>
              <description>Invert the HSCMP output before it is used to control switches and the CSD sequencer. This bit does not affect the ADC sequencer or the STATUS.HSCMP_OUT</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ_EN</name>
              <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AMBUF</name>
          <description>Reference Generator configuration</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Amux buffer power level</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable buffer</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORM</name>
                  <description>On, normal or low power level depending on CONFIG.LP_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HI</name>
                  <description>On, high or low power level depending on CONFIG.LP_MODE.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>REFGEN</name>
          <description>Reference Generator configuration</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F1F71</resetMask>
          <fields>
            <field>
              <name>REFGEN_EN</name>
              <description>Reference Generator Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable Reference Generator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYPASS</name>
              <description>Bypass selected input reference unbuffered to Vrefhi</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_EN</name>
              <description>Close Vdda switch to top of resistor string (or Vrefhi?)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_EN</name>
              <description>Resistor string enable; 0= open switch on top of the resistor string (Vreflo=Vssa)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN</name>
              <description>Select resistor string tap for feedback, 0= minimum vout, 31= maximum vout = vrefhi -&gt; gain=1  (only works if the resistor string is enabled; RES_EN=1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFLO_SEL</name>
              <description>Select resistor string tap for Vreflo/Vreflo_int, 0= minimum vout, 31= maximum vout = vrefhi (only works if the resistor string is enabled; RES_EN=1)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFLO_INT</name>
              <description>Ouput the resistor string tap either to Vreflo (0) or Vreflo_int (1).</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSDCMP</name>
          <description>CSD Comparator configuration</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB0000331</resetMask>
          <fields>
            <field>
              <name>CSDCMP_EN</name>
              <description>CSD Comparator Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable comparator, output is zero</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY_SEL</name>
              <description>Select which IDAC polarity to use to detect CSDCMP triggering</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDACA_POL</name>
                  <description>Use idaca_pol (firmware setting with CSX and optionally DSI mixed in) to determine the direction, this is the most common use-case, used for normal CSD and normal CSX</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDACB_POL</name>
                  <description>Use idacb_pol (firmware setting with optional DSI mixed in) to determine the direction, this is only used for normal CSD if IDACB is used i.s.o. IDACA (not common)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUAL_POL</name>
                  <description>Use the expression (csd_sense ? idaca_pol : idacb_pol)  to determine the direction, this is only useful for the CSX with DUAL_IDAC use-case</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_PHASE</name>
              <description>Select in what phase(s) the comparator is active, typically set to match the BAL_MODE of the used IDAC. Note, this also determines when a bad conversion is detected, namely at the beginning and end of the comparator active phase (also taking into account FILTER_DELAY and non-overlap).</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>Comparator is active from start of Phi2 and kept active into Phi1. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>Comparator is active during Phi1 only. Currently no known use-case.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>Comparator is active during Phi2 only. Intended usage: CSD Low EMI.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>Comparator is activated at the start of both Phi1 and Phi2 (non-overlap should be enabled). Intended usage: CSX, or Full-Wave.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_MODE</name>
              <description>Select which signal to output on dsi_sample_out.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD mode: output the filtered sample signal on dsi_sample_out</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose mode: output the unfiltered sample unfiltered comparator output, either asynchronous or flopped.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FEEDBACK_MODE</name>
              <description>This bit controls whether the output directly from the comparator (csdcmp_out) or the flopped version (csdcmp_out_ff) is used. For CSD operation, the selected signal controls the IDAC(s), in GP mode the signal goes out on dsi_sample_out.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FLOP</name>
                  <description>Use feedback from sampling flip-flop (used in most modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP</name>
                  <description>Use feedback from comparator directly (used in single Cmod mutual cap sensing only)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AZ_EN</name>
              <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_RES</name>
          <description>Switch Resistance configuration</description>
          <addressOffset>0x1F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF00FF</resetMask>
          <fields>
            <field>
              <name>RES_HCAV</name>
              <description>Select resistance or low EMI (slow ramp) for the HCAV switch</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOWEMI</name>
                  <description>Low EMI (slow ramp: 3 switches closed by fixed delay line)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_HCAG</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_HCBV</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_HCBG</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_F1PM</name>
              <description>Select resistance for the corresponding  switch</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_F2PT</name>
              <description>Select resistance for the corresponding  switch</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_PERIOD</name>
          <description>Sense clock period</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC000000</resetValue>
          <resetMask>0xFF70FFF</resetMask>
          <fields>
            <field>
              <name>SENSE_DIV</name>
              <description>The length-1 of the Sense modulation 'clock' period in clk_csd cycles. For regular CSD one sense clock cycle = one conversion (=phi1+phi2) .
Note this is the base divider, clock dithering may change the actual period length.
Note that SENSE_DIV must be at least 1 and additionally also allow for one clk_hf of non overlap (if OVERLAP_HI1/2 is set) on both phases, i.e. if clk_csd=clk_hf then SENSE_DIV must be &gt;=3.
In addition the FILTER_DELAY needs to be added to the minimum allowed SENSE_DIV value.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_SIZE</name>
              <description>Selects the length of the LFSR which determines the LFSR repeat period. LFSR_BITS LSB of the LFSR are used  for the clock dithering variation on the base period (was PRS in CSDv1). Whenever the LFSR is used (non zero value in this field) the LFSR_CLEAR bit should also be set.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Don't use clock dithering (=spreadspectrum) (LFSR output value is zero)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6B</name>
                  <description>6-bit LFSR (G(x)=X^6  +X^4+X^3+    X+1, period= 63)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7B</name>
                  <description>7-bit LFSR (G(x)=X^7  +X^4+X^3+X^2+1, period= 127)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>9B</name>
                  <description>9-bit LFSR (G(x)=X^9  +X^4+X^3+    X+1, period= 511)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10B</name>
                  <description>10-bit LFSR (G(x)=X^10+X^4+X^3+    X+1, period= 1023)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8B</name>
                  <description>8-bit LFSR (G(x)=X^8+X^4+X^3+X^2+1, period= 255)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>12B</name>
                  <description>12-bit LFSR (G(x)=X^12+X^7+X^4+X^3+1, period= 4095)</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE</name>
              <description>Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This dithering is disabled when SEL_LSFR_MSB is set.
The clock divider to be used = (SENSE_DIV+1) + (SEL_LSFR_MSB ? 0 : (LFSR_OUT&lt;&lt;LFSR_SCALE)).
Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_CLEAR</name>
              <description>When set, forces the LFSR to it's initial state (all ones).  This bit is automatically cleared by hardware after the LFSR is cleared, which is at the next clk_csd positive edge. This bit should be set whenever this register is written and the LFSR is used.
Note that the LFSR will also get reset to all ones during the AutoZero_1/2 states.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_LFSR_MSB</name>
              <description>Use the MSB of configured LSFR size as csd_sense signal. Intended to be used only with bit 8 or 12-bit LFSR size for CSDv1 backward compatibility (PRS). When this bit is set then clock divider dithering is disabled and SENSE_WIDTH is disabled.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_BITS</name>
              <description>Selects the number of LSB bits to use from the LSFR to provide the clock dithering variation on the base period.
Caveat make sure that SENSE_DIV &gt; the maximum absolute range (e.g. for 4B  SENSE_DIV &gt; 8), otherwise results are undefined.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2B</name>
                  <description>use 2 bits: range = [-2,1]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>3B</name>
                  <description>use 3 bits: range = [-4,3]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4B</name>
                  <description>use 4 bits: range = [-8,7]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5B</name>
                  <description>use 5 bits: range = [-16,15] (default)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_DUTY</name>
          <description>Sense clock duty cycle</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0FFF</resetMask>
          <fields>
            <field>
              <name>SENSE_WIDTH</name>
              <description>Defines the length of the first phase of the sense clock in clk_csd cycles. 
A value of 0 disables this feature and the duty cycle of csd_sense will be 50 percent, which is equal to SENSE_WIDTH = (SENSE_DIV+1)/2, or when clock dithering is used that becomes [(SENSE_DIV+1) + (LFSR_OUT &lt;&lt; LSFR_SCALE)]/2.  At all times it must be assured that the phases are at least 2 clk_csd cycles (1 for non overlap, if used), if this rule is violated the result is undefined.
Note that this feature is not available when SEL_LFSR_MSB (PRS) is selected.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_POL</name>
              <description>Polarity of the sense clock
0 = start with low phase (typical for regular negative transfer CSD)
1 = start with high phase</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP_PHI1</name>
              <description>NonOverlap or not for Phi1 (csd_sense=0).
0 = Non-overlap for Phi1, the Phi1 signal is  csd_sense inverted except that the signal goes low 1 clk_sample before csd_sense goes high. Intended usage: new low EMI CSD/CSX with static GPIO.
1 = 'Overlap' (= not non-overlap) for Phi1, the Phi1 signal is  csd_sense inverted. Intended usage: legacy CSD with GPIO switching, the GPIO internal circuit ensures that the switches are non-overlapping.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP_PHI2</name>
              <description>Same as OVERLAP_PHI1 but for Phi2 (csd_sense=1).</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_HS_P_SEL</name>
          <description>HSCMP Pos input switch Waveform selection</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11111111</resetMask>
          <fields>
            <field>
              <name>SW_HMPM</name>
              <description>Set HMPM switch
0: static open
1: static closed</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMPT</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMPS</name>
              <description>Set corresponding switch</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMMA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMCA</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMRH</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_HS_N_SEL</name>
          <description>HSCMP Neg input switch Waveform selection</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77110000</resetMask>
          <fields>
            <field>
              <name>SW_HCCC</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCD</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCRH</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCRL</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SHIELD_SEL</name>
          <description>Shielding switches Waveform selection</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x117777</resetMask>
          <fields>
            <field>
              <name>SW_HCAV</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCAG</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCBV</name>
              <description>N/A</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCBG</name>
              <description>Select waveform for corresponding switch, using csd_shield as base</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCV</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCG</name>
              <description>Set corresponding switch
If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_AMUXBUF_SEL</name>
          <description>Amuxbuffer switches Waveform selection</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11171110</resetMask>
          <fields>
            <field>
              <name>SW_IRBY</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRLB</name>
              <description>Set corresponding switch</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ICA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ICB</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRLI</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRH</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRL</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_BYP_SEL</name>
          <description>AMUXBUS bypass switches Waveform selection</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x111000</resetMask>
          <fields>
            <field>
              <name>SW_BYA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_BYB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CBCC</name>
              <description>Set corresponding switch
If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_CMP_P_SEL</name>
          <description>CSDCMP Pos Switch Waveform selection</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1111777</resetMask>
          <fields>
            <field>
              <name>SW_SFPM</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFPT</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFPS</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFMA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFCA</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_CMP_N_SEL</name>
          <description>CSDCMP Neg Switch Waveform selection</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77000000</resetMask>
          <fields>
            <field>
              <name>SW_SCRH</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SCRL</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_REFGEN_SEL</name>
          <description>Reference Generator Switch Waveform selection</description>
          <addressOffset>0x2A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11110011</resetMask>
          <fields>
            <field>
              <name>SW_IAIB</name>
              <description>Set corresponding switch</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IBCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGRP</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGRE</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGR</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_FW_MOD_SEL</name>
          <description>Full Wave Cmod Switch Waveform selection</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11170701</resetMask>
          <fields>
            <field>
              <name>SW_F1PM</name>
              <description>Set corresponding switch</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F1MA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F1CA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1CC</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1CD</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1F1</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_FW_TANK_SEL</name>
          <description>Full Wave Csh_tank Switch Waveform selection</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11177710</resetMask>
          <fields>
            <field>
              <name>SW_F2PT</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2MA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2CA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2CB</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2CC</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2CD</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2F2</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_DSI_SEL</name>
          <description>DSI output switch control Waveform selection</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DSI_CSH_TANK</name>
              <description>Select waveform for dsi_csh_tank output signal
0: static open
1: static closed
2: phi1
3: phi2
4: phi1 &amp; HSCMP
5: phi2 &amp; HSCMP
6: HSCMP                       // ignores phi1/2
7: !sense                        // = phi1 but ignores OVERLAP_PHI1

8: phi1_delay              // phi1 delayed with shield delay
9: phi2_delay              // phi2 delayed with shield delay

10: !phi1
11: !phi2
12: !(phi1 &amp; HSCMP)
13: !(phi2 &amp; HSCMP)
14: !HSCMP                   // ignores phi1/2
15: sense                       // = phi2 but ignores OVERLAP_PHI2</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_CMOD</name>
              <description>Select waveform for dsi_cmod output signal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IO_SEL</name>
          <description>IO output control Waveform selection</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF0FF</resetMask>
          <fields>
            <field>
              <name>CSD_TX_OUT</name>
              <description>Select waveform for csd_tx_out output signal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_OUT_EN</name>
              <description>Select waveform for csd_tx_out_en output signal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_AMUXB_EN</name>
              <description>Select waveform for csd_tx_amuxb_en output signal</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_N_OUT</name>
              <description>Select waveform for csd_tx_n_out output signal</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_N_OUT_EN</name>
              <description>Select waveform for csd_tx_n_out_en output signal</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_N_AMUXA_EN</name>
              <description>Select waveform for csd_tx_n_amuxa_en output signal</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_TIME</name>
          <description>Sequencer Timing</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AZ_TIME</name>
              <description>Define Auto-Zero time in csd_sense cycles -1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_INIT_CNT</name>
          <description>Sequencer Initial conversion and sample counts</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CONV_CNT</name>
              <description>Number of conversion per Initialization sample, if set to 0 the Sample_init state will be skipped.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_NORM_CNT</name>
          <description>Sequencer Normal conversion and sample counts</description>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CONV_CNT</name>
              <description>Number of conversion per sample, if set to 0 the Sample_norm state will be skipped.
Sample window size = SEQ_NORM_CNT.CONV_CNT * (SENSE_PERIOD.SENSE_DIV+1).
Note for CSDv1 Sample window size = PERIOD</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTL</name>
          <description>ADC Control</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>ADC_TIME</name>
              <description>ADC timing -1 in csd_sense clock cycles (actual time is ADC_TIME+1 cycles), either used to discharge Cref1&amp;2, or as the aperture to capture the input voltage on Cref1&amp;2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_MODE</name>
              <description>Enable ADC measurement. When enabled the ADC sequencer will be started when the main sequencer goes to the SAMPLE_NORM state</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>No ADC measurement</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_CNT</name>
                  <description>Count time A to bring Cref1 + Cref2 up from Vssa to Vrefhi with IDACB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_BY2_CNT</name>
                  <description>Count time B to bring Cref1 + Cref2 back up to Vrefhi with IDACB (after bringing them down for time A/2 cycles with IDACB sinking)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIN_CNT</name>
                  <description>Determine HSCMP polarity and count time C to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_START</name>
          <description>Sequencer start</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31B</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>Start the CSD sequencer. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when a sample has been accumulated, when the high speed comparator trips or if the sequencer is aborted. When the ADC is enabled the ADC sequencer will start when the CSD sequencer reaches the Sample_norm state (only with the regular CSD scan mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_MODE</name>
              <description>0 = regular CSD scan + optional ADC 
1 = coarse initialization, the Sequencer will go to the INIT_COARSE state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>When a 1 is written the CSD and ADC sequencers will be aborted (if they are running) and the START bit will be cleared. This bit always read as 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_START_EN</name>
              <description>When this bit is set a positive edge on dsi_start will start the CSD sequencer and if enabled also the ADC sequencer.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ0_SKIP</name>
              <description>When set the AutoZero_0 state will be skipped</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ1_SKIP</name>
              <description>When set the AutoZero_1 state will be skipped</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDACA</name>
          <description>IDACA Configuration</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3EF0FFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>Current value setting for this IDAC (7 bits).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_DYN</name>
              <description>Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STATIC</name>
                  <description>Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DYNAMIC</name>
                  <description>Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_MODE==CSD also mixed with the CSD configuration and operation. However in mutual cap mode with one IDAC (config.mutual_cap=1 &amp; config.csx_dual_idac=0) the polarity of the IDAC is controlled by csd_sense.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_SRC</name>
                  <description>Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_SNK</name>
                  <description>Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE</name>
                  <description>The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_INV</name>
                  <description>The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BAL_MODE</name>
              <description>Balancing mode: only applies to legs configured as CSD.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>enabled from start of Phi2 until disabled by CSDCMP. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>enabled from start of Phi1 and disabled by CSDCMP or at end of Phi1. Enables dual IDAC CSX or Full-Wave, one for sourcing and the other for sinking.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>enabled from start of Phi2 and disabled by CSDCMP or at end of Phi2. Intended usage: CSD Low EMI or  dual IDAC CSX or Full-Wave.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>enabled from start of both Phi1 and Phi2 and disabled by CSDCMP or at end of Phi1 or Phi2 (if non-overlap enabled). Intended usage: single IDAC CSX, or Full-Wave.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_MODE</name>
              <description>Controls the usage mode of LEG1 and the Polarity bit</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>General Purpose static mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose dynamic mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>CSD static mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG1 is controlled by LEG1_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD dynamic mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In thoses states LEG1 is controlled by LEG1_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG2_MODE</name>
              <description>Controls the usage mode of LEG2</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>General Purpose static mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN).  No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose dynamic mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>CSD static mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg2 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD dynamic mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). In addition leg2 enable can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_CTRL_EN</name>
              <description>Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled).
0: no DSI control 
     IDACA_POLARITY = IDACA.POLARITY 
     IDACA_LEG1_EN =  IDACA.LEG1_EN 
     IDACA_LEG2_EN = IDACA.LEG2_EN   
1: Mix MMIO with DSI control
     IDACA_POLARITY = IDACA.POLARITY EXOR dsi_idaca_pol
     IDACA_LEG1_EN =  IDACA.LEG1_EN AND dsi_idaca_leg1_en 
     IDACA_LEG2_EN = IDACA.LEG2_EN AND dsi_idaca_leg2_en</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE</name>
              <description>IDAC multiplier</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDAC_LO</name>
                  <description>1 LSB =   37.5 nA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_MED</name>
                  <description>1 LSB =  300 nA</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_HI</name>
                  <description>1 LSB = 2400 nA</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_EN</name>
              <description>output enable for leg 1 to CSDBUSA</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG2_EN</name>
              <description>output enable for leg 2 to CSDBUSA</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDACB</name>
          <description>IDACB Configuration</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7EF0FFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>Current value setting for this IDAC (7 bits).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_DYN</name>
              <description>Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STATIC</name>
                  <description>Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DYNAMIC</name>
                  <description>Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_EN==1 and LEG1_MODE==CSD also mixed with the CSD configuration and operation. In mutual cap mode however (see config.mutual_cap) the polarity of the IDAC is controlled by csd_sense. If LEG3_EN=1 (the other two legs must be off) then the ADC sequencer controls the IDACB polarity, optionally mixed with DSI.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_SRC</name>
                  <description>Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_SNK</name>
                  <description>Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE</name>
                  <description>The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_INV</name>
                  <description>The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BAL_MODE</name>
              <description>same as corresponding IDACA Balancing mode</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_MODE</name>
              <description>Controls the usage mode of LEG1 and the Polarity bit</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG2_MODE</name>
              <description>Controls the usage mode of LEG2</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_CTRL_EN</name>
              <description>Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled)
0: no DSI control
     IDACB_POLARITY = IDACB.POLARITY 
     IDACB_LEG1_EN =  IDACB.LEG1_EN 
     IDACB_LEG2_EN = IDACB.LEG2_EN   
     IDACB_LEG3_EN = IDACB.LEG3_EN   
1: Mix MMIO with DSI control
     IDACB_POLARITY = IDACB.POLARITY EXOR dsi_idacb_pol
     IDACB_LEG1_EN =  IDACB.LEG1_EN AND dsi_idacb_leg1_en 
     IDACB_LEG2_EN = IDACB.LEG2_EN AND dsi_idacb_leg2_en  
     IDACB_LEG3_EN = IDACB.LEG3_EN AND dsi_idacb_leg3_en</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE</name>
              <description>IDAC multiplier</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDAC_LO</name>
                  <description>1 LSB =   37.5 nA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_MED</name>
                  <description>1 LSB =  300 nA</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_HI</name>
                  <description>1 LSB = 2400 nA</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_EN</name>
              <description>output enable for leg 1 to CSDBUSB or CSDBUSA</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG2_EN</name>
              <description>output enable for leg 2 to CSDBUSB or CSDBUSA</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG3_EN</name>
              <description>output enable for leg3 to CSDBUSC, only allowed when RANGE = IDAC_LO. When this bit is set both other legs should be off.
Note that leg3 can only be used for ADC mode, not GP mode. Which means that leg3 can only be on when the ADC Sequencer is in the ADC_measure or Calib_measure state. In those states  leg3 is controlled by the ADC configuration and the HSCMP output. In addition this leg3 enable bit can optionally be mixed with DSI (see DSI_CTRL_EN).
When LEG3_EN=1 also the IDACB polarity is controlled by the ADC sequencer.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x40380000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>32768</dimIncrement>
          <name>GRP[%s]</name>
          <description>Group of counters</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <dim>8</dim>
            <dimIncrement>128</dimIncrement>
            <name>CNT[%s]</name>
            <description>Timer/Counter/PWM Counter Module</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CTRL</name>
              <description>Counter control register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xF0</resetValue>
              <resetMask>0xC73737FF</resetMask>
              <fields>
                <field>
                  <name>AUTO_RELOAD_CC0</name>
                  <description>Specifies switching of the CC0 and buffered CC0 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 0 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_CC1</name>
                  <description>Specifies switching of the CC1 and buffered CC1 values. This field has a function in TIMER, QUAD (QUAD_RANGE0_CMP, QUAD_RANGE1_CMP range modes), SR, PWM, PWM_DT and PWM_PR modes.
Timer, QUAD, SR modes:
'0': never switch.
'1': switch on a compare match 1 event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_PERIOD</name>
                  <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM and PWM_DT modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.

In QUAD mode, QUAD_RANGE0_CMP range mode this field is used to select the index / wrap-around capture function.
'0': Captures on index (reload) event. The counter value is copied to the PERIOD register on an index (reload) event.
'1': Captures when COUNTER equals 0 or 0xffff. The counter value is copied to the PERIOD register when COUNTER equals 0 or 0xffff.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AUTO_RELOAD_LINE_SEL</name>
                  <description>Specifies switching of the LINE_SEL and LINE_BUFF_SEL values. This field has a function in PWM and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting up
'1': compare match 0 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 0 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 0 event generation disabled when counting down
'1': compare match 0 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_UP_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting up (STATUS.DOWN = 0) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting up
'1': compare match 1 event generation enabled when counting up

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH_DOWN_EN</name>
                  <description>Enables / disables the compare match 1 event generation (COUNTER equals CC0 register) when counting down (STATUS.DOWN = 1) in CNT_UPDN1/2 mode.
'0': compare match 1 event generation disabled when counting down
'1': compare match 1 event generation enabled when counting down

This field has a function in PWM and PWM_DT modes only.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_IMM_KILL</name>
                  <description>Specifies whether the kill event immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals or with the next module clock ('active count' pre-scaled 'clk_counter').
'0': synchronous kill activation. Deactivates the 'dt_line_out' and 'dt_line_compl_out' signals with the next module clock ('active count' pre-scaled 'clk_counter').
'1': immediate kill activation. Immediately deactivates the 'dt_line_out' and 'dt_line_compl_out' signals.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_STOP_ON_KILL</name>
                  <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_SYNC_KILL</name>
                  <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PWM_DISABLE_MODE</name>
                  <description>Specifies the behavior of the PWM outputs 'line_out' and 'line_compl_out' while the TCPWM counter is disabled (CTL.ENABLED='0') or stopped.

Note: The output signal of this selection can be further modified by the immediate kill logic and line_out polarity settings (CTRL.QUAD_ENCODING_MODE).</description>
                  <bitRange>[13:12]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The behavior is the same is in previous mxtcpwm (version 1).

When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are NOT driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).
Note: This is realized by driving the TCPWM output 'line_out_en' to 0.

When the counter is stopped upon a stop event the PWM outputs are deactivated (to the polarity defined by CTL.QUAD_ENCODING_MODE).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RETAIN</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM.
When the counter is disabled or stopped upon a stop event the PWM outputs are retained (keep their previous levels). 
While the counter is disabled or stopped the PWM outputs can be changed via LINE_SEL (when parameter GRP_SMC_PRESENT = 1).</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>L</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '0' and the PWM output 'line_compl_out' is driven as a fixed '1'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>When the counter is disabled the PWM outputs 'line_out' and 'line_compl_out' are driven by the TCPWM. 
When the counter is disabled or stopped upon a stop event the PWM output 'line_out' is driven as a fixed '1' and the PWM output 'line_compl_out' is driven as a fixed '0'.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UP_DOWN_MODE</name>
                  <description>Determines counter direction.

In QUAD mode this field acts as QUAD_RANGE_MODE field selecting between different counter range, reload value and compare / capture behavior.</description>
                  <bitRange>[17:16]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>COUNT_UP</name>
                      <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_DOWN</name>
                      <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN1</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>COUNT_UPDN2</name>
                      <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>ONE_SHOT</name>
                  <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>QUAD_ENCODING_MODE</name>
                  <description>In QUAD mode this field selects the quadrature encoding mode (X1/X2/X4) or the Up / Down rotary counting mode.
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUAD_ENCODING_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUAD_ENCODING_MODE[1].</description>
                  <bitRange>[21:20]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>X1</name>
                      <description>X1 encoding (QUAD mode)
This encoding is identical with an up / down counting functionality of the following way: Rising edges of input phiA increment or decrement the counter depending on the state of input phiB (direction input).</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X2</name>
                      <description>X2 encoding (QUAD mode)</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>X4</name>
                      <description>X4 encoding (QUAD mode)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UP_DOWN</name>
                      <description>Up / Down rotary counting mode. Input phiA increments the counter, input phiB decrements the counter. The trigger edge detection settings apply.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>MODE</name>
                  <description>Counter mode.</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>TIMER</name>
                      <description>Timer mode</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD1</name>
                      <description>N/A</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CAPTURE</name>
                      <description>Capture mode</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>QUAD</name>
                      <description>Quadrature mode

Different encoding modes can be selected by QUAD_ENCODING_MODE including up/down count functionality.
Different counter range, reload value and capture behavior can be selected by QUAD_RANGE_MODE (overloaded field UP_DOWN_MODE).</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>Pulse width modulation (PWM) mode</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_DT</name>
                      <description>PWM with deadtime insertion mode</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_PR</name>
                      <description>Pseudo random pulse width modulation</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>SR</name>
                      <description>Shift register mode.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>DBG_FREEZE_EN</name>
                  <description>Specifies the counter behavior in debug mode.
'0': The counter operation continues in debug mode.
'1': The counter operation freezes in debug mode.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Counter enable.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_IN_SEL, TR_IN_EDGE_SEL, TR_PWM_CTRL and TR_OUT_SEL register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_out0' and tr_out1').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>STATUS</name>
              <description>Counter status register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x20</resetValue>
              <resetMask>0xFFFF8FF1</resetMask>
              <fields>
                <field>
                  <name>DOWN</name>
                  <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE0</name>
                  <description>Indicates the actual level of the selected capture 0 trigger.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_COUNT</name>
                  <description>Indicates the actual level of the selected count trigger.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_RELOAD</name>
                  <description>Indicates the actual level of the selected reload trigger.</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_STOP</name>
                  <description>Indicates the actual level of the selected stop trigger.</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_START</name>
                  <description>Indicates the actual level of the selected start trigger.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TR_CAPTURE1</name>
                  <description>Indicates the actual level of the selected capture 1 trigger.</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_OUT</name>
                  <description>Indicates the actual level of the PWM line output signal.</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>LINE_COMPL_OUT</name>
                  <description>Indicates the actual level of the complementary PWM line output signal.</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RUNNING</name>
                  <description>When '0', the counter is NOT running. When '1', the counter is running. 

This field is used to indicate that the counter is running after a start/reload event and that the counter is stopped after a stop event.
When a running counter operation is paused in debug state (see CTRL.DBG_PAUSE) then the RUNNING bit is still '1'.</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_L</name>
                  <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion (8bit dead time counter or low byte of 16-bit dead time counter). 
In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DT_CNT_H</name>
                  <description>High byte of 16-bit dead time counter. In PWM_DT mode, this counter is used for dead time insertion.
In all other modes, this field has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8bit wide and the only the field DT_CNT_L is used as dead time counter.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>COUNTER</name>
              <description>Counter count register</description>
              <addressOffset>0x8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>COUNTER</name>
                  <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0</name>
              <description>Counter compare/capture 0 register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC0_BUFF</name>
              <description>Counter buffered compare/capture 0 register</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1</name>
              <description>Counter compare/capture 1 register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CC1_BUFF</name>
              <description>Counter buffered compare/capture 1 register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CC</name>
                  <description>Additional buffer for counter CC1 register.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD</name>
              <description>Counter period register</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PERIOD_BUFF</name>
              <description>Counter buffered period register</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFFFFFF</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>PERIOD</name>
                  <description>Additional buffer for counter PERIOD register.

In PWM_PR mode PEROD_BUFF defines the LFSR polynomial. Each bit represents a tap of the shift register which can be feed back to the MSB via an XOR tree. 
Examples for GRP_CNT_WIDTH = 16: 
- Maximum length 16bit LFSR
  - polynomial x^16 + x^14 + x^13 + x^11 + 1
  - taps 0,2,3,5 -&gt; PERIOD = 0x002d
  - period is 2^16-1 = 65535 cycles
- Maximum length 8bit LFSR: 
  - polynomial x^8 + x^6 + x^5 + x^4 + 1
  - taps 8,10,11,12 (realized in 8 MSBs of 16bit LFSR)
  - period is 2^8-1 = 255 cycles

In SR mode PERIOD_BUFF defines which tap of the shift register generates the PWM output signals. For a delay of n cycles (from capture event to PWM output) the bit CNT_WIDTH-n should be set to '1'. For a shift register function only one tap should be use, i.e. a one-hot value must be written to PERIOD_BUFF. If multiple bits in PERIOD_BUFF are set then the taps are XOR combined.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL</name>
              <description>Counter line selection register</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_out'. Default setting is the PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_out polarity setting (CTRL.QUAD_ENCODING_MODE[0]).</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Selects the source for the output signal 'line_compl_out'. Default setting is the inverted PWM signal 'line'. Other settings are useful for Stepper Motor Control.
This field has a function in PWM and PWM_PR modes only.

Note: The output signal of this selection can be further modified by the stop / kill logic and line_compl_out polarity setting (CTRL.QUAD_ENCODING_MODE[1]).</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>L</name>
                      <description>fixed '0'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>H</name>
                      <description>fixed '1'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM</name>
                      <description>PWM signal 'line'</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>PWM_INV</name>
                      <description>inverted PWM signal 'line'</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Z</name>
                      <description>The output 'line_compl_out' is not driven by the TCPWM. Instead the port default level configuration applies, e.g. 'Z' (high impedance).

Note: This is realized by driving the output 'line_compl_out_en' to 0.</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD5</name>
                      <description>N/A</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD7</name>
                      <description>N/A</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>LINE_SEL_BUFF</name>
              <description>Counter buffered line selection register</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT_SEL</name>
                  <description>Buffer for LINE_SEL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COMPL_OUT_SEL</name>
                  <description>Buffer for LINE_SEL.COMPL.OUT_SEL.
Can be exchanged with LINE_SEL.LINE_COMPL_OUT_SEL on a terminal count event with an actively pending switch event.

This field has a function in PWM and PWM_PR modes only.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DT</name>
              <description>Counter PWM dead time register</description>
              <addressOffset>0x30</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DT_LINE_OUT_L</name>
                  <description>In PWM_DT mode, this field is used to determine the low byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain. 
In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.

Note: This field determines the low byte of the 16-bit dead time before activating 'line_out' when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by this DT_LINE_OUT_L field is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_OUT_H</name>
                  <description>In PWM_DT mode, this field is used to determine the high byte of the dead time before activating the PWM line output signal 'line_out': amount of dead time cycles in the counter clock domain.
In all other modes, this field  has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DT_LINE_COMPL_OUT</name>
                  <description>In PWM_DT mode, this field is used to determine the dead time before activating the complementary PWM line output signal 'line_compl_out': amount of dead time cycles in the counter clock domain. 
In all other modes, this field  has no effect.

Note: This field only exists when parameter GRP_AMC_PRESENT for advanced motor control is set to 1. Otherwise the dead time is only 8 bit wide and the same dead time specified by field DT_LINE_OUT_L is used before activating 'line_out' and 'line_compl_out'.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_CMD</name>
              <description>Counter trigger command register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3D</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0</name>
                  <description>SW capture 0 trigger. When written with '1', a capture 0 trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.ENABLED, the field is immediately set to '0'.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD</name>
                  <description>SW reload trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP</name>
                  <description>SW stop trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>START</name>
                  <description>SW start trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1</name>
                  <description>SW capture 1 trigger. For HW behavior, see COUNTER_CAPTURE0 field.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL0</name>
              <description>Counter input trigger selection register 0</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_SEL</name>
                  <description>Selects one of the up to 256 input triggers as a capture0 trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. If existing, the one-to-one trigger inputs 'tr_one_cnt_in' (different to each counter) are selected by setting 2 and above. The settings above are used for the general purpose trigger inputs 'tr_all_cnt_in' connected to all counters selected.
In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>COUNT_SEL</name>
                  <description>Selects one of the 256 input triggers as a count trigger. 
In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.

Note: In the modes: TIMER, CAPTURE, PWM, PWM_DT, and SR, If the counter is externally triggered ( COUNT_SEL &gt; 1), an external trigger will be required for each TR_CMD to execute. For example, a write to TR_CMD.START will not start the counter until the trigger selected by COUNT_SEL asserts. The next trigger will increment the counter since the counter is now running. This goes for all TR_CMD fields.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RELOAD_SEL</name>
                  <description>Selects one of the 256 input triggers as a reload trigger. 
In QUAD mode, this is the index or revolution pulse. In these modes, it will update the counter with 0x8000 (counter midpoint) or 0x0000 depending on the QUAD_RANGE_MODE.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>STOP_SEL</name>
                  <description>Selects one of the 256 input triggers as a stop trigger. 
In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                  <bitRange>[31:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_SEL1</name>
              <description>Counter input trigger selection register 1</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>START_SEL</name>
                  <description>Selects one of the 256 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAPTURE1_SEL</name>
                  <description>Selects one of the 256 input triggers as a capture 1 trigger.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_IN_EDGE_SEL</name>
              <description>Counter input trigger edge selection register</description>
              <addressOffset>0x4C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFF</resetValue>
              <resetMask>0xFFF</resetMask>
              <fields>
                <field>
                  <name>CAPTURE0_EDGE</name>
                  <description>A capture 0 event will copy the counter value into the CC0 register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>COUNT_EDGE</name>
                  <description>A counter event will increase or decrease the counter by '1'.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>RELOAD_EDGE</name>
                  <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>STOP_EDGE</name>
                  <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>START_EDGE</name>
                  <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                  <bitRange>[9:8]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CAPTURE1_EDGE</name>
                  <description>A capture 1 event will copy the counter value into the CC1 register.</description>
                  <bitRange>[11:10]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>RISING_EDGE</name>
                      <description>Rising edge. Any rising edge generates an event.</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>FALLING_EDGE</name>
                      <description>Falling edge. Any falling edge generates an event.</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>ANY_EDGE</name>
                      <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_EDGE_DET</name>
                      <description>No edge detection, use trigger as is.</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_PWM_CTRL</name>
              <description>Counter trigger PWM control register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFF</resetValue>
              <resetMask>0xFF</resetMask>
              <fields>
                <field>
                  <name>CC0_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 0 event (COUNTER equals CC0 register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC0 register should be set to '0'. For a 100 percent duty cycle, the counter CC0 register should be set to larger than the counter PERIOD register.</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OVERFLOW_MODE</name>
                  <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>UNDERFLOW_MODE</name>
                  <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>CC1_MATCH_MODE</name>
                  <description>Determines the effect of a compare match 1 event (COUNTER equals CC1 register) on the 'line_out' output signals.</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>SET</name>
                      <description>Set to '1'</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CLEAR</name>
                      <description>Set to '0'</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>INVERT</name>
                      <description>Invert</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>NO_CHANGE</name>
                      <description>No Change</description>
                      <value>3</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>TR_OUT_SEL</name>
              <description>Counter output trigger selection register</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x32</resetValue>
              <resetMask>0x77</resetMask>
              <fields>
                <field>
                  <name>OUT0</name>
                  <description>Selects one of the internal events to generate the output trigger 0. Default setting selects the terminal count event.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event (default selection)</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
                <field>
                  <name>OUT1</name>
                  <description>Selects one of the internal events to generate the output trigger 1. Default setting selects the compare match 0 event.</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                  <enumeratedValues>
                    <enumeratedValue>
                      <name>OVERFLOW</name>
                      <description>Overflow event</description>
                      <value>0</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>UNDERFLOW</name>
                      <description>Underflow event</description>
                      <value>1</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>TC</name>
                      <description>Terminal count event</description>
                      <value>2</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC0_MATCH</name>
                      <description>Compare match 0 event (default selection)</description>
                      <value>3</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>CC1_MATCH</name>
                      <description>Compare match 1 event</description>
                      <value>4</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>LINE_OUT</name>
                      <description>PWM output signal 'line_out'</description>
                      <value>5</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>RSVD6</name>
                      <description>N/A</description>
                      <value>6</value>
                    </enumeratedValue>
                    <enumeratedValue>
                      <name>Disabled</name>
                      <description>Output trigger disabled.</description>
                      <value>7</value>
                    </enumeratedValue>
                  </enumeratedValues>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR</name>
              <description>Interrupt request register</description>
              <addressOffset>0x70</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Counter matches CC0 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Counter matches CC1 register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_SET</name>
              <description>Interrupt set request register</description>
              <addressOffset>0x74</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASK</name>
              <description>Interrupt mask register</description>
              <addressOffset>0x78</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Mask bit for corresponding bit in interrupt request register.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>INTR_MASKED</name>
              <description>Interrupt masked request register</description>
              <addressOffset>0x7C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TC</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC0_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC1_MATCH</name>
                  <description>Logical and of corresponding request and mask bits.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCD0</name>
      <description>LCD Controller Block</description>
      <headerStructName>LCD</headerStructName>
      <baseAddress>0x403B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x2F0F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LCD controller peripheral is 0xF0F0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0002</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIVIDER</name>
          <description>LCD Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBFR_DIV</name>
              <description>Input clock frequency divide value, to generate the 1/4 sub-frame period. The sub-frame period is  4*(SUBFR_DIV+1) cycles long.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_DIV</name>
              <description>Length of the dead time period in cycles.  When set to  zero, no dead time period exists.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONTROL</name>
          <description>LCD Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000FFF</resetMask>
          <fields>
            <field>
              <name>LS_EN</name>
              <description>Low speed (LS) generator enable
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_EN</name>
              <description>High speed (HS) generator enable
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD_MODE</name>
              <description>HS/LS Mode selection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LS</name>
                  <description>Select Low Speed Generator (Works in Active, Sleep and DeepSleep power modes). Low speed clock (clk_lf) or middle speed clock (clk_mf) can be selected for Low Speed Generator.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HS</name>
                  <description>Select High Speed (system clock) Generator (Works in Active and Sleep power modes only).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TYPE</name>
              <description>LCD driving waveform type configuration.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TYPE_A</name>
                  <description>Type A - Each frame addresses each COM pin only once with a balanced (DC=0) waveform.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TYPE_B</name>
                  <description>Type B - Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>Driving mode configuration</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <description>PWM Mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CORRELATION</name>
                  <description>Digital Correlation Mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIAS</name>
              <description>PWM bias selection</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALF</name>
                  <description>1/2 Bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD</name>
                  <description>1/3 Bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOURTH</name>
                  <description>1/4 Bias</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIFTH</name>
                  <description>1/5 Bias</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_LS_SEL</name>
              <description>Low speed (LS) generator clock source selection
1: select clk_mf
0: select clk_lf</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COM_NUM</name>
              <description>The number of COM connections minus 2. So:
0: 2 COM's
1: 3 COM's
...
13: 15 COM's
14: 16 COM's
15: undefined</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LS_EN_STAT</name>
              <description>LS enable status bit.  This bit is a copy of LS_EN that is synchronized to the low speed clock domain and back to the system clock domain. Firmware can use this bit to observe whether LS_EN has taken effect in the low speed clock domain.  Firmware should never change the configuration for the LS generator without ensuring this bit is 0.
The following procedure should be followed to disable the LS generator:
1. If LS_EN=0 we are done.  Exit the procedure.
2. Check that LS_EN_STAT=1.  If not, wait until it is. This will catch the case of a recent enable (LS_EN=1) that has not taken effect yet.
3. Set LS_EN=0.
4. Wait until LS_EN_STAT=0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA0[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA1[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA2[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA3[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBFS0</name>
      <description>USB Host and Device Controller</description>
      <headerStructName>USBFS</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>USBDEV</name>
          <description>USB Device</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>EP0_DR[%s]</name>
            <description>Control End point EP0 Data Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_BYTE</name>
                <description>This register is shared for both transmit and receive. The count in the EP0_CNT register determines the number of bytes received or to be transferred.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR0</name>
            <description>USB control 0 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DEVICE_ADDRESS</name>
                <description>These bits specify the USB device address to which the SIE will respond. This address must be set by firmware and is specified by the USB Host with a SET ADDRESS command during USB enumeration. This value must be programmed by firmware when assigned during enumeration. It is not set automatically by the hardware.
If USB bus reset is detected, these bits are initialized.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USB_ENABLE</name>
                <description>This bit enables the device to respond to USB traffic.
If USB bus reset is detected, this bit is cleared.
Note:
When USB PHY is GPIO mode(USBIO_CR1.IOMODE=0), USB bus reset is detected. Therefore, when USB PHY is GPIO mode, this bit is cleared even if this bit is set to 1. If this bit is set to 1, write this bit upon USB bus reset interrupt, and do not write to this bit during initialization steps.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR1</name>
            <description>USB control 1 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>REG_ENABLE</name>
                <description>This bit controls the operation of the internal USB regulator. For applications with supply voltages in the 5V range this bit is set high to enable the internal regulator. For device supply voltage in the 3.3V range this bit is cleared to connect the transceiver directly to the supply.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LOCK</name>
                <description>This bit is set to turn on the automatic frequency locking of the internal oscillator to USB traffic.  Unless an external clock is being provided this bit should remain set for proper USB operation.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_ACTIVITY</name>
                <description>The Bus Activity bit is a stickybit that detects any non-idle USB event that has occurred on the USB bus. Once set to High by the SIE to indicate the bus activity this bit retains its logical High
value until firmware clears it.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP_INT_EN</name>
            <description>USB SIE Data Endpoints Interrupt Enable Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR_EN</name>
                <description>Enables interrupt for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR_EN</name>
                <description>Enables interrupt for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR_EN</name>
                <description>Enables interrupt for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR_EN</name>
                <description>Enables interrupt for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR_EN</name>
                <description>Enables interrupt for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR_EN</name>
                <description>Enables interrupt for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR_EN</name>
                <description>Enables interrupt for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR_EN</name>
                <description>Enables interrupt for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP_INT_SR</name>
            <description>USB SIE Data Endpoint Interrupt Status</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR</name>
                <description>Interrupt status for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>Interrupt status for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>Interrupt status for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>Interrupt status for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>Interrupt status for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>Interrupt status for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>Interrupt status for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>Interrupt status for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR0</name>
            <description>USBIO Control 0 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE0</resetMask>
            <fields>
              <field>
                <name>RD</name>
                <description>Received Data. This read only bit gives the state of the USB differential receiver when IOMODE bit is '0'  and USB doesn't transmit. This bit is valid if USB Device.
If D+=D- (SE0), this value is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIFF_LOW</name>
                    <description>D+ &lt; D- (K state)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIFF_HIGH</name>
                    <description>D+ &gt; D- (J state)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TD</name>
                <description>Transmit Data. Transmit a USB J or K state on the USB bus. No effect if TEN=0 or TSE0=1.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIFF_K</name>
                    <description>Force USB K state (D+ is low D- is high).</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIFF_J</name>
                    <description>Force USB J state (D+ is high D- is low).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSE0</name>
                <description>Transmit Single-Ended Zero. SE0: both D+ and D- low. No effect if TEN=0.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEN</name>
                <description>USB Transmit Enable. This is used to manually transmit on the D+ and D- pins. Normally this bit should be cleared to allow the internal SIE to drive the pins. The most common reason for manually
transmitting is to force a resume state on the bus.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR2</name>
            <description>USBIO control 2 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RSVD_5_0</name>
                <description>N/A</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TEST_PKT</name>
                <description>This bit enables the device to transmit a packet in response to an internally generated IN packet.  When set, one packet will be generated.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR1</name>
            <description>USBIO control 1 Register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20</resetValue>
            <resetMask>0x20</resetMask>
            <fields>
              <field>
                <name>DMO</name>
                <description>This read only bit gives the state of the D- pin when IOMODE bit is '0'  and USB doesn't transmit.
This bit is '0' when USB transmits SE0, and this bit is '1' when USB transmits other than SE0.
This bit is valid if USB Device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DPO</name>
                <description>This read only bit gives the state of the D+ pin when IOMODE bit is '0' and USB doesn't transmit.
This bit displays the output value of D+ pin when USB transmits SE0 or data.
This bit is valid if USB Device.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IOMODE</name>
                <description>This bit allows the D+ and D- pins to be configured for either USB mode or bit-banged modes. If this bit is set the DMI and DPI bits are used to drive the D- and D+ pins.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DYN_RECONFIG</name>
            <description>USB Dynamic reconfiguration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DYN_CONFIG_EN</name>
                <description>This bit is used to enable the dynamic re-configuration for the selected EP. If set to 1, indicates the reconfiguration required for selected EP.
Use 0 for EP1, 1 for EP2, etc.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DYN_RECONFIG_EPNO</name>
                <description>These bits indicates the EP number for which reconfiguration is required when dyn_config_en bit is set to 1.</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DYN_RECONFIG_RDY_STS</name>
                <description>This bit indicates the ready status for the dynamic reconfiguration, when set to 1, indicates the block is ready for reconfiguration.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF0</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER</name>
                <description>It has the lower 8 bits [7:0] of the SOF frame number.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF1</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER_MSB</name>
                <description>It has the upper 3 bits [10:8] of the SOF frame number.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR0</name>
            <description>Oscillator lock data register 0</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER</name>
                <description>These bits return the lower 8 bits of the oscillator locking circuits adder output.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR1</name>
            <description>Oscillator lock data register 1</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER_MSB</name>
                <description>These bits return the upper 7 bits of the oscillator locking circuits adder output.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP0_CR</name>
            <description>Endpoint0 control Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OUT_RCVD</name>
                <description>When set this bit indicates a valid OUT packet has been received and ACKed. This bit is updated to '1' after the last received packet in an OUT transaction. When clear this bit indicates no OUT received. It is cleared by any writes to the register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_RCVD</name>
                <description>When set this bit indicates a valid IN packet has been received. This bit is updated to '1' after the host acknowledges an IN data packet. When clear this bit indicates either no IN has been received or that the host did not acknowledge the IN data by sending ACK handshake. It is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP_RCVD</name>
                <description>When set this bit indicates a valid SETUP packet was received and ACKed. This bit is forced HIGH from the start of the data packet phase of the SETUP transaction until the start of the ACK packet returned by the SIE. The CPU is prevented from clearing this bit during this interval. After this interval the bit will remain set until cleared by firmware. While this bit is set to '1' the CPU cannot write to the EP0_DRx registers. This prevents firmware from overwriting an incoming SETUP transaction before firmware has a chance to read the SETUP data. This bit is cleared by any non-locked writes to the register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP0_CNT</name>
            <description>Endpoint0 count Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCF</resetMask>
            <fields>
              <field>
                <name>BYTE_COUNT</name>
                <description>These bits indicate the number of data bytes in a transaction. For IN transactions firmware loads the count with the number of bytes to be transmitted to the host from the endpoint FIFO. Valid values are 0 to 8. For OUT or SETUP transactions the count is updated by hardware to the number of data bytes received plus two for the CRC bytes. Valid values are 2 to 10.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT/SETUP transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xB4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x130</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x134</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x138</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x170</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x174</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x178</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1B4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x1F8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x21C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUF_SIZE</name>
            <description>Dedicated Endpoint Buffer Size Register  *1</description>
            <addressOffset>0x230</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>IN_BUF</name>
                <description>Buffer size for IN Endpoints.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_BUF</name>
                <description>Buffer size for OUT Endpoints.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP_ACTIVE</name>
            <description>Endpoint Active Indication Register  *1</description>
            <addressOffset>0x238</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP_TYPE</name>
            <description>Endpoint Type (IN/OUT) Indication  *1</description>
            <addressOffset>0x23C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP2_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP3_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP4_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP5_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP6_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP7_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP8_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x240</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x244</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x248</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x250</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x254</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x25C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_CFG</name>
            <description>Arbiter Configuration Register  *1</description>
            <addressOffset>0x270</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0</resetMask>
            <fields>
              <field>
                <name>AUTO_MEM</name>
                <description>Enables Auto Memory Configuration.  Manual memory configuration by default.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_CFG</name>
                <description>DMA Access Configuration.</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DMA_NONE</name>
                    <description>No DMA</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DMA_MANUAL</name>
                    <description>Manual DMA</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DMA_AUTO</name>
                    <description>Auto DMA</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CFG_CMP</name>
                <description>Register Configuration Complete Indication. Posedge is detected on this bit. Hence a 0 to 1 transition is required.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CLK_EN</name>
            <description>USB Block Clock Enable Register</description>
            <addressOffset>0x274</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CSR_CLK_EN</name>
                <description>Clock Enable for Core Logic clocked by AHB bus clock</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_INT_EN</name>
            <description>Arbiter Interrupt Enable  *1</description>
            <addressOffset>0x278</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR_EN</name>
                <description>Enables interrupt for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR_EN</name>
                <description>Enables interrupt for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR_EN</name>
                <description>Enables interrupt for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR_EN</name>
                <description>Enables interrupt for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR_EN</name>
                <description>Enables interrupt for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR_EN</name>
                <description>Enables interrupt for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR_EN</name>
                <description>Enables interrupt for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR_EN</name>
                <description>Enables interrupt for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_INT_SR</name>
            <description>Arbiter Interrupt Status  *1</description>
            <addressOffset>0x27C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR</name>
                <description>Interrupt status for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>Interrupt status for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>Interrupt status for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>Interrupt status for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>Interrupt status for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>Interrupt status for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>Interrupt status for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>Interrupt status for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x280</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x284</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x288</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x290</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x294</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x298</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x29C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x2A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA</name>
            <description>Common Area Write Address  *1</description>
            <addressOffset>0x2B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CWA</name>
                <description>Write Address for Common Area</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA_MSB</name>
            <description>Endpoint Read Address value  *1</description>
            <addressOffset>0x2B4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CWA_MSB</name>
                <description>Write Address for Common Area</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x2C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x2C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x2C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x2D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x2D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x2D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x2DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x2E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x2F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DMA_THS</name>
                <description>DMA Threshold count</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES_MSB</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x2F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>DMA_THS_MSB</name>
                <description>DMA Threshold count</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x300</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x304</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x308</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x310</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x314</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x318</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x31C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUS_RST_CNT</name>
            <description>Bus Reset Count Register</description>
            <addressOffset>0x330</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>BUS_RST_CNT</name>
                <description>Bus Reset Count Length</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x340</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x344</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x348</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x350</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x354</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x358</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x35C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x380</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x384</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x388</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x390</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x394</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x398</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x39C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x3A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x3C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x3C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x3C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x3D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x3D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x3D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x3DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x3E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>512</dim>
            <dimIncrement>4</dimIncrement>
            <name>MEM_DATA[%s]</name>
            <description>DATA</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF16</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x1060</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER16</name>
                <description>The frame number (11b)</description>
                <bitRange>[10:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR16</name>
            <description>Oscillator lock data register</description>
            <addressOffset>0x1080</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER16</name>
                <description>These bits return the oscillator locking circuits adder output.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1250</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1290</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1298</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x12A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA16</name>
            <description>Common Area Write Address</description>
            <addressOffset>0x12B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>CWA16</name>
                <description>Write Address for Common Area</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x12D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x12D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x12E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES16</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x12F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DMA_THS16</name>
                <description>DMA Threshold count</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1310</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1318</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1350</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1358</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1390</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1398</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x13A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x13D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x13D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x13E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBLPM</name>
          <description>USB Device LPM and PHY Test</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <name>POWER_CTL</name>
            <description>Power Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x303F0004</resetMask>
            <fields>
              <field>
                <name>SUSPEND</name>
                <description>Put PHY into Suspend mode.  If the PHY is enabled, this bit MUST be set before entering a low power mode (DeepSleep).
Note:
- This bit is invalid if the HOST bit of the Host Control 0 Register (HOST_CTL0) is '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_UP_EN</name>
                <description>Enables the pull up on the DP.
'0' : Disable.
'1' : Enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_BIG</name>
                <description>Select the resister value if POWER_CTL.DP_EN='1'. This bit is valid in GPIO.
'0' : The resister value is from 900 to1575Ohmpull up on the DP.
'1' : The resister value is from 1425 to 3090Ohmpull up on the DP</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_DOWN_EN</name>
                <description>Enables the ~15k pull down on the DP.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_UP_EN</name>
                <description>Enables the pull up on the DM. The bit is valid in GPIO. The pull up resistor is disabled in not GPIO.
'0' : Disable.
'1' : Enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_BIG</name>
                <description>Select the resister value if POWER_CTL.DM_EN='1'. This bit is valid in GPIO.
'0' : The resister value is from 900 to1575Ohmpull up on the DM.
'1' : The resister value is from 1425 to 3090Ohmpull up on the DM</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_DOWN_EN</name>
                <description>Enables the ~15k pull down on the DP.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_DPO</name>
                <description>Enables the single ended receiver on D+.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_DMO</name>
                <description>Enables the signle ended receiver on D-.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CTL</name>
            <description>USB IO Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>DM_P</name>
                <description>The GPIO Drive Mode for DP IO pad. This field only applies if USBIO_CR1.IOMODE =1. Data comes from the corresponding GPIO.DR register.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0: Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.

Other values, not supported.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM_M</name>
                <description>The GPIO Drive Mode for DM IO pad.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLOW_CTL</name>
            <description>Flow Control Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_ERR_RESP</name>
                <description>End Point 1 error response
0: do nothing (backward compatibility mode)
1: if this is an IN EP and an underflow occurs then cause a CRC error, if this is an OUT EP and an overflow occurs then send a NAK</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_ERR_RESP</name>
                <description>End Point 2 error response</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_ERR_RESP</name>
                <description>End Point 3 error response</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_ERR_RESP</name>
                <description>End Point 4 error response</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_ERR_RESP</name>
                <description>End Point 5 error response</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_ERR_RESP</name>
                <description>End Point 6 error response</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_ERR_RESP</name>
                <description>End Point 7 error response</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_ERR_RESP</name>
                <description>End Point 8 error response</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPM_CTL</name>
            <description>LPM Control Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17</resetMask>
            <fields>
              <field>
                <name>LPM_EN</name>
                <description>LPM enable
0: Disabled, LPM token will not get a response (backward compatibility mode) 
1: Enable, LPM token will get a handshake response (ACK, STALL, NYET or NAK)
       A STALL will be sent if the bLinkState is not 0001b
       A NYET, NAK or ACK response will be sent depending on the NYET_EN and LPM_ACK_RESP bits below</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_ACK_RESP</name>
                <description>LPM ACK response enable (if LPM_EN=1), to allow firmware to refuse a low power request 
0: a LPM token will get a NYET or NAK (depending on NYET_EN bit below) response and the device will NOT go to a low power mode  
1: a LPM token will get an ACK response and the device will go to the requested low power mode</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NYET_EN</name>
                <description>Allow firmware to choose which response to use for an LPM token (LPM_EN=1) when the device is NOT ready to go to the requested low power mode (LPM_ACK_RESP=0).
0: a LPM token will get an NAK response (indicating a CRC error),  the host is expected to repeat the LPM token.
1: a LPM token will get a NYET response</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_RESP</name>
                <description>Enable a STALL response for all undefined SubPIDs, i.e. other than LPM (0011b). If not enabled then there will be no response (Error) for the undefined SubPIDs.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPM_STAT</name>
            <description>LPM Status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>LPM_BESL</name>
                <description>Best Effort Service Latency
This value should match either the Baseline (DeepSleep) or Deep (Hibernate) BESL in the BOS descriptor.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_REMOTEWAKE</name>
                <description>0: Device is prohibited from initiating a remote wake
1: Device is allow to wake the host</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Status</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>Interrupt status for USB SOF</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>Interrupt status for BUS RESET</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>Interrupt status for EP0</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>Interrupt status for LPM  (Link Power Management, L1 entry)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Interrupt status for Resume</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_SET</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Set</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_MASK</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Mask</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_MASKED</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Masked</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_LVL_SEL</name>
            <description>Select interrupt level for each interrupt source</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFC3FF</resetMask>
            <fields>
              <field>
                <name>SOF_LVL_SEL</name>
                <description>USB SOF Interrupt level select</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>illegal</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUS_RESET_LVL_SEL</name>
                <description>BUS RESET Interrupt level select</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_LVL_SEL</name>
                <description>EP0 Interrupt level select</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_LVL_SEL</name>
                <description>LPM Interrupt level select</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_LVL_SEL</name>
                <description>Resume Interrupt level select</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ARB_EP_LVL_SEL</name>
                <description>Arbiter Endpoint Interrupt level select</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1_LVL_SEL</name>
                <description>EP1 Interrupt level select</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_LVL_SEL</name>
                <description>EP2 Interrupt level select</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_LVL_SEL</name>
                <description>EP3 Interrupt level select</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_LVL_SEL</name>
                <description>EP4 Interrupt level select</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_LVL_SEL</name>
                <description>EP5 Interrupt level select</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_LVL_SEL</name>
                <description>EP6 Interrupt level select</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_LVL_SEL</name>
                <description>EP7 Interrupt level select</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_LVL_SEL</name>
                <description>EP8 Interrupt level select</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_HI</name>
            <description>High priority interrupt Cause register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_MED</name>
            <description>Medium priority interrupt Cause register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_LO</name>
            <description>Low priority interrupt Cause register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DFT_CTL</name>
            <description>DFT control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DDFT_OUT_SEL</name>
                <description>DDFT output select signal</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Nothing connected, output 0</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DP_SE</name>
                    <description>Single Ended output of DP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DM_SE</name>
                    <description>Single Ended output of DM</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TXOE</name>
                    <description>Output Enable</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RCV_DF</name>
                    <description>Differential Receiver output</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DP_OUT</name>
                    <description>GPIO output of DP</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DM_OUT</name>
                    <description>GPIO output of DM</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDFT_IN_SEL</name>
                <description>DDFT input select signal</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Nothing connected, output 0</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DP_IN</name>
                    <description>GPIO input of DP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DM_IN</name>
                    <description>GPIO input of DM</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBHOST</name>
          <description>USB Host Controller</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>HOST_CTL0</name>
            <description>Host Control 0 Register.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>HOST</name>
                <description>This bit selects an operating mode of this IP.
'0' : USB Device
'1' : USB Host
Notes:
- The mode of operation mode does not transition immediately after setting this bit.  Read this bit to confirm that the operation mode has changed.
- This bit is reset to '0' if the ENABLE bit in this register changes from '1' to '0'.
- Before changing from the USB Host to the USB Device, check that the following conditions are satisfied and also set the RST bit of the Host Control 1 Register (HOST_CTL1). to '1'.
     * The SOFBUSY bit of the Host Status Register (HOST_STATUS) is set to '0'.
     * The TKNEN bits of the Host Token Endpoint Register (HOST_TOKEN) is set to '000'.
     * The SUSP bit of the Host Status Register (HOST_STATUS) is set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>This bit enables the operation of this IP.
'0' : Disable USB Host
'1' : Enable USB Host
Note:
- This bit doesn't affect the USB Device.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTL1</name>
            <description>Host Control 1 Register.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x83</resetValue>
            <resetMask>0x83</resetMask>
            <fields>
              <field>
                <name>CLKSEL</name>
                <description>This bit selects the operating clock of USB Host.
'0' : Low-speed clock
'1' : Full-speed clock
Notes:
- This bit is set to it's default vaulue '1' if the ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.
- This bit must always be set to '1' in the USB Device mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USTP</name>
                <description>This bit stops the clock for the USB Host operating unit. When this bit is '1', power consumption can be reduced by configuring this bit.
'0' : Normal operating mode.
'1' : Stops the clock for the USB Host operating unit.
Notes:
- If this bit is set to '1', the function of USB Host can't be used because internal clock is stopped.
- This bit is initialized if ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RST</name>
                <description>This bit resets the USB Host.
'0' : Normal operating mode.
'1' : USB Host is reset.
Notes:
- This bit is to it's default value '1' if  the ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.
- If this bit is set to '1', both the BFINI bits of the Host Endpoint 1 Control Register (HOST_EP1_CTL) and Host Endpoint 2 Control Register (HOST_EP2_CTL) are set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTL2</name>
            <description>Host Control 2 Register.</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RETRY</name>
                <description>If this bit is set to '1', the target token is retried if a NAK or error* occurs. Retry processing is performed after the time that is specified in the Host Retry Timer Setup Register (HOST_RTIMER).
* : HOST_ERR.RERR='1', HOST_ERR.TOUT='1', HOST_ERR.CRC='1', HOST_ERR.TGERR='1', HOST_ERR.STUFF='1'
'0' : Doesn't retry token sending.
'1' : Retries token sending
Note:
- This bit isn't initialized even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CANCEL</name>
                <description>When this bit is set to '1', if the target token is written to the Host Token Endpoint Register (HOST_TOKEN) in the EOF area (specified in the Host EOF Setup Register), its sending is canceled. When this bit is set to '0', token sending is not canceled even if the target token is written to the register. The cancellation of token sending is detected by reading the TCAN bit of the Interrupt USB Host Register (INTR_USBHOST).
'0' : Continues a token.
'1' : Cancels a token.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFSTEP</name>
                <description>If this bit is set to '1', the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is set to '1' each time SOF is sent.
If this bit is set to '0', the set value of the Host SOF Interrupt Frame Compare Register (HOST_FCOMP) is compared with the low-order eight bits of the SOF frame number. If they match, the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is set to '1'.
'0' : An interrupt occurred due to the HOST_HFCOMP setting.
'1' : An interrupt occurred.
Notes:
- If a SOF token (TKNEN='001') is sent by the setting of the Host Token Endpoint Register (HOST_TOKEN), the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is not set to '1' regardless of the setting of this bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ALIVE</name>
                <description>This bit is used to specify the keep-alive function in the low-speed mode. If this bit it set to '1' while the CLKSEL bit of the Host Control 1 Register (HOST_CTL1) is '0', SE0 is output instead of SOF. This bit is only effective when the CLKSEL bit is '0'. If the CLKSEL bit is '1' (Full-Speed mode), SOF is output regardless of the setting of the ALIVE bit. 
'0' : SOF output.
'1' : SE0 output (Keep alive)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TTEST</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_ERR</name>
            <description>Host Error Status Register.</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>HS</name>
                <description>These flags indicate the status of a handshake packet to be sent or received.
These flags are set to 'NULL' when no handshake occurs due to an error or when a SOF token has been ended with the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN).
These bits are updated when sending or receiving has been ended. 
Write '11' to set the status back to 'NULL', all other write values are ignored. 
Note:
This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACK</name>
                    <description>Acknowledge Packet</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK</name>
                    <description>Non-Acknowledge Packet</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL</name>
                    <description>Stall Packet</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NULL</name>
                    <description>Null Packet</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STUFF</name>
                <description>If this bit is set to '1', it means that a bit stuffing error has been detected. When this bit is '0', it means that no error is detected. If a stuffing error is detected, bit5 (TOUT) of this register is also set to '1'.  Write '1' to clear, a write of '0' is ignored.
'0' : No stuffing error.
'1' : Stuffing error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TGERR</name>
                <description>If this bit is set to '1', it means that the data does not match the TGGL data. When this bit is '0', it means that no error is detected. Write '1' to clear, a write of '0' is ignored.
'0' : No toggle error.
'1' : Toggle error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC</name>
                <description>If this bit is set to '1', it means that a CRC error is detected in the USB Host. When this bit is '0', it means that no error is detected. If a CRC error is detected, bit5 (TOUT) of this register is also set to '1'.  Write '1' to clear, a write of '0' is ignored.
'0' : No CRC error.
'1' : CRC error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOUT</name>
                <description>If this bit is set to '1', it means that no response is returned from the device within the specified time after a token has been sent in the USB Host. When this bit is '0', it means that no timeout is detected.  Write '1' to clear, a write of '0' is ignored.
'0' : No timeout.
'1' : Timeout has detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RERR</name>
                <description>When this bit is set to '1', it means that the received data exceeds the specified maximum number of packets in the USB Host. If a receive error is detected, bit5 (TOUT) of this register is also set to '1'. When this bit is '0', it means that no error is detected. Write '1' to clear, a write of '0' is ignored.
'0' : No receive error.
'1' : Maximum packet receive error detected.
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LSTSOF</name>
                <description>If this bit is set to '1', it means that the SOF token can't be sent in the USB Host because other token is in process. When this bit is '0', it means that SOF token was sent with no error. Write '1' to clear, a write of '0' is ignored.
'0' : SOF sent without error.
'1' : SOF error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_STATUS</name>
            <description>Host Status Register.</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xC2</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>CSTAT</name>
                <description>When this bit is '1', it means that the device is connected. When this bit is '0', it means that the device is disconnected.
'0' : Device is disconnected.
'1' : Device is connected.
Notes:
- This bit is set to the default value if the RST bit of the Host Control 1 Register (Host_CTL1) is set to '1'.
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TMODE</name>
                <description>If this bit is '1', it means that the device is connected in the full-speed mode. When this bit is '0', it means that the device is connected in the low-speed mode. This bit is valid when the CSTAT bit of the Host Status Register (HOST_STATUS) is '1'.
'0' : Low-speed.
'1' : Full-speed.
Notes:
- This bit is set to the default value if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'. 
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUSP</name>
                <description>If this bit is set to '1', the USB Host is placed into the suspend state. If this bit is set to '0' while it is '1' or the USB bus is placed into the k-state mode, then suspend state is released, and the RWIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
Set to '1' : Suspend.
Set '0' when this bit is '1' : Resume.
Other conditions : Holds the status.
Notes:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.
- If this bit is set to '1', this bit must not be set to '1' until the RWIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
- Do not set this bit to '1' while the USB is active (during USB bus resetting, data transfer, or SOF timer running).
- If the value of this bit is changed, it is not immediately reflected on the state of the USB bus. To check whether or not the state is updated, read this bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFBUSY</name>
                <description>When a SOF token is sent using the Host Token Endpoint Register (HOST_TOKEN), this bit is set to '1', which means that the SOF timer is active. When this bit is '0', it means that the SOF timer is under suspension. To stop the active SOF timer, write '0' to this bit. However, if this bit is written with '1', its value is ignored. 
'0' : The SOF timer is stopped.
'1' : The SOF timer is active.
Notes:
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1).
- The SOF timer does not stop immediately after this bit has been set to '0' to stop the SOF timer. To check whether or not the SOF timer is stopped, read this bit.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URST</name>
                <description>When this bit is set to '1', the USB bus is reset. This bit remains a '1' during USB bus resetting, and changes to '0' when USB bus resetting is ended. If this bit is set to '0', the USB bus reset is complete</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSTBUSY</name>
                <description>This bit shows that USB Host is being reset internally. If the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1', this bit is set to '1'.
If the RST bit of Host Control 1 Register (HOST_CTL1) is set to '0', this bit is set to '0'.
'0' : USB Host isn't being reset.
'1' : USB Host is being reset.
Notes:
- If this bit is '1', the a token must not be executed.
- This bit isn't set to '0' or '1' immediately even if the RST bit of Host Control 1 Register (HOST_CTL1) is set to '0' or '1'. Read this bit to confirm the operation is complete.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLKSEL_ST</name>
                <description>This bit shows whether it is full-speed or not. If the CLKSEL bit of the Host Control 1 Register (HOST_CTL1) is set to '1', this bit is set to '1'.
'0' : Low speed
'1' : Full speed
Note:
- If this bit is different from the CLKSEL bit, The execution of the token and bus reset must wait these bits match.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1). Read this bit to confirm the operation is complete.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_ST</name>
                <description>This bit shows whether the device is in USB Host mode. If the HOST bit of the Host Control Register (HOST_CTL0) is set to '1', this bit is set to '1'.
'0' : USB Device
'1' : USB Host
Notes:
- If this bit is different from the HOST bit, The execution of a token must wait these bits match.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1). Read this bit to confirm the operation is complete.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_FCOMP</name>
            <description>Host SOF Interrupt Frame Compare Register</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FRAMECOMP</name>
                <description>These bits are used to specify the data to be compared with the low-order eight bits of a frame number when sending a SOF token.
If the SOFSTEP bit of Host Control 2 Register (HOST_CTL2) is '0', the frame number of SOF is compared with the value of this register when sending a SOF token. If they match, the SOFIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
The setting of this register is invalid when the SOFSTEP bit of Host Control 2 Register (HOST_CTL2) is '1'.
Note:
- This bit is not reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_RTIMER</name>
            <description>Host Retry Timer Setup Register</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFFF</resetMask>
            <fields>
              <field>
                <name>RTIMER</name>
                <description>These bits are used to specify the retry time in this register. The retry timer is activated when token sending starts while the RETRY bit of Host Control 2 Register (HOST_CTL2) is '1'. The retry time is then decremented by one when a 1-bit transfer clock (12 MHz in the full-speed mode) is output. When the retry timer reaches 0, the target token is sent, and processing ends.
If a token retry occurs in the EOF area, the retry timer is stopped until SOF sending is ended. After SOF sending has been completed, the retry timer restarts with the value that is set when the timer stopped.</description>
                <bitRange>[17:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_ADDR</name>
            <description>Host Address Register</description>
            <addressOffset>0x114</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>ADDRESS</name>
                <description>These bits are used to specify a token address.
Note:
- This bit is reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EOF</name>
            <description>Host EOF Setup Register</description>
            <addressOffset>0x118</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>EOF</name>
                <description>These bits are used to specify the time to disable token sending before transferring SOF. Specify the time with a margin, which is longer than the one-packet length. The time unit is the 1-bit transfer time.
Setting example: MAXPKT = 64 bytes, full-speed mode
 (Token_length + packet_length + header + CRC)*7/6 + Turn_around_time
  =(34 bit + 546 bit)*7/6 + 36 bit = 712.7 bit
 Therefore, set 0x2C9.
Note:
- This bit is not reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[13:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_FRAME</name>
            <description>Host Frame Setup Register</description>
            <addressOffset>0x11C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FRAME</name>
                <description>These bits are used to specify a frame number of SOF.
Notes:
- This bit isn't reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- Specify a frame number in this register before setting SOF in the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN).
- This register cannot be written while the SOFBUSY bit of the Host Status Register (HOST_STATUS) is '1' and a SOF token is in process.</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_TOKEN</name>
            <description>Host Token Endpoint Register</description>
            <addressOffset>0x120</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17F</resetMask>
            <fields>
              <field>
                <name>ENDPT</name>
                <description>These bits are used to specify an endpoint to send or receive data to or from the device.
Note:
- This bit isn't reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TKNEN</name>
                <description>These bits send a token according to the current settings. After operation is complete, the TKNEN bit is set to '000', and the CMPIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
The settings of the TGGL and ENDPT bits are ignored when sending a SOF token.
Notes:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- The PRE packet isn't supported.
- Do not set '100' to the TKNEN bit when the SOFBUSY bit of the Host Status Register (HOST_STATUS) is '1'
- Mode should be USB Host before writing data to this bit.
- When issuing a token again after the token interrupt flag (CMPIRQ) has been set to '1', wait for 3 cycles or more after a USB transfer clock (12 MHz in the full-speed mode, 1.5 MHz in the low-speed mode) was output, then write data to this bit.
- Read the value of TKNEN bit if a new value is written in it .Continue writing in this bit until a retrieved value equals a new value written in. During this checking process, it is needed to prevent any interrupt.
- Take the following steps when CMPIRQ bit of Interrupt USB Host Register (INTR_USBHOST) is set to '1' by finishing IN token or Isochronous IN token.
1. Read HS bit of Host Error Status Register (HOST_ERR), then set CMPIRQ bit to '0'.
2. Set EPn bit of Host DMA Enable Register (HOST_DMA_ENBL) (n=1 or 2) to '1' if HS bit of Host Error Status Register (HOST_ERR) is equal to '00' and wait until EPn bit of Host DMA Data Request Register (HOST_DMA_DREQ) changes to '1'. Finish the IN token processing if HS bit is not equal to '00'.
3. Read the received data if EPn bit of Host DMA Data Requet (HOST_DMA_DREQ) (n=1 or 2) changes to '1'.</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NONE</name>
                    <description>Sends no data.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SETUP</name>
                    <description>Sends SETUP token.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IN</name>
                    <description>Sends IN token.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OUT</name>
                    <description>Sends OUT token.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SOF</name>
                    <description>Sends SOF token.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>Sends Isochronous IN.</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>Sends Isochronous OUT.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSV</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TGGL</name>
                <description>This bit is used to set toggle data. Toggle data is sent depending on the setting of this bit. When receiving toggle data, received toggle data is compared with the toggle data of this bit to verify whether or not an error occurs.
'0' : DATA0
'1' : DATA1
Notes:
- This bit isn't reset to the default value even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- Set this bit when the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN) is '000'.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_CTL</name>
            <description>Host Endpoint 1 Control Register</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8100</resetValue>
            <resetMask>0x9DFF</resetMask>
            <fields>
              <field>
                <name>PKS1</name>
                <description>This bit specifies the maximum size transferred by one packet. The configurable range is from 0x001 to 0x100.
- If automatic buffer transfer mode (DMAE='1') is used, Endpoint 0,1, or 2 cannot be used,</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NULLE</name>
                <description>When a data transfer request in OUT the direction is transmitted while automatic buffer transfer mode is set (DMAE = 1), this bit sets a mode that transfers 0-byte data automatically upon the detection of the last packet transfer.
'0' : Releases the NULL automatic transfer mode.
'1' : Sets the NULL automatic transfer mode.
Note :
- For data transfer in the IN direction or when automatic buffer transfer mode is not set, the NULL bit configuration does not affect communication.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>This bit sets a mode that uses DMA for writing or reading transfer data to/from send/receive buffer, and automatically transfers the send/receive data synchronized with an data request in the IN or OUT direction. Until the data size set in the DMA is reached, the data is transferred.
'0' : Releases the packet transfer mode.
'1' : Sets the packet transfer mode.
Note :
- The CPU must not access the send/receive buffer while the DMAE bit is set to '1'. For data transfer in the IN direction, set the DMA transfer size to the multiples of that set in PKS1 bits of the Host EP1 Control Register (HOST_EP1_CTL) and Host EP2 Control Register (HOST_EP2_CTR).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>This bit specifies the transfer direction the Endpoint support.
'0' : IN Endpoint.
'1' : OUT Endpoint
Note:
- This bit must be changed when INI_ST bit of the Host Endpoint 1 Status Register (HOST_EP1_STATUS) is '1'.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BFINI</name>
                <description>This bit initializes the send/receive buffer of transfer data. The BFINI bit is also automatically set by setting the RST bit of the HOST Control 1 Register (HOST_CTL1). If the RST bit was used for resetting, therefore, set the RST bit to '0' before clearing the BFINI bit.
'0' : Clears the initialization.
'1' : Initializes the send/receive buffer
Note :
- The EP1 buffer has a double-buffer configuration. The BFINI bit initialization initializes the double buffers concurrently and also initializes the EP1DRQ and EP1SPK bits.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_STATUS</name>
            <description>Host Endpoint 1 Status Register</description>
            <addressOffset>0x404</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x60000</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>SIZE1</name>
                <description>These bits indicate the number of data bytes written to the receive buffer when IN packet transfer of EP1 has finished.
The indication range is from 0x000 to 0x100.
Note :
- These bits are set to the data size transferred in the IN direction and written to the buffer. Therefore, a value read during transfer in the OUT direction has no effect.</description>
                <bitRange>[8:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VAL_DATA</name>
                <description>This bit shows that there is valid data in the EP1 buffer.
'0' : Invalid data in the buffer
'1' : Valid data in the buffer</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INI_ST</name>
                <description>This bit shows that EP1 is initialized. If the init bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is set to '1' and EP1 is initialized, this bit is to '1'.
'0' : Not initiatialized
'1' : Initialized
Note:
- This bit isn't set to '0' or '1' immediately even if BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is set to '0' or '1'.  Read this bit to confirm the transition.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_18</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_RW1_DR</name>
            <description>Host Endpoint 1 Data 1-Byte Register</description>
            <addressOffset>0x408</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BFDT8</name>
                <description>Data Register for EP1 for 1-byte data</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_RW2_DR</name>
            <description>Host Endpoint 1 Data 2-Byte Register</description>
            <addressOffset>0x40C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BFDT16</name>
                <description>Data Register for EP1 for 2-byte data</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_CTL</name>
            <description>Host Endpoint 2 Control Register</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8040</resetValue>
            <resetMask>0x9C7F</resetMask>
            <fields>
              <field>
                <name>PKS2</name>
                <description>This bit specifies the maximum size transferred by one packet. The configurable range is from 0x001 to 0x40.
- If automatic buffer transfer mode (DMAE='1') is used, this Endpoint must not set from 0 to 2.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NULLE</name>
                <description>When a data transfer request in the OUT direction transmitted while packet transfer mode is set (DMAE = 1), this bit sets a mode that transfers 0-byte data automatically upon the detection of the last packet transfer.
'0' : Releases the NULL automatic transfer mode.
'1' : Sets the NULL automatic transfer mode.
Note :
- For data transfer in the IN direction or when automatic buffer transfer mode is not set, the NULL bit configuration does not affect communication.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>This bit sets a mode that uses DMA for writing or reading transfer data to/from send/receive buffer, and automatically transfers the send/receive data synchronized with an data request in the IN or OUT direction. Until the data size set in the DMA is reached, the data is transferred.
'0' : Releases the automatic buffer transfer mode.
'1' : Sets the automatic buffer transfer mode.
Note :
- The CPU must not access the send/receive buffer while the DMAE bit is set to '1'. For data transfer in the IN direction, set the DMA transfer size to the multiples of that set in PKS bits of the Host EP1 Control Register (HOST_EP1_CTL) and Host EP2 Control Register (HOST_EP2_CTR).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>This bit specifies the transfer direction the Endpoint support.
'0' : IN Endpoint.
'1' : OUT Endpoint
Note:
- This bit must be changed when INI_ST bit of the Host Endpoint 2 Status Register (HOST_EP2_STATUS) is '1'.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BFINI</name>
                <description>This bit initializes the send/receive buffer of transfer data. The BFINI bit is also automatically set by setting the RST bit of the HOST Control 1 Register (HOST_CTL1). If the RST bit was used for resetting, therefore, set the RST bit to '0' before clearing the BFINI bit.
'0' : Clears the initialization.
'1' : Initializes the send/receive buffer
Note :
- The EP2 buffer has a double-buffer configuration. The BFINI bit initialization initializes the double buffers concurrently and also initializes the EP2DRQ and EP2SPK bits.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_STATUS</name>
            <description>Host Endpoint 2 Status Register</description>
            <addressOffset>0x504</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x60000</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>SIZE2</name>
                <description>These bits indicate the number of data bytes written to the receive buffer when IN packet transfer of EP2 has finished.
The indication range is from 0x000 to 0x40.
Note :
- These bits are set to the data size transferred in the IN direction and written to the buffer. Therefore, a value read during transfer in the OUT direction has no effect.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VAL_DATA</name>
                <description>This bit shows that there is valid data in the EP2 buffer.
'0' : Invalid data in the buffer
'1' : Valid data in the buffer</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INI_ST</name>
                <description>This bit shows that EP2 is initialized. If the BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is set to '1' and EP2 is initialized, this bit is to '1'.
'0' : Not Initialized
'1' : Initialized
Note:
- This bit isn't set to '0' or '1' immediately evne if BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is set to '0' or '1'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_18</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_RW1_DR</name>
            <description>Host Endpoint 2 Data 1-Byte Register</description>
            <addressOffset>0x508</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BFDT8</name>
                <description>Data Register for EP2 for 1-byte data.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_RW2_DR</name>
            <description>Host Endpoint 2 Data 2-Byte Register</description>
            <addressOffset>0x50C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BFDT16</name>
                <description>Data Register for EP2 for 2 byte data.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_LVL1_SEL</name>
            <description>Host Interrupt Level 1 Selection Register</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_SEL</name>
                <description>These bits assign SOFIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRQ_SEL</name>
                <description>These bits assign DIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQ_SEL</name>
                <description>These bits assign CNNIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQ_SEL</name>
                <description>These bits assign URIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQ_SEL</name>
                <description>These bits assign URIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQ_SEL</name>
                <description>These bits assign RWKIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_13_12</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCAN_SEL</name>
                <description>These bits assign TCAN interrupt flag to selected interrupt signals.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_LVL2_SEL</name>
            <description>Host Interrupt Level 2 Selection Register</description>
            <addressOffset>0x804</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF0</resetMask>
            <fields>
              <field>
                <name>EP1_DRQ_SEL</name>
                <description>These bits assign EP1_DRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP1_SPK_SEL</name>
                <description>These bits assign EP1_SPK interrupt flag to selected interrupt signals.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_DRQ_SEL</name>
                <description>These bits assign EP2_DRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_SPK_SEL</name>
                <description>These bits assign EP2_SPK interrupt flag to selected interrupt signals.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_HI</name>
            <description>Interrupt USB Host Cause High Register</description>
            <addressOffset>0x900</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_MED</name>
            <description>Interrupt USB Host Cause Medium Register</description>
            <addressOffset>0x904</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_LO</name>
            <description>Interrupt USB Host Cause Low Register</description>
            <addressOffset>0x908</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_HI</name>
            <description>Interrupt USB Host Endpoint Cause High Register</description>
            <addressOffset>0x920</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_MED</name>
            <description>Interrupt USB Host Endpoint Cause Medium Register</description>
            <addressOffset>0x924</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_LO</name>
            <description>Interrupt USB Host Endpoint Cause Low Register</description>
            <addressOffset>0x928</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST</name>
            <description>Interrupt USB Host Register</description>
            <addressOffset>0x940</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ</name>
                <description>If this bit is set to '1', it means that SOF token sending is started. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Does not issue an interrupt request by starting a SOF token.
'1' : Issues an interrupt request by starting a SOF token.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQ</name>
                <description>If this bit is set to '1', it means that a device disconnection is detected. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by detecting a device disconnection.
'1' : Issues an interrupt request by detecting a device disconnection.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQ</name>
                <description>If this bit is set to '1', it means that a device connection is detected. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by detecting a device connection.
'1' : Issues an interrupt request by detecting a device connection.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQ</name>
                <description>If this bit is set to '1', it means that a token is completed. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by token completion.
'1' : Issues an interrupt request by token completion.
Note :
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- This bit is not set to '1' even if the TCAN bit of the Interrupt USBHost Register (INTR_USBHOST) changes to '1'.
- Take the following steps when this bit is set to '1' by finishing IN token or Isochronous IN token.
1. Read HS bit of Host Error Status Register (HOST_ERR), then set CMPIRQ bit to '0'.
2. Set EPn bit of Host DMA Enable Register (HOST_DMA_ENBL) (n=1 or 2) to '1' if HS bit of Host Error Status Register (HOST_ERR) is equal to '00' and wait until EPn bit of Host DMA Data Request Register (HOST_DMA_DREQ) changes to '1'. Finish the IN token processing if HS bit is not equal to '00'.
3. Read the received data if EPn bit of Host DMA Data Requet (HOST_DMA_DREQ) (n=1 or 2) changes to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQ</name>
                <description>If this bit is set to '1', it means that USB bus resetting is ended. When this bit is '0', it has no meaning. If this bit is written with '1', it is set to '0'. However, if this bit is written with '0', its value is ignored.
'0' : Issues no interrupt request by USB bus resetting.
'1' : Issues an interrupt request by USB bus resetting.
Note :
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQ</name>
                <description>If this bit is set to '1', it means that remote Wake-up is ended. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by restart.
'1' : Issues an interrupt request by restart.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCAN</name>
                <description>If this bit is set to '1', it means that token sending is canceled based on the setting of the CANCEL bit of Host Control 2 Register (HOST_CTL2). When this bit is '0', it means that token sending is not canceled. Write '1' to clear, a write of '0' is ignored.
'0' : Does not cancel token sending.
'1' : Cancels token sending.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_SET</name>
            <description>Interrupt USB Host Set Register</description>
            <addressOffset>0x944</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQS</name>
                <description>This bit sets SOFIRQ bit. If this bit is written to '1', SOFIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQS</name>
                <description>This bit sets DIRQ bit. If this bit is written to '1', DIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQS</name>
                <description>This bit sets CNNIRQ bit. If this bit is written to '1', CNNIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQS</name>
                <description>This bit sets CMPIRQ bit. If this bit is written to '1', CMPIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQS</name>
                <description>This bit sets URIRQ bit. If this bit is written to '1', URIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQS</name>
                <description>This bit sets RWKIRQ bit. If this bit is written to '1', RWKIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCANS</name>
                <description>This bit sets TCAN bit. If this bit is written to '1', TCAN is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_MASK</name>
            <description>Interrupt USB Host Mask Register</description>
            <addressOffset>0x948</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQM</name>
                <description>This bit masks the interrupt by SOF flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQM</name>
                <description>This bit masks the interrupt by DIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQM</name>
                <description>This bit masks the interrupt by CNNIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQM</name>
                <description>This bit masks the interrupt by CMPIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQM</name>
                <description>This bit masks the interrupt by URIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQM</name>
                <description>This bit masks the interrupt by RWKIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCANM</name>
                <description>This bit masks the interrupt by TCAN flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_MASKED</name>
            <description>Interrupt USB Host Masked Register</description>
            <addressOffset>0x94C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQED</name>
                <description>This bit indicates the interrupt by SOF flag.
'0' : Doesn't request the interrupt by SOF
'1' : Request the interrupt by SOF</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQED</name>
                <description>This bit indicates the interrupt by DIRQ flag.
'0' : Doesn't request the interrupt by DIRQ
'1' : Request the interrupt by DIRQ</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQED</name>
                <description>This bit indicates the interrupt by CNNIRQ flag.
'0' : Doesn't request the interrupt by CNNIRQ
'1' : Request the interrupt by CNNIRQ</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQED</name>
                <description>This bit indicates the interrupt by CMPIRQ flag.
'0' : Doesn't request the interrupt by CMPIRQ
'1' : Request the interrupt by CMPIRQ</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQED</name>
                <description>This bit indicates the interrupt by URIRQ flag.
'0' : Doesn't request the interrupt by URIRQ
'1' : Request the interrupt by URIRQ</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQED</name>
                <description>This bit indicates the interrupt by RWKIRQ flag.
'0' : Doesn't request the interrupt by RWKIRQ
'1' : Request the interrupt by RWKIRQ</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCANED</name>
                <description>This bit indicates the interrupt by TCAN flag.
'0' : Doesn't request the interrupt by TCAN
'1' : Request the interrupt by TCAN</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP</name>
            <description>Interrupt USB Host Endpoint Register</description>
            <addressOffset>0xA00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ</name>
                <description>This bit indicates that the EP1 packet transfer has normally ended, and processing of the data is required. The DRQ bit is an interrupt cause, and writing '0' is ignored. Clear the DRQ bit by writing '1'.
'0' : Clears the interrupt cause
'1' : Packet transfer normally ended
Note :
- If automatic buffer transfer mode (DMAE = '1') is not used, '1' must be written to the DRQ bit after data has been written or read to/from the send/receive buffer. Switch the access buffers once the DRQ bit is cleared. That DRQ = '0' may not be read after the DRQ bit is cleared. If the transfer direction is set to OUT, and the DRQ bit is cleared without writing buffer data while the DRQ bit is '1', it implies that 0-byte data is set. If DIR of the Host Endpoint 1 Control Register (HOST_EP1_CTL)  is set to '1' at initial settings, the DRQ bit of corresponding Endpoint is set at the same time. Also while the DRQ bit is not set, '1' must not be written.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPK</name>
                <description>This bit indicates that the data size transferred from the host does not satisfy the maximum packet size (including 0-byte) set by PKS in the Host Endpoint 1 Control Register (HOST_EP1_CTL) when the data has been received successfully. This bit is an interrupt cause, and writing '0' is ignored. Clear it by writing '1'.
'0' : Received data size satisfies the maximum packet size
'1' : Received data size does not satisfy the maximum packet size
Note :
- The EP1SPK bit is not set during data transfer in the OUT direction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQ</name>
                <description>This bit indicates that the EP2 packet transfer has normally ended, and processing of the data is required. The DRQ bit is an interrupt cause, and writing '0' is ignored. Clear the DRQ bit by writing '1'.
'0' : Clears the interrupt cause
'1' : Packet transfer normally ended
Note :
- If packet transfer mode (DMAE = '1') is not used, '1' must be written to the DRQ bit after data has been written or read to/from the send/receive buffer. Switch the access buffers once the DRQ bit is cleared. That DRQ = '0' may not be read after the DRQ bit is cleared. If the transfer direction is set to OUT, and the DRQ bit is cleared without writing buffer data while the DRQ bit is '1', it implies that 0-byte data is set. If DIR of the Host Endpoint 2 Control Register (HOST_EP2_CTL)  is set to '1' at initial settings, the DRQ bit of corresponding Endpoint is set at the same time. Also while the DRQ bit is not set, '1' must not be written.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPK</name>
                <description>This bit indicates that the data size transferred from the host does not satisfy the maximum packet size (including 0-byte) set by PKS1 in the Host Endpoint 2 Control Register (HOST_EP2_CTL) when the data has been received successfully. This bit is an interrupt cause, and writing '0' is ignored. Clear it by writing '1'.
'0' : Received data size satisfies the maximum packet size
'1' : Received data size does not satisfy the maximum packet size
Note :
- The SPK bit is not set during data transfer in the OUT direction.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_SET</name>
            <description>Interrupt USB Host Endpoint Set Register</description>
            <addressOffset>0xA04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQS</name>
                <description>This bit sets EP1DRQ bit. If this bit is written to '1', EP1DRQ is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is '1', EP1DRQ can't be set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPKS</name>
                <description>This bit sets EP1SPK bit. If this bit is written to '1', EP1SPK is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is '1', EP1SPK can't be set to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQS</name>
                <description>This bit sets EP2DRQ bit. If this bit is written to '1', EP2DRQ is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is '1', EP2DRQ can't be set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPKS</name>
                <description>This bit sets EP2SPK bit. If this bit is written to '1', EP2SPK is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is '1', EP2SPK can't be set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_MASK</name>
            <description>Interrupt USB Host Endpoint Mask Register</description>
            <addressOffset>0xA08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQM</name>
                <description>This bit masks the interrupt by EP1DRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPKM</name>
                <description>This bit masks the interrupt by EP1SPK flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQM</name>
                <description>This bit masks the interrupt by EP2DRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPKM</name>
                <description>This bit masks the interrupt by EP2SPK flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_MASKED</name>
            <description>Interrupt USB Host Endpoint Masked Register</description>
            <addressOffset>0xA0C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQED</name>
                <description>This bit indicates the interrupt by EP1DRQ flag.
'0' : Doesn't request the interrupt by EP1DRQ
'1' : Request the interrupt by EP1DRQ</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPKED</name>
                <description>This bit indicates the interrupt by EP1SPK flag.
'0' : Doesn't request the interrupt by EP1SPK
'1' : Request the interrupt by EP1SPK</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQED</name>
                <description>This bit indicates the interrupt by EP2DRQ flag.
'0' : Doesn't request the interrupt by EP2DRQ
'1' : Request the interrupt by EP2DRQ</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPKED</name>
                <description>This bit indicates the interrupt by EP2SPK flag.
'0' : Doesn't request the interrupt by EP2SPK
'1' : Request the interrupt by EP2SPK</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_DMA_ENBL</name>
            <description>Host DMA Enable Register</description>
            <addressOffset>0xB00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC</resetMask>
            <fields>
              <field>
                <name>DM_EP1DRQE</name>
                <description>This bit enables DMA Request by EP1DRQ.
'0' : Disable
'1' : Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_EP2DRQE</name>
                <description>This bit enables DMA Request by EP2DRQ.
'0' : Disable
'1' : Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_BLK</name>
            <description>Host Endpoint 1 Block Register</description>
            <addressOffset>0xB20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>BLK_NUM</name>
                <description>Set the total byte number for DMA transfer. If HOST_EP1_RW1_DR or HOST_EP1_RW2_DR is written, the block number counter is decremented when DMAE='1'.
- Set this bits before DMA transfer is enabled (HOST_DMA_ENBL.DM_DP1DRQE='1')</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_BLK</name>
            <description>Host Endpoint 2 Block Register</description>
            <addressOffset>0xB30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>BLK_NUM</name>
                <description>Set the total byte number for DMA transfer. If HOST_EP2_RW1_DR or HOST_EP2_RW2_DR is written, the block number counter is decremented when DMAE='1'.
- Set this bits before DMA transfer is enabled (HOST_DMA_ENBL.DM_DP2DRQE='1')</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMIF0</name>
      <description>Serial Memory Interface</description>
      <headerStructName>SMIF</headerStructName>
      <baseAddress>0x40420000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000</resetValue>
          <resetMask>0x81073001</resetMask>
          <fields>
            <field>
              <name>XIP_MODE</name>
              <description>Mode of operation.

Note: this field should only be changed when the IP is disabled or when STATUS.BUSY is '0' and SW should not be executing from the XIP interface or MMIO interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MMIO_MODE</name>
                  <description>'0': MMIO mode. Individual MMIO accesses to TX and RX FIFOs are used to generate a sequence of SPI transfers. This mode of operation allows for large flexibility in terms of the SPI transfers that can be generated.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XIP_MODE</name>
                  <description>1': XIP mode. eXecute-In-Place mode: incoming read and write transfers over the AHB-Lite bus infrastructure are automatically translated in SPI transfers to read data from and write data to a device. This mode of operation allow for efficient device read and write operations. This mode is only supported in SPI_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_IF_RX_SEL</name>
              <description>Specifies device interface receiver clock 'clk_if_rx' source. MISO data is captured on the rising edge of 'clk_if_rx'.
'0': 'spi_clk_out' (internal clock)
'1': !'spi_clk_out' (internal clock)
'2': 'spi_clk_in' (feedback clock)
'3': !'spi_clk_in' (feedback clock)

Note: the device interface transmitter clock 'clk_if_tx' is fixed and is 'spi_clk_out' MOSI data is driven on the falling edge of 'clk_if_tx'.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESELECT_DELAY</name>
              <description>Specifies the minimum duration of SPI deselection ('spi_select_out[]' is high/'1') in between SPI transfers:
'0': 1 interface clock cycle.
'1': 2 interface clock cycles.
'2': 3 interface clock cycles.
'3': 4 interface clock cycles.
'4': 5 interface clock cycles.
'5': 6 interface clock cycles.
'6': 7 interface clock cycles.
'7': 8 interface clock cycles.

During SPI deselection, 'spi_select_out[]' are '1'/inactive, 'spi_data_out[]' are '1' and 'spi_clk_out' is '0'/inactive.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Specifies what happens for MMIO interface read accesses to an empty RX data FIFO or to a full TX format/data FIFO. Note: the FIFOs can only be accessed in MMIO_MODE.

This field is not used for test controller accesses.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BUS_ERROR</name>
                  <description>0': Generate an AHB-Lite bus error. This option is useful when SW decides to use polling on STATUS.TR_BUSY to determine if a interface transfer is no longer busy (transfer is completed). This option adds SW complexity, but limits the number of AHB-Lite wait states (and limits ISR latency).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STATES</name>
                  <description>1': Introduce wait states. This setting potentially locks up the AHB-Lite infrastructure and may increase the CPU interrupt latency.This option is useful when SW performs TX/RX data FIFO accesses immediately after a command is setup using the TX format FIFO. This option has low SW complexity, but may result in a significant number of AHB-Lite wait states (and may increase ISR latency).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers are reset to their default value when the IP is disabled. When the IP is disabled, the XIP accesses produce AHB-Lite bus errors.
'1': Enabled.

Note: Before disabling the IP, SW should ensure that the IP is NOT busy (STATUS.BUSY is '0'), otherwise illegal interface transfers may occur.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Cache, cryptography, XIP, device interface or any other logic busy in the IP:
'0': not busy
'1': busy
When BUSY is '0', the IP can be safely disabled without:
- the potential loss of transient write data.
- the potential risk of aborting an inflight SPI device interface transfer.
When BUSY is '0', the mode of operation (XIP_MODE or MMIO_MODE) can be safely changed.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_STATUS</name>
          <description>Transmitter command FIFO status</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>USED3</name>
              <description>Number of entries that are used in the TX command FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 4].</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_WR</name>
          <description>Transmitter command FIFO write</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA20</name>
              <description>Command data. The higher two bits DATA[19:18] specify the specific command
'0'/TX: A SPI transfer always start with a TX command FIFO entry of the 'TX' format.
- DATA[17:16] specifies the width of the data transfer:
   - '0': 1 bit/cycle (single data transfer).
   - '1': 2 bits/cycle (dual data transfer).
   - '2': 4 bits/cycle (quad data transfer).
   - '3': 8 bits/cycle (octal data transfer).
- DATA[15]: specifies whether this is the last TX Byte; i.e. whether the 'spi_select_out[3:0]' IO output signals are de-activated after the transfer.
- DATA[11:8] specifies which of the four devices are selected. DATA[11:8] are directly mapped to 'spi_select_out[3:0]'. Two devices can be selected at the same time in dual-quad mode.
  - '0': device deselected
  - '1': device selected 
- DATA[7:0] specifies the transmitted Byte.

'1'/TX_COUNT: The 'TX_COUNT' command relies on the TX data FIFO to provide the transmitted bytes. The 'TX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
- DATA[17:16] specifies the width of the transfer.
- DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) from the TX data FIFO.

'2'/RX_COUNT: The 'RX_COUNT' command relies on the RX data FIFO to accept the received bytes. The 'RX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
- DATA[17:16] specifies the width of the transfer.
- DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) to the RX data FIFO.

'3'/DUMMY_COUNT: The 'DUMMY_COUNT' command conveys dummy cycles. Dummy cycles are used to implement a Turn-Around time in which the SPI master changes from a transmitter driving the data lines to a receiver receiving on the same data lines. The 'DUMMY_COUNT' command is ALWAYS considered to be NOT the last command of a SPI data transfers; i.e. it needs to be followed by another command.
- DATA[15:0] specifies the number of dummy cycles (minus 1). In dummy cycles, the data lines are not driven.</description>
              <bitRange>[19:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_CTL</name>
          <description>Transmitter data FIFO control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Determines when the TX data FIFO 'tr_tx_req' trigger is activated  (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when TX_DATA_FIFO_STATUS.USED &lt;= TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_STATUS</name>
          <description>Transmitter data FIFO status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR1</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR2</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR4</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>TX data (written to TX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>TX data (written to TX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_CTL</name>
          <description>Receiver data FIFO control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Determines when RX data FIFO 'tr_rx_req' trigger is activated (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when RX_DATA_FIFO_STATUS.USED &gt; TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_STATUS</name>
          <description>Receiver data FIFO status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the RX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD1</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD2</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD4</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>RX data (read from RX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>RX data (read from RX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD1_SILENT</name>
          <description>Receiver data FIFO silent read</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CTL</name>
          <description>Slow cache control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in SLOW_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in SLOW_CA_STATUS0/1/2.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': Disabled.
'1': Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Cache enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CMD</name>
          <description>Slow cache command</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Cache and prefetch buffer invalidation. 
SW writes a '1' to clear the cache and prefetch buffer. The cache's LRU structure is also reset to its default state.
Note, 
A write access will invalidate the prefetch buffer automatically in hardware.
A write access should invalidate both fast and slow caches, by firmware.
Note, firmware should invalidate the cache and prefetch buffer only when STATUS.BUSY is '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CTL</name>
          <description>Fast cache control</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>See SLOW_CA_CTL.WAY.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>See SLOW_CA_CTL.SET_ADDR.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>See SLOW_CA_CTL.PREF_EN.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>See SLOW_CA_CTL.ENABLED.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CMD</name>
          <description>Fast cache command</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>See SLOW_CA_CMD.INV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_CMD</name>
          <description>Cryptography Command</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>SW sets this field to '1' to start a AES-128 forward block cipher operation (on the address in CRYPTO_ADDR). HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRYPTO_RESULT0, ..., CRYPTO_RESULT3.

The operation takes roughly 13 clk_hf clock cycles.

Note: An operation can only be started in MMIO_MODE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT0</name>
          <description>Cryptography input 0</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[31:0] = CRYPTO_INPUT0.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT1</name>
          <description>Cryptography input 1</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[63:32] = CRYPTO_INPUT1.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT2</name>
          <description>Cryptography input 2</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[95:64] = CRYPTO_INPUT2.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT3</name>
          <description>Cryptography input 3</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[127:96] = CRYPTO_INPUT3.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY0</name>
          <description>Cryptography key 0</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[31:0] = CRYPTO_KEY0.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY1</name>
          <description>Cryptography key 1</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[63:32] = CRYPTO_KEY1.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY2</name>
          <description>Cryptography key 2</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[95:64] = CRYPTO_KEY2.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY3</name>
          <description>Cryptography key 3</description>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[127:96] = CRYPTO_KEY3.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT0</name>
          <description>Cryptography output 0</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[31:0] = CRYPTO_OUTPUT0.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT1</name>
          <description>Cryptography output 1</description>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[63:32] = CRYPTO_OUTPUT1.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT2</name>
          <description>Cryptography output 2</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[95:64] = CRYPTO_OUTPUT2.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT3</name>
          <description>Cryptography output 3</description>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[127:96] = CRYPTO_OUTPUT3.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Activated in MMIO mode, when a TX data FIFO trigger 'tr_tx_req' is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Activated in MMIO mode, when a RX data FIFO trigger 'tr_rx_req' is activated.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Activated in XIP mode, if:
- The selected device's ADDR_CTL.DIV2 is '1' and the AHB-Lite bus transfer address is not a multiple of 2.
- The selected device's ADDR_CTL.DIV2 is '1' and the XIP transfer request is NOT for a multiple of 2 Bytes. 

Note: In dual-quad SPI mode (ADDR_CTL.DIV is '1'), each memory device contributes a 4-bit nibble for read data or write data. This is only possible if the request address is a multiple of 2 and the number of requested Bytes is a multiple of 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX command FIFO (TX_CMD_FIFO_WR) with not enough free entries available.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX data FIFO (TX_DATA_FIFO_WR1, TX_DATA_FIFO_WR2, TX_DATA_FIFO_WR4) with not enough free entries available.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite read transfer from the RX data FIFO (RX_DATA_FIFO_RD1, RX_DATA_FIFO_RD2, RX_DATA_FIFO_RD4) with not enough entries available. Only activated for NON test bus controller transfers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>128</dimIncrement>
          <name>DEVICE[%s]</name>
          <description>Device (only used in XIP mode)</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80030101</resetMask>
            <fields>
              <field>
                <name>WR_EN</name>
                <description>Write enable:
'0': write transfers are not allowed to this device. An attempt to write to this device results in an AHB-Lite bus error.
'1': write transfers are allowed to this device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRYPTO_EN</name>
                <description>Cryptography on read/write accesses:
'0': disabled.
'1': enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SEL</name>
                <description>Specifies the connection of the IP's data lines (spi_data[0], ..., spi_data[7]) to the device's data lines (SI/IO0, SO/IO1, IO2, IO3, IO4, IO5, IO6, IO7):
'0': spi_data[0] = IO0, spi_data[1] = IO1, ..., spi_data[7] = IO7. This value is allowed for single, dual, quad, dual quad and octal SPI modes. This value must be used for the first device in dual quad SPI mode. This value must be used for octal SPI mode.
'1': spi_data[2] = IO0, spi_data[3] = IO1. This value is only allowed for single and dual SPI modes.
'2': spi_data[4] = IO0, spi_data[5] = IO1, ..., spi_data[7] = IO3. This value is only allowed for single, dual, quad and dual quad  SPI modes. In dual quad SPI mode, this value must be used for the second device. 
'3': spi_data[6] = IO0, spi_data[7] = IO1. This value is only allowed for single and dual SPI modes.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Device enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR</name>
            <description>Device region base address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Specifies the base address of the device region. If the device region is 2^m Bytes, ADDR MUST be a multiple of 2^m.

In dual quad SPI data transfer, the two devices should have the same ADDR and MASK register settings. The device control information (ADDR_CTL, RD_CMD_CTL, etc.) are provided by the MMIO control registers of the device with the lowest index.

The most significant bit fields are constants and set based on the SMIF_XIP_ADDR parameter. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK is 0xff00:0000 (16 MB XIP memory region), ADDR[31:24] = SMIF_XIP_ADDR[31:24].</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK</name>
            <description>Device region mask</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>MASK</name>
                <description>Specifies the size of the device region. All '1' bits are used to compare the incoming transfer request address A[31:0] with the address as specified in ADDR.ADDR: Address A is in the device when (A[31:8] &amp; MASK[31:8]) == ADDR.ADDR[31:8].

The most significant bit fields are constants and set to'1'. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK  is 0xff00:0000 (16 MB XIP memory region), MASK[31:24] = 0xff.

Note: a transfer request that is not in any device region results in an AHB-Lite bus error.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR_CTL</name>
            <description>Address control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x103</resetMask>
            <fields>
              <field>
                <name>SIZE2</name>
                <description>Specifies the size of the XIP device address in Bytes:
'0': 1 Byte address.
'1': 2 Byte address.
'2': 3 Byte address.
'3': 4 Byte address.
The lower significant address Bytes of the transfer request are used as XIP address to the external device. Note that for dual quad SPI data transfer, the transfer request address is divided by 2. Therefore, the transfer request address needs to be a multiple of 2. If the trasnfer requestaddress is NOT a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV2</name>
                <description>Specifies if the AHB-Lite bus transfer address is divided by 2 or not:
'0': No divide by 2.
'1': Divide by 2.  

This functionality is used for read and write operation in XIP, dual quad SPI mode; i.e. this DIV2 must be set to '1' in dual quad SPI mode. If the transfer request address is NOT a multiple of 2 or the requested number of Bytes is not a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CMD_CTL</name>
            <description>Read command control</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of data transfer:
'0': 1 bit/cycle (single data transfer).
'1': 2 bits/cycle (dual data transfer).
'2': 4 bits/cycle (quad data transfer).
'3': 8 bits/cycle (octal data transfer).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of command field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_ADDR_CTL</name>
            <description>Read address control</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_MODE_CTL</name>
            <description>Read mode control</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of mode field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DUMMY_CTL</name>
            <description>Read dummy control</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.

Note: this field specifies dummy cycles, not dummy Bytes!</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DATA_CTL</name>
            <description>Read data control</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CMD_CTL</name>
            <description>Write command control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of command field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_ADDR_CTL</name>
            <description>Write address control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_MODE_CTL</name>
            <description>Write mode control</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of mode field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DUMMY_CTL</name>
            <description>Write dummy control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DATA_CTL</name>
            <description>Write data control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x40520000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>CH</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_ttcan_tx
10 Dominant ('0') level at pin m_ttcan_tx
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin
Monitors the actual value of pin m_ttcan_rx
0= The CAN bus is dominant (m_ttcan_rx = '0')
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization
0= Normal Operation
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission
after itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting
is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant. 
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code
, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message
, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event
, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>Rx FIFO 0 New Message
0= No new message written to Rx FIFO 0
1= New message written to Rx FIFO 0</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>Rx FIFO 0 Watermark Reached
0= Rx FIFO 0 fill level below watermark
1= Rx FIFO 0 fill level reached watermark</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>Rx FIFO 0 Message Lost
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>Rx FIFO 1 New Message
0= No new message written to Rx FIFO 1
1= New message written to Rx FIFO 1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>Rx FIFO 1 Watermark Reached
0= Rx FIFO 1 fill level below watermark
1= Rx FIFO 1 fill level reached watermark</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>Rx FIFO 1 Message Lost
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>High Priority Message
0= No high priority message received
1= High priority message received</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>Transmission Completed
0= No transmission completed
1= Transmission completed</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>Transmission Cancellation Finished
0= No transmission cancellation finished
1= Transmission cancellation finished</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>Tx FIFO Empty
0= Tx FIFO non-empty
1= Tx FIFO empty</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>Tx Event FIFO New Entry
0= Tx Event FIFO unchanged
1= Tx Handler wrote Tx Event FIFO element</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>Tx Event FIFO Watermark Reached
0= Tx Event FIFO fill level below watermark
1= Tx Event FIFO fill level reached watermark</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>Tx Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>Tx Event FIFO Element Lost
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>Timestamp Wraparound
0= No timestamp counter wrap-around
1= Timestamp counter wrapped around</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>Message RAM Access Failure
The flag is set, when the Rx Handler
- has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message.
- was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM
in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_TTCAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted
Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>Timeout Occurred
0= No timeout
1= Timeout reached</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>Message stored to Dedicated Rx Buffer
The flag is set whenever a received message has been stored into a dedicated Rx Buffer.
0= No Rx Buffer updated
1= At least one received message stored into a Rx Buffer</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>M_TTCAN reports correctable ECC fault to the generic fault structure, this bit always reads as 0.
Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_ttcan_aeim_berr[0]
generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. Controlled by input signal m_ttcan_aeim_berr[1]
generated by an optional external parity / ECC logic attached to the Message RAM. An uncorrected
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected (e.g. parity logic)</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>Error Logging Overflow
0= CAN Error Logging Counter did not overflow
1= Overflow of CAN Error Logging Counter occurred</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>Error Passive
0= Error_Passive status unchanged
1= Error_Passive status changed</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>Warning Status
0= Error_Warning status unchanged
1= Error_Warning status changed</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>Bus_Off Status
0= Bus_Off status unchanged
1= Bus_Off status changed</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>Watchdog Interrupt
0= No Message RAM Watchdog event occurred
1= Message RAM Watchdog event due to missing READY</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)
0= No protocol error in arbitration phase
1= Protocol error in arbitration phase detected (PSR.LEC != 0,7)</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>Protocol Error in Data Phase (Data Bit Time is used)
0= No protocol error in data phase
1= Protocol error in data phase detected (PSR.DLEC != 0,7)</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Line  (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Line</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Line</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Line</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Line</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Line</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Line</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Line</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Line</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0
0= Interrupt line m_ttcan_int0 disabled
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1
0= Interrupt line m_ttcan_int1 disabled
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1FFFFFFF</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RxF0A.F0AI</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the
 buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index
 RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RxF1A.FAI</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the
 buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index
 RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>Rx FIFO 0 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.
The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register
TXBRP. In case a transmission has already been started when a cancellation is requested, this is
done at the end of the transmission, regardless whether the transmission was successful or not. The
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The
corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan
process has completed.
0= No transmission request added
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission
is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements
0= No Trigger Memory
1-64= Number of Trigger Memory elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier
Identifier transmitted with reference message and used for reference message filtering. Standard or
extended reference identifier depending on bit XTD. A standard identifier has to be written to
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier
0= 11-bit standard identifier
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select
Ignored in case of time slaves.
0= Reference message has no additional payload
1= The following elements are taken from Tx Buffer 0:
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode
00= Event-driven CAN communication, default
01= TTCAN level 1
10= TTCAN level 2
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable
0= Strictly time-triggered operation
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master
0= Time Master function disabled
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration.
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation.
0= External clock synchronization in TTCAN Level 0,2 disabled
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit
The application watchdog can be disabled by programming AWL to 0x00.
0x00-FF Maximum time after which the application has to serve the application watchdog.
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering
0= Global time filtering in TTCAN Level 0,2 is disabled
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration
0= Automatic clock calibration in TTCAN Level 0,2 is disabled
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low
Write access to the TUR Numerator Configuration Low is only possible during configuration with
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new
value for NCL is written outside TT Configuration Mode, the new value takes effect when
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'.
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration
0x0000 Illegal value
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time
0= Local time is stopped, default
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one
Host clock period. The global time preset takes effect when the node transmits the next reference
message with the Master_Ref_Mark modified by the preset value written to TTGTP.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. A register time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap
Set by the CPU, reset by each reference message
0= No reference message requested
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap
0= Reset by each reference message
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for
external event-synchronized time-triggered operation (TTOCF.GEN = '1')
0= No action, reset by reception of any reference message
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signaled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked
Set by a write access to register TTOCN. Reset when the updated configuration has been
synchronized into the CAN clock domain.
0= Write access to TTOCN enabled
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code
Cycle count for which the time mark is valid.
0b000000x valid for all cycles
0b000001c valid every second cycle at cycle count mod2 = c
0b00001cc valid every fourth cycle at cycle count mod4 = cc
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain.
0= Write access to TTTMK enabled
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle
0= No Basic Cycle started since bit has been reset
1= Basic Cycle started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle
0= No Matrix Cycle started since bit has been reset
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode
0= No change in master to slave relation or schedule synchronization
1= Master to slave relation or schedule synchronization changed,
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap
0= No reference message seen with Next_is_Gap bit set
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent
of the synchronization state.
0= Time mark not reached
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state
In_Gap or In_Schedule.
0= Time mark not reached
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap
0= No global time wrap occurred
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity
0= No discontinuity of global time
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only.
0= Synchronization deviation within limit
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow
0= Number of Tx Trigger as expected
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow
0= Number of Tx Trigger as expected
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1
0= No scheduling error 1
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2
0= No scheduling error 2
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed
Not set when error level changed during initialization.
0= No change in error level
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger
The initialization is restarted by resetting IWT.
0= No missing reference message during system startup
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger
0= No missing reference message
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog
0= Application watchdog served in time
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error
Trigger out of order.
0= No error found in trigger list
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level
00= Severity 0 - No Error
01= Severity 1 - Warning
10= Severity 2 - Error
11= Severity 3 - Severe Error</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State
00= Master_Off, no master properties relevant
01= Operating as Time Slave
10= Operating as Backup Time Master
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State
00= Out of Synchronization
01= Synchronizing to TTCAN communication
10= Schedule suspended by Gap (In_Gap)
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'.
0= Global time not valid
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'.
0= Local clock speed not synchronized to Time Master clock speed
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F).
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read.
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity
0= No global time preset pending
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another
node sending a reference message.
0= Reset at the end of each reference message
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator
0= No Gap in schedule, reset by each reference message and for all time slaves
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event
The application watchdog is served by reading TTOST. When the watchdog is not served in time,
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring
Mode.
0= Application Watchdog served in time
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization
0= No external clock synchronization pending
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time
Non-fractional part of local time, incremented once each local NTU (see Section 4.5).
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5).
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5).
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable. 
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around) 
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>Clock Stop Request for each TTCAN IP .
The m_ttcan_clkstop_req of each TTCAN IP is directly driven by these bits.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
0= Default MRAM on (with MRAM retained in DeepSleep).
1= Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.

To meet S8 platform requirements, MRAM_OFF should be set to 0 prior to transitioning to Hibernate mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value. 
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC for CANFD SRAM
When disabled also all error injection functionality is disabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_ERR_INJ</name>
          <description>ECC error injection</description>
          <addressOffset>0x1084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFC</resetValue>
          <resetMask>0x7F10FFFC</resetMask>
          <fields>
            <field>
              <name>ERR_ADDR</name>
              <description>Specifies the address of the word where an error will be injected on write or an non-correctable error will be suppressed.
When the ERR_EN bit is set an error parity (ERR_PAR) is injected when any write, from bus or a CAN channel, is done to this address.
When the ERR_EN bit is set and the access address matches ERR_ADDR then a non-correctable ECC error or an Address error will NOT result in a bus error or CAN channel shutdown.
Note that error reporting to the fault structure cannot be suppressed.</description>
              <bitRange>[15:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_EN</name>
              <description>Enable error injection (ECC_EN must be 1).
When this bit is set the error parity (ERR_PAR) will be used when an AHB write is done to the ERR_ADDR address.
When the error word is read a single or double error will be reported to the fault structure just like for a real ECC error (even if this bit is no longer set).
When this bit is set (and ECC_EN=1) a non-correctable error (ECC or address error) for the ERR_ADDR will not be reported back to the CAN channel or  AHB bus.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_PAR</name>
              <description>ECC Parity bits to use for ECC error injection at address ERR_ADDR.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40600000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI). In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames mot separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of up to 256 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element:
'0': 16-bit FIFO data elements.
'1': 8-bit FIFO data elements. This mode doubles the amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, MMIO read operations return 0xffff:ffff and MMIO write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable IP, select the specific operation mode and oversampling factor.
When the IP is enabled, no control information should be changed. Changes should be made AFTER disabling the IP, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the IP is re-enabled. Note that disabling the IP will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when the slave is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register are reliable (when CMD_RESP_EC_BUSY is '0') or not reliable (when CMD_RESP_EC_BUSY is '1'). Note:
- When there is no ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable).
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable), when the CURR_RD_ADDR and CURR_WR_ADDR are not being updated by the HW.
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '1' (not reliable), when the CURR_RD_ADDR or CURR_WR_ADDR are being updated by the HW. 
   Note that this update lasts one I2C clock cycle, or two SPI clock cycles.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: independent of the availability of TX FIFO data frames.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Indicates the clock phase. This field, together with the CPOL field, indicates when MOSI data is driven and MISO data is captured:
- Motorola mode 0. CPOL is '0', CPHA is '0': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is '0', CPHA is '1': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is '1', CPHA is '0': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is '1', CPHA is '1': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.

In SPI Motorola submode, all four CPOL/CPHA modes are valid.
in SPI NS submode, only CPOL=0 CPHA=0 mode is valid.
in SPI TI submode, only CPOL=0 CPHA=1 mode is valid.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. This field, together with the CPHA field, indicates when MOSI data is driven and MISO data is captured:
- CPOL is '0': SCLK is '0' when not transmitting data.
- CPOL is '1': SCLK is '1' when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (for Motorola as determined by CPOL and CPHA, for Texas Instruments on the falling edge of SCLK and for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode. 
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful for slave devices that use SCLK for functional operation other than just SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave select signal 0 (master mode) and to the incoming SPI slave select signal (slave mode). For Motorola and National Semiconductors submodes: 
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Instruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line 'spi_miso_in' is connected to the SPI MISO pin.
'1': the SPI master MISO line 'spi_miso_in' is connected to the SPI master MOSI line 'spi_mosi_out'. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
The IP should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence on availability of data frames in the TX FIFO. In slave mode, when selected and there is no data frame in the TX FIFO, the slave will transmit all '1's. In both master and slave modes, received data frames will be lost if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). When '0', the transmitter TX line 'uart_tx_out' is connected to the TX pin and the receiver RX line 'uart_rx_in' is connected to the RX pin. When '1', the transmitter TX line 'uart_tx_out' is connected to the receiver RX line 'uart_rx_in'. A similar connections scheme is followed for 'uart_rts_out' and 'uart_cts_in'.

This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0xF3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle ('1') time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame separates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal 'uart_rts_out' is activated. By setting this field to '0', flow control is effectively SW disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal 'uart_rts_out':
'0': RTS is low/'0' active; 'uart_rts_out' is '0' when active and 'uart_rts_out' is '1' when inactive.
'1': RTS is high/'1' active; 'uart_rts_out' is '1' when active and 'uart_rts_out' is '0' when inactive.

During IP reset (Hibernate system power mode), 'uart_rts_out' is '1'. This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal 'uart_cts_in':
'0': CTS is low/'0' active; 'uart_cts_in' is '0' when active and 'uart_cts_in' is '1' when inactive.
'1': CTS is high/'1' active; 'uart_cts_in' is '1' when active and 'uart_cts_in' is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal 'uart_cts_in' by the UART transmitter:
'0': Disabled. The UART transmitter ignores 'uart_cts_in', and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses 'uart_cts_in' to qualify the transmission of data. It transmits when 'uart_cts_in' is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', 'uart_cts_in' is connected to 'uart_rts_out' in the IP (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular (no stretching) interface (IF) low time to guarantee functional correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities: 1). the internally clocked logic is enabled (we are in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the internally clocked logic takes over). The internally clocked logic will handle the ongoing transfer as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines are routed internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values.

SDA_IN_FILT_TRIM[1] is used to enable I2CS_EC or SPIS_EC access to internal SRAM memory.
1: enable clock_scb_en, has no effect on ec_busy_pp
0: disable clock_scb_en, enable ec_busy_pp (grant I2CS_EC or SPIS_EC access)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of 'i2c_sda_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of 'i2c_scl_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative 'i2c_sda_out' filter delay:
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1010F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
- UART mode, 'uart_tx' IO cell.
- SPI mode, 'spi_miso' IO cell.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x30F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.

In UART multi-processor mode, all 8 bits are used.

In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization of the first transmitted byte in a I2C transfer: the first 7 bits represent the address of the addressed slave, and the last 1 bit is a read/write indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the ADDR field bits in the ADDR field take part in the matching of the slave address: MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

This register has a side effect when read by software: a data frame is removed from the FIFO. This may be undesirable during debug; i.e. a read during debug should NOT have a side effect. To this end, the IP uses the AHB-Lite 'hmaster[0]' input signal. When this signal is '1' in the address cycle of a bus transfer, a read transfer will not have a side effect. As a result, a read from this register will not remove a data frame from the FIFO. As a result, a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK'd or NACK'd.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO.   In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL.TRIGGER_LEVEL. 

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries != FF_DATA_NR/2.
BYTE_MODE is '1': # entries != FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.

Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO, and the last stop field is transmitted (both TX FIFO and transmit shifter register are empty). Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is useful when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by RX_FIFO_CTRL.TRIGGER_LEVEL.

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.

Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries == FF_DATA_NR/2.
BYTE_MODE is '1': # entries == FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40610000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40620000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x40640000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB5</name>
      <baseAddress>0x40650000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB6</name>
      <baseAddress>0x40660000</baseAddress>
    </peripheral>
    <peripheral>
      <name>CTBM0</name>
      <description>Continuous Time Block Mini</description>
      <headerStructName>CTBM</headerStructName>
      <baseAddress>0x40900000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTB_CTRL</name>
          <description>global CTB and power control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: CTB IP disabled off during DeepSleep power mode
- 1: CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: CTB IP disabled (put analog in power down, open all switches)
- 1: CTB IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES0_CTRL</name>
          <description>Opamp0 and resistor0 control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1BFF</resetMask>
          <fields>
            <field>
              <name>OA0_PWR_MODE</name>
              <description>Opamp0 power level, assumes Cload=15pF for the (internal only) 1x driver or 50pF for the (external) 10x driver</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low power mode (IDD: 350uA, GBW: 1MHz for both 1x/10x)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MEDIUM</name>
                  <description>Medium power mode (IDD: 600uA, GBW: 3MHz for 1x &amp; 2.5MHz for 10x)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High power mode for highest GBW (IDD: 1500uA, GBW: 8MHz for 1x &amp; 6MHz for 10x)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PS_LOW</name>
                  <description>Power Saver Low power mode (IDD: ~20uA with 1uA bias from AREF, GBW: ~100kHz for 1x/10x, offset correcting IDAC is disabled)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PS_MEDIUM</name>
                  <description>Power Saver Medium power mode (IDD: ~40uA with 1uA bias from AREF, GBW: ~100kHz for 1x/10x, offset correcting IDAC is enabled)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PS_HIGH</name>
                  <description>Power Saver Medium power mode (IDD: ~60uA with 1uA bias from AREF, GBW: ~200kHz for 1x/10x, offset correcting IDAC is enabled)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_DRIVE_STR_SEL</name>
              <description>Opamp0 output strength select 0=1x, 1=10x
This setting sets specific requirements for OA0_BOOST_EN and OA0_COMP_TRIM</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMP_EN</name>
              <description>Opamp0 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_HYST_EN</name>
              <description>Opamp0 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_BYPASS_DSI_SYNC</name>
              <description>Opamp0 bypass comparator output synchronization for DSI (trigger) output: 0=synchronize (level or pulse), 1=bypass (output async)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_DSI_LEVEL</name>
              <description>Opamp0 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA0_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMPINT</name>
              <description>Opamp0 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_PUMP_EN</name>
              <description>Opamp0 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_BOOST_EN</name>
              <description>Opamp0 gain booster enable for class A output, for risk mitigation only, not user selectable. Value depends on the drive strength setting - 1x mode: set to 1; 10x mode: set to 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES1_CTRL</name>
          <description>Opamp1 and resistor1 control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1BFF</resetMask>
          <fields>
            <field>
              <name>OA1_PWR_MODE</name>
              <description>Opamp1 power level: see description of OA0_PWR_MODE</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DRIVE_STR_SEL</name>
              <description>Opamp1 output strength select 0=1x, 1=10x
This setting sets specific requirements for OA1_BOOST_EN and OA1_COMP_TRIM</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMP_EN</name>
              <description>Opamp1 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_HYST_EN</name>
              <description>Opamp1 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_BYPASS_DSI_SYNC</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize, 1=bypass</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DSI_LEVEL</name>
              <description>Opamp1 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA1_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMPINT</name>
              <description>Opamp1 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA1_PUMP_EN</name>
              <description>Opamp1 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_BOOST_EN</name>
              <description>Opamp1 gain booster enable for class A output, for risk mitigation only, not user selectable. Value depends on the drive strength setting - 1x mode: set to 1; 10x mode: set to 0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP_STAT</name>
          <description>Comparator status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OA0_COMP</name>
              <description>Opamp0 current comparator status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1_COMP</name>
              <description>Opamp1 current comparator status</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW</name>
          <description>Opamp0 switch control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>Opamp0 positive terminal amuxbusa</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>Opamp0 positive terminal P0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>Opamp0 positive terminal ctbbus0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>Opamp0 negative terminal P1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>Opamp0 negative terminal Opamp0 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>Opamp0 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>Opamp0 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW_CLEAR</name>
          <description>Opamp0 switch control clear</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW</name>
          <description>Opamp1 switch control</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4193</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>Opamp1 positive terminal amuxbusb</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>Opamp1 positive terminal P5</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>Opamp1 positive terminal ctbbus1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A73</name>
              <description>Opamp1 positive terminal to vref1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>Opamp1 negative terminal P4</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>Opamp1 negative terminal Opamp1 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>Opamp1 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>Opamp1 output sarbus1 (ctbbus3 in CTB)</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>Opamp1 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW_CLEAR</name>
          <description>Opamp1 switch control clear</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4193</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A73</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTD_SW</name>
          <description>CTDAC connection switch control</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF732</resetMask>
          <fields>
            <field>
              <name>CTDD_CRD</name>
              <description>CTDAC Reference opamp output to ctdrefdrive</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDS_CRS</name>
              <description>ctdrefsense to opamp input</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDS_COR</name>
              <description>ctdvout to opamp input</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDO_C6H</name>
              <description>P6 pin to Hold capacitor</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDO_COS</name>
              <description>ctdvout to Hold capacitor (Sample switch). Note this switch will temporarily be opened for deglitching if CTDAC.DEGLITCH_COS is set</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_COB</name>
              <description>Drive the CTDAC output with CTBM 1x output during hold mode in Sample and Hold operation</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_CHD</name>
              <description>Hold capacitor connect</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_CA0</name>
              <description>Hold capacitor to opamp input</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_CIS</name>
              <description>Hold capacitor isolation (from all the other switches)</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_ILR</name>
              <description>Hold capacitor leakage reduction (drive other side of CIS to capacitor voltage)</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTD_SW_CLEAR</name>
          <description>CTDAC connection switch control clear</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF732</resetMask>
          <fields>
            <field>
              <name>CTDD_CRD</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDS_CRS</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDS_COR</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDO_C6H</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDO_COS</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_COB</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_CHD</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_CA0</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_CIS</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDH_ILR</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_DS_CTRL</name>
          <description>CTB bus switch control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000C00</resetMask>
          <fields>
            <field>
              <name>P2_DS_CTRL23</name>
              <description>for P22, D51 (dsi_out[2])</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>P3_DS_CTRL23</name>
              <description>for P33, D52, D62 (dsi_out[3])</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTD_COS_DS_CTRL</name>
              <description>Hold capacitor Sample switch (COS)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_SQ_CTRL</name>
          <description>CTB bus switch Sar Sequencer control</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00</resetMask>
          <fields>
            <field>
              <name>P2_SQ_CTRL23</name>
              <description>for D51</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>P3_SQ_CTRL23</name>
              <description>for D52, D62</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_STATUS</name>
          <description>CTB bus switch control status</description>
          <addressOffset>0xC8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>OA0O_D51_STAT</name>
              <description>see OA0O_D51 bit in OA0_SW</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D52_STAT</name>
              <description>see OA1O_D52 bit in OA1_SW</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D62_STAT</name>
              <description>see OA1O_D62 bit in OA1_SW</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTD_COS_STAT</name>
              <description>see COS bit in CTD_SW</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_OFFSET_TRIM</name>
              <description>Opamp0 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SLOPE_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_SLOPE_OFFSET_TRIM</name>
              <description>Opamp0 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_COMP_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA0_COMP_TRIM</name>
              <description>Opamp0 Compensation Capacitor Trim. 
Value depends on the drive strength setting - 1x mode: set to 01; 10x mode: set to 11</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_OFFSET_TRIM</name>
              <description>Opamp1 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SLOPE_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_SLOPE_OFFSET_TRIM</name>
              <description>Opamp1 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_COMP_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA1_COMP_TRIM</name>
              <description>Opamp1 Compensation Capacitor Trim. 
Value depends on the drive strength setting - 1x mode: set to 01; 10x mode: set to 11</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CTDAC0</name>
      <description>Continuous Time DAC</description>
      <headerStructName>CTDAC</headerStructName>
      <baseAddress>0x40940000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTDAC_CTRL</name>
          <description>Global CTDAC control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFBC0033F</resetMask>
          <fields>
            <field>
              <name>DEGLITCH_CNT</name>
              <description>To prevent glitches after VALUE changes from propagating the output switch can be opened for DEGLITCH_CNT+1 clk_peri clock cycles.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEGLITCH_CO6</name>
              <description>Force CTDAC.CO6 switch open after each VALUE change for the set number of clock cycles.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEGLITCH_COS</name>
              <description>Force CTB.COS switch open after each VALUE change for the set number of clock cycles.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_EN</name>
              <description>Output enable, intended to be used during the Hold phase of the Sample and Hold when power cycling :
0: output disabled, the output is either: 
       - Tri-state (DISABLED_MODE=0) 
       - or Vssa (DISABLED_MODE=1 &amp;&amp; CTDAC_RANGE=0)  
       - or Vref (DISABLED_MODE=1 &amp;&amp; CTDAC_RANGE=1) 
1: output enabled, CTDAC output drives the programmed VALUE</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDAC_RANGE</name>
              <description>By closing the bottom switch in the R2R network the output is lifted by one LSB, effectively adding 1
0: Range is [0, 4095] * Vref / 4096 
1: Range is [1, 4096] * Vref / 4096</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDAC_MODE</name>
              <description>DAC mode, this determines the Value decoding</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED12</name>
                  <description>Unsigned 12-bit VDAC, i.e. no value decoding.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIRT_SIGNED12</name>
                  <description>Virtual signed 12-bits' VDAC. Value decoding: 
add 0x800 to the 12-bit Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD3</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DISABLED_MODE</name>
              <description>Select the output value when the output is disabled (OUT_EN=0) (for risk mitigation)
0: Tri-state CTDAC output when disabled
1: output Vssa or Vref when disabled (see OUT_EN description)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_STROBE_EN</name>
              <description>DSI strobe input Enable. This enables CTDAC updates to be further throttled by DSI.
0: Ignore DSI strobe input
1: Only do a CTDAC update if allowed by the DSI strobe (throttle), see below for level or edge</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_STROBE_LEVEL</name>
              <description>Select level or edge detect for DSI strobe
- 0: DSI strobe signal is a pulse input, after a positive edge is detected on the DSI strobe signal the next DAC value update is done on the next CTDAC clock
- 1: DSI strobe signal is a level input, as long as the DSI strobe signal remains high the CTDAC will do a next DAC value update on each CTDAC clock.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: CTDAC IP disabled off during DeepSleep power mode
- 1: CTDAC IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0: CTDAC IP disabled (put analog in power down, open all switches)
1: CTDAC IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VDAC_EMPTY</name>
              <description>VDAC Interrupt: hardware sets this interrupt when VDAC next value field is empty, i.e. was copied to the current VALUE. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VDAC_EMPTY_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VDAC_EMPTY_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VDAC_EMPTY_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTDAC_SW</name>
          <description>CTDAC switch control</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>CTDD_CVD</name>
              <description>VDDA supply to ctdrefdrive</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDO_CO6</name>
              <description>ctdvout to P6 pin. Note this switch will temporarily be opened for deglitching if DEGLITCH_CO6 is set</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTDAC_SW_CLEAR</name>
          <description>CTDAC switch control clear</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>CTDD_CVD</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTDO_CO6</name>
              <description>see corresponding bit in CTD_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTDAC_VAL</name>
          <description>DAC Value</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Value, in CTDAC_MODE 1 this value is decoded</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTDAC_VAL_NXT</name>
          <description>Next DAC value (double buffering)</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Next value for CTDAC_VAL.VALUE</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SAR0</name>
      <description>SAR ADC with Sequencer</description>
      <headerStructName>SAR</headerStructName>
      <baseAddress>0x409B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Analog control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000000</resetValue>
          <resetMask>0xFF3FEEF7</resetMask>
          <fields>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWR_100</name>
                  <description>full power  (100 percent) (default), bypass cap, max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_80</name>
                  <description>80 percent power</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_60</name>
                  <description>60 percent power</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_50</name>
                  <description>50 percent power</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_40</name>
                  <description>40 percent power</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_30</name>
                  <description>30 percent power</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_20</name>
                  <description>20 percent power</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_10</name>
                  <description>10 percent power</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VREF0</name>
                  <description>VREF0 from PRB (VREF buffer on)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF1</name>
                  <description>VREF1 from PRB (VREF buffer on)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF2</name>
                  <description>VREF2 from PRB (VREF buffer on)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_AROUTE</name>
                  <description>VREF from AROUTE (VREF buffer on)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBGR</name>
                  <description>1.024V from BandGap (VREF buffer on)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_EXT</name>
                  <description>External precision Vref direct from a pin (low impedance path).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_DIV_2</name>
                  <description>Vdda/2  (VREF buffer on)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA</name>
                  <description>Vdda.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_KELVIN</name>
                  <description>NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ART_VSSA</name>
                  <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P1</name>
                  <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P3</name>
                  <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P5</name>
                  <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P7</name>
                  <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACORE</name>
                  <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF</name>
                  <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_DLY</name>
              <description>Set the comparator latch delay in accordance with SAR conversion rate</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>D2P5</name>
                  <description>2.5ns delay, use this for 2.5Msps</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D4</name>
                  <description>4.0ns delay, use this for 2.0Msps</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D10</name>
                  <description>10ns delay, use this for 1.5Msps</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D12</name>
                  <description>12ns delay, use this for 1.0Msps or less</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls, not yet designated, for late changes done with an ECO</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTPUMP_EN</name>
              <description>deprecated</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFBUF_EN</name>
              <description>For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. 
Setting this bit is critical to proper function of switches inside SARREF block.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_PWR</name>
              <description>Comparator power mode. (Sample rate TBD)</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>P100</name>
                  <description>Power = 100 percent, Use this for SAR Clock Frequency greater than 18MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P80</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P60</name>
                  <description>Power = 60 percent, Use this for SAR Clock Frequency greater than 1.8MHz up to 18MHz.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P50</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P40</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P30</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P20</name>
                  <description>Power = 20 percent, Use this for SAR Clock Frequency less than or equal to 1.8MHz</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P10</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: SARMUX IP disabled off during DeepSleep power mode
- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_CONFIG</name>
              <description>- 0: bypass clock domain synchronization of the DSI config signals.
- 1: synchronize the DSI config signals to peripheral clock domain.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_MODE</name>
              <description>SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)
- 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations
- 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)
- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations
- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgating) on write.
- 1: SAR IP enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_CTRL</name>
          <description>Sample control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80008</resetValue>
          <resetMask>0xDFCF01FE</resetMask>
          <fields>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value 

If AVG_MODE = 1 (Interleaved averaging), then SINGLE_ENDED_SIGNED must be configured identically to DIFFERENTIAL_SIGNED.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Default: result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value when DIFFERENTIAL_EN or NEG_ADDR_EN is set to 1

If AVG_MODE = 1 (Interleaved averaging), then DIFFERENTIAL_SIGNED must be configured identically to SINGLE_ENDED_SIGNED.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Default: result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have averaging enabled (AVG_EN). A channel will be sampled (1&lt;&lt;(AVG_CNT+1)) = [2..256] times.
- In ACCUNDUMP mode  (1st order accumulate and dump filter) a channel will be sampled back to back, the average result is calculated and stored and then the next enabled channel is sampled. If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).
- In INTERLEAVED mode one sample is taken per triggered scan, only in the scan where the final averaging count is reached a valid average is calculated and stored in the RESULT register (by definition the same scan for all the channels that have averaging enabled). In all other scans the RESULT register for averaged channels will have an invalid result and the intermediate accumulated value is stored in the 16-bit WORK register. In this mode make sure that the averaging count is low enough to ensure that the intermediate value does not exceed 16-bits otherwise the MSBs will be lost. So for a 12-bit resolution the averaging count should be set to 16 or less (AVG_CNT=&lt;3).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in 12 bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_MODE</name>
              <description>Averaging mode,  in DSI mode this bit is ignored and only AccuNDump mode is available.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACCUNDUMP</name>
                  <description>Accumulate and Dump (1st order accumulate and dump filter): a channel will be sampled back to back and averaged</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INTERLEAVED</name>
                  <description>Interleaved: Each scan (trigger) one sample is taken per channel and averaged over several scans.  Interleaved averaging cannot be set by SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.
- 1: Continuously scan enabled channels, ignore triggers.  This field cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>- 0: firmware trigger only: disable hardware trigger tr_sar_in.
- 1: enable hardware trigger tr_sar_in (e.g. from TCPWM, GPIO or UDB).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>- 0: trigger signal is a pulse input, a positive edge detected on the trigger signal triggers a new scan.
- 1: trigger signal is a level input, as long as the trigger signal remains high the SAR will do continuous scans. This field cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>- 0: bypass clock domain synchronization of the trigger signal.
- 1: synchronize the trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UAB_SCAN_MODE</name>
              <description>Select whether UABs are scheduled or unscheduled. When no UAB is scanned this selection is ignored.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSCHEDULED</name>
                  <description>Unscheduled UABs: one or more of the UABs scanned by the SAR is not scheduled, for each channel that scans a UAB the SAR will wait for a positive edge on the trigger output of that UAB. Caveat: in this mode the length of SAR scan can be variable.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCHEDULED</name>
                  <description>Scheduled UABs: All UABs scanned by the SAR are assumed to be properly scheduled, i.e. their output is assumed to be valid when sampled by the SAR and the SAR does not wait. In this mode the length of the SAR scan is constant. 
This mode requires that the SAR scans strictly periodically, i.e. the SAR has to either run continuously or has to be triggered by a periodic hardware trigger (TCPWM or UDB timer). It also requires that the end of the UAB valid phase is precisely aligned with the end of the SAR sample period (using UAB.STARTUP_DELAY). Normally this scheduling is done by Creator.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REPEAT_INVALID</name>
              <description>For unscheduled UAB_SCAN_MODE only, do the following if an invalid sample is received:
- 0: use the last known valid sample for that channel and clear the NEWVALUE flag
- 1: repeat the conversions until a valid sample is received (caveat: could be never if the UAB valid window is incorrectly schedule w.r.t. SAR sampling)</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_SEL</name>
              <description>Static UAB Valid select
0=UAB0 half 0 Valid output
1=UAB0 half 1 Valid output
2=UAB1 half 0 Valid output
3=UAB1 half 1 Valid output
4=UAB2 half 0 Valid output
5=UAB2 half 1 Valid output
6=UAB3 half 0 Valid output
7=UAB3 half 1 Valid output</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_SEL_EN</name>
              <description>Enable static UAB Valid selection (override Hardware)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_IGNORE</name>
              <description>Ignore UAB valid signal, including the dynamic/Hardware from AROUTE and the static Valid selection from the VALID_SEL fields above</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_OUT_EN</name>
              <description>SAR output trigger enable (used for UAB synchronization). To ensure multiple UABs starting at the same trigger it is recommended to use this bit to temporarily disable the trigger output until all those UABs are set to run (UAB.SRAM_CTRL.RUN=1).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a trigger pulse is send on the tr_sar_out signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30003</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is one clock less than specified here. The minimum sample time is 167ns, which is 3.0 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30003</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_THRES</name>
          <description>Global range detect threshold register.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_COND</name>
          <description>Global range detect mode register.</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BELOW</name>
                  <description>result &lt; RANGE_LOW</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INSIDE</name>
                  <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ABOVE</name>
                  <description>RANGE_HIGH &lt;= result</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUTSIDE</name>
                  <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. 
- 0: the corresponding channel is disabled.
- 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CTRL</name>
          <description>Start control register (firmware trigger).</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.  This fiel+G201d cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_CONFIG[%s]</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x81773577</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  
If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.
- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formatting), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_WORK[%s]</name>
          <description>Channel working data register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x88000000</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_RESULT[%s]</name>
          <description>Channel result data register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE8000000</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_UPDATED</name>
          <description>Channel working data register 'updated' bits</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_UPDATED</name>
              <description>If set the corresponding WORK register was updated, i.e. was already sampled during the current scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_UPDATED</name>
          <description>Channel result data register 'updated' bits</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_UPDATED</name>
              <description>If set the corresponding RESULT register was updated, i.e. was sampled during the previous scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_NEWVALUE</name>
          <description>Channel working data register 'new value' bits</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_NEWVALUE</name>
              <description>If set the corresponding WORK data received a new value, i.e. was already sampled during the current scan and data was valid.
In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.
In case of averaging this New Value bit is an OR of all the valid bits received by each conversion. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_NEWVALUE</name>
          <description>Channel result data register 'new value' bits</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_NEWVALUE</name>
              <description>If set the corresponding RESULT data received a new value, i.e. was sampled during the last scan and data was valid.
In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.
In case of averaging this New Value bit is an OR of all the valid bits received by each conversion. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register.</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.  This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit. This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit. This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit. This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF, this is an indication that the ADC likely saturated. Write with '1' to clear bit. This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit. This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit. This interrupt cannot be used if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register.</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR</name>
          <description>Saturate interrupt request register.</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF, this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register.</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR</name>
          <description>Range detect interrupt request register.</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register.</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00000FF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_MASKED_RED</name>
              <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_MASKED_RED</name>
              <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_CHAN_CONFIG</name>
          <description>Injection channel configuration register.</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0003577</resetMask>
          <fields>
            <field>
              <name>INJ_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this injection channel. If differential is enabled then INJ_PIN_ADDR[0] is ignored and considered to be 0, i.e. INJ_PIN_ADDR points to the even pin of a pin pair.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT</name>
                  <description>AROUTE virtual port</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SAMPLE_TIME_SEL</name>
              <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_TAILGATING</name>
              <description>Injection channel tailgating.
- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set if the SAR is not busy.  If the SAR is busy, the INJ channel addressed pin is sampled at the end of the current scan.
- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_START_EN</name>
              <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.  This field cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_RESULT</name>
          <description>Injection channel result register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF8000000</resetMask>
          <fields>
            <field>
              <name>INJ_RESULT</name>
              <description>SAR conversion result of the channel. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_NEWVALUE</name>
              <description>The data in this register received a new value (only relevant for UAB, this bit shows the value of the UAB valid bit). This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000001F</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_VREF_NEG</name>
              <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL). This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF8FFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRLV_BUSY</name>
              <description>If high then the SAR is in the middle of Interleaved averaging spanning several scans. While this bit is high the Firmware should not make any changes to the configuration registers otherwise some results may be incorrect. Note that the CUR_AVG_CNT status register below gives an indication how many more scans need to be done to complete the Interleaved averaging.
This bit can be cleared by changing the averaging mode to ACCUNDUMP or by disabling the SAR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update. This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, (also powers on the temperature sensor if AREF_CTRL.EN=1 (active mode) and AREF_CTRL.DEEPSLEEP=1 and AREF_CTRL.DEEPSLEEP_MODE=2 or 3 (required for deepsleep mode only). The Write with '1' to set bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_SQ_CTRL</name>
          <description>SARMUX switch Sar Sequencer control</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_SQ_CTRL_P0</name>
              <description>for P0 switches</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P1</name>
              <description>for P1 switches</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P2</name>
              <description>for P2 switches</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P3</name>
              <description>for P3 switches</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P4</name>
              <description>for P4 switches</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P5</name>
              <description>for P5 switches</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P6</name>
              <description>for P6 switches</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P7</name>
              <description>for P7 switches</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_VSSA</name>
              <description>for vssa switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_TEMP</name>
              <description>for temp switch</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_AMUXBUSA</name>
              <description>for amuxbusa switch</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_AMUXBUSB</name>
              <description>for amuxbusb switches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_SARBUS0</name>
              <description>for sarbus0 switch</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_SARBUS1</name>
              <description>for sarbus1 switch</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x348</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0.  This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SAR0">
      <name>SAR1</name>
      <baseAddress>0x409C0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>PASS</name>
      <description>PASS top-level MMIO (AREF, LPOSC, FIFO, INTR, Trigger)</description>
      <baseAddress>0x409F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CTB0_INT</name>
              <description>CTB0 interrupt pending</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB1_INT</name>
              <description>CTB1 interrupt pending</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB2_INT</name>
              <description>CTB2 interrupt pending</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB3_INT</name>
              <description>CTB3 interrupt pending</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC0_INT</name>
              <description>CTDAC0 interrupt pending</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC1_INT</name>
              <description>CTDAC1 interrupt pending</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC2_INT</name>
              <description>CTDAC2 interrupt pending</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC3_INT</name>
              <description>CTDAC3 interrupt pending</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAR0_INT</name>
              <description>SAR0 interrupt pending</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAR1_INT</name>
              <description>SAR1 interrupt pending</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAR2_INT</name>
              <description>SAR2 interrupt pending</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAR3_INT</name>
              <description>SAR3 interrupt pending</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO0_INT</name>
              <description>FIFO0 interrupt pending</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO1_INT</name>
              <description>FIFO1 interrupt pending</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO2_INT</name>
              <description>FIFO2 interrupt pending</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO3_INT</name>
              <description>FIFO3 interrupt pending</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPSLP_CLOCK_SEL</name>
          <description>Deepsleep clock select</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x71</resetMask>
          <fields>
            <field>
              <name>DPSLP_CLOCK_SEL</name>
              <description>Select source for PASS DPSLP Clock</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLK_LPOSC</name>
                  <description>CLK_DPSLP is set to CLK_LPOSC</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_MF</name>
                  <description>CLK_DPSLP is set to CLK_MF</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DPSLP_CLOCK_DIV</name>
              <description>CLK_DPSLP divider</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_0</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_PWR_CFG</name>
          <description>Analog power configuration</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>PWR_UP_DELAY</name>
              <description>Power up time for analog blocks.  Fastest power up time is achieved with a setting of 0.  Additional time can be added to allow for analog settling.  The power up time is in clk_dpslp cycles. This field is only applicable when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DUTY_CYCLE_SAR_ACT_EN</name>
              <description>Enable for powering down (duty cycling) a SAR in chip active mode.  This is a risk mitigation bit for power reduction in chip active mode.  In order for this field affect SAR operation, the SAR must be configured for deepsleep clocking (SAR_CLOCK_SEL.CLOCK_SEL set to 1), and the SAR must be set for Timer-based hardware triggering (either by following the guidlines in SAR_OVR_CTRL.HW_TR_TIMER_SEL or SAR_SIMULT_CTRL.SIMULT_HW_TIMER_SEL).

If this bit is set for a given SAR, the Timer is the only valid trigger source.  Non-timer based Hardware (DSI) triggers cannot be used nor can Firmware based triggers (FW,Continuous,Injection).  Furthermore, trigger collision functionality will be limited to interrupt generation only.

-0: Legacy (SAR not duty cycled in chip active mode
-1: SAR duty cycled in chip active mode

&lt;0&gt;: Active Mode Duty Cycle enable for SAR0
&lt;1&gt;: Active Mode Duty Cycle enable for SAR1
&lt;2&gt;: Active Mode Duty Cycle enable for SAR2
&lt;3&gt;: Active Mode Duty Cycle enable for SAR3

This field is only applicable when SAR_CLOCK_SEL.CLOCK_SEL =1.

This field can also affect LPOSC functionality in Active Mode (see LPOSC CONFIG.DEEPSLEEP_MODE field for details)</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>4</dimIncrement>
          <name>CTBM_CLOCK_SEL[%s]</name>
          <description>Clock select for CTBm</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>PUMP_CLOCK_SEL</name>
              <description>Select source for CTBm Pump Clock.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <description>CTBm pump clock set by AREF.CTRL.CLOCK_PUMP_PERI_SEL (Legacy).

When configured for legacy operation, the CTBm deeplseep functionality is determined solely by the CTRL.DEEPSLEEP_ON bit.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_DPSLP</name>
                  <description>CTBm pump clock sourced from CLK_DPSLP

When configured for CLK_DPSLP operation, the CTBm deepsleep functionality is determined by the CTRL.DEEPSLEEP_ON bit AND SAR(s) operation (i.e. CTBm is duty cycled with the SAR(s)).  In this mode, the CTBm should only be used as a buffer/gain stage for the SAR(s).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>4</dimIncrement>
          <name>SAR_DPSLP_CTRL[%s]</name>
          <description>Deepsleep control for SARv3</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>enable for SAR deepsleep operation.  SAR_CLOCK_SEL.CLOCK_SEL must be set to 1 for this field to affect SAR operation.

- 0: SAR deeepsleep operation disabled
- 1: SAR deepsleep operation enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>4</dimIncrement>
          <name>SAR_CLOCK_SEL[%s]</name>
          <description>Clock select for SARv3</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>SAR clock select</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <description>- 0: legacy: SAR clock source is CLK_PERI (SAR is only operational in chip ACTIVE mode)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_DPSLP</name>
                  <description>- 1: SAR clock source is CLK_DPSLP (SAR can be operational in both chip ACTIVE and DEEPSLEEP modes)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>2</dim>
          <dimIncrement>4</dimIncrement>
          <name>SAR_TR_SCAN_CNT_STATUS[%s]</name>
          <description>SAR trigger scan control status</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SCAN_CNT_STATUS</name>
              <description>A read from this register returns the current sample count (possible values are 1 through SCAN_TR_SCAN_CNT.SCAN_CNT+1). This field cannot be read if SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR_TR_SCAN_CNT</name>
          <description>SAR trigger scan control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SCAN_CNT</name>
              <description>SAR trigger sample counter. This field determines the number of samples a SAR will take when triggered.  The number of samples is SCAN_COUNT+1.

This feature can be enabled for individual SARs by setting the appropriate bit of SAR_TR_CTRL.TR_SCAN_CNT_SEL.

This feature can be enabled for simultaneously sampled SARs by setting SAR_SIMULT_TR_CTRL.SIMULT_TR_SCAN_CNT_SEL.

If SAR.SAMPLE_CTRL.AVG_MODE is set to INTERLEAVED, the SCAN_CNT must be set an integer multiple of  (1&lt;&lt;AVG_CNTR+1).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR_OVR_CTRL</name>
          <description>SAR HW trigger override</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>HW_TR_TIMER_SEL</name>
              <description>SAR hardware trigger source select (one bit per SAR). SAR must be configured for hardware triggering (SAR.SAMPLE_CTRL.DSI_TRIGGER_EN must be set to 1).

-0: Legacy (tr_sar_in_&lt;N&gt;)
-1: Timer trigger

&lt;0&gt;: HW Trigger source for SAR0
&lt;1&gt;: HW Trigger source for SAR1
&lt;2&gt;: HW Trigger source for SAR2
&lt;3&gt;: HW Trigger source for SAR3</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_SCAN_CNT_SEL</name>
              <description>SAR trigger sample select (one bit per SAR).

-0: Disabled
-1: Enabled, SAR takes SAR_TR_SCAN_CNT per trigger (valid for both Firmware and Edge Senstive Hardware triggering, but ignored for Level Sensitive Hardware triggering and CONTINUOUS triggering).  This feature cannot be enabled if the SAR is configured for Non-Tailgating Injection (SAR.INJ_CHAN_CONFIG.INJ_TAILGATING=0 while SAR.INJ_CHAN_CONFIG.INJ_START_EN=1)

&lt;0&gt;: trigger sample select for SAR0
&lt;1&gt;: trigger sample select for SAR1
&lt;2&gt;: trigger sample select for SAR2
&lt;3&gt;: trigger sample select for SAR3</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_INTR_SCAN_CNT_SEL</name>
              <description>SAR EOS interrupt source select (one bit per SAR).  This feature is not available for FW or Continuous triggering.

-0: Legacy (SAR EOS is the source of the SAR EOS interrupt)
-1: Enabled, SAR EOS interrupt only occurs for the EOS when sample=SAR_TR_SCAN_CNT.SCAN_CNT.

&lt;0&gt;: EOS interrupt sample count select for SAR0
&lt;1&gt;: EOS interrupt sample count select for SAR1
&lt;2&gt;: EOS interrupt sample count select for SAR2
&lt;3&gt;: EOS interrupt sample count select for SAR3</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR_SIMULT_CTRL</name>
          <description>SAR simultaneous trigger control</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000</resetValue>
          <resetMask>0x3C013F</resetMask>
          <fields>
            <field>
              <name>SIMULT_HW_TR_EN</name>
              <description>SAR simultaneous hardware triggering enable (one bit per SAR)
-0: disabled
-1: SAR trigger override enabled (SAR trigger set by SAR_OVR_CTRL register)

&lt;0&gt;: Simultaneuous sampling enable for SAR0
&lt;1&gt;: Simultaneuous sampling enable for SAR1
&lt;2&gt;: Simultaneuous sampling enable for SAR2
&lt;3&gt;: Simultaneuous sampling enable for SAR3

Simultaneous sampling requires at least two bits in this field to be set.
If less than two bits are set, this register will not affect SAR operation.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIMULT_HW_TR_SRC</name>
              <description>Source for Simult Hardware trigger</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SAR_TR_IN_0</name>
                  <description>SAR 0 HW Trigger Input</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SAR_TR_IN_1</name>
                  <description>SAR 1 HW Trigger Input</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SAR_TR_IN_2</name>
                  <description>SAR 2 HW Trigger Input</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SAR_TR_IN_3</name>
                  <description>SAR 3 HW Trigger Input</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SIMULT_HW_TR_TIMER_SEL</name>
              <description>SAR hardware trigger source select
-0: SIMULT_HW_TR_SRC
-1: Timer trigger</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIMULT_HW_TR_LEVEL</name>
              <description>- 0: trigger signal is a pulse input, a positive edge detected on the trigger signal triggers a new scan.
- 1: trigger signal is a level input, as long as the trigger signal remains high the SAR will do continuous scans. This field cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIMULT_HW_SYNC_TR</name>
              <description>- 0: bypass clock domain synchronization of the Simult trigger signal.
- 1: synchronize the Simult trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIMULT_TR_SCAN_CNT_SEL</name>
              <description>Simultaneous trigger sample select
-0: Disabled
-1: Enabled, SAR takes SAR_TR_SCAN_CNT per trigger (valid for both Firmware and Edge Senstive Hardware triggering, but ignored for Level Sensitive Hardware triggering and CONTINUOUS triggering) This feature cannot be enabled if either SAR is configured for Non-Tailgating Injection (SAR.INJ_CHAN_CONFIG.INJ_TAILGATING=0 while SAR.INJ_CHAN_CONFIG.INJ_START_EN=1)</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SIMULT_EOS_INTR_SCAN_CNT_SEL</name>
              <description>Simultaneous SAR EOS interrupt source select.  This feature is not available for FW or Continuous triggering.

-0: Legacy (SAR EOS is the source of the SAR EOS interrupt)
-1: Enabled, SAR EOS interrupt only occurs for the EOS when sample=SAR_TR_SCAN_CNT.SCAN_CNT.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR_SIMULT_FW_START_CTRL</name>
          <description>SAR simultaneous start control</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF000F</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>This field is used to simultaneously FW trigger two or more SARs.

&lt;0&gt;: Firmware trigger for SAR0
&lt;1&gt;: Firmware trigger for SAR1
&lt;2&gt;: Firmware trigger for SAR2
&lt;3&gt;: Firmware trigger for SAR3

If less than two bits are set, this field has no effect.

When firmware writes to this field it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.  This field cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>This field is used to configure two or more SARs for continuous operation.

-0: Continuous mode disabled
-1: Continuously scan enabled channels, ignore triggers.

&lt;0&gt;: Continuous Mode for SAR0
&lt;1&gt;: Continuous Mode for SAR1
&lt;2&gt;: Continuous Mode for SAR2
&lt;3&gt;: Continuous Mode for SAR3

If less than two bits are set, this field has no effect. This field cannot be set when SAR_CLOCK_SEL.CLOCK_SEL =1.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR_TR_OUT_CTRL</name>
          <description>SAR trigger out control</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SAR0_TR_OUT_SEL</name>
              <description>SAR0 Trigger Out Source Select</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <description>sar output trigger is set by SAR.SAMPLE_CTRL.EOS_DSI_OUT_EN condition</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BUFFER_TRIGGER_LEVEL</name>
                  <description>sar output trigger is set by FIFO.CTRL.FIFO_LEVEL condition</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR1_TR_OUT_SEL</name>
              <description>SAR1 Trigger Out Source Select</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <description>sar output trigger is set by SAR.SAMPLE_CTRL.EOS_DSI_OUT_EN condition</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BUFFER_TRIGGER_LEVEL</name>
                  <description>sar output trigger is set by FIFO.CTRL.FIFO_LEVEL condition</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR2_TR_OUT_SEL</name>
              <description>SAR2 Trigger Out Source Select</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <description>sar output trigger is set by SAR.SAMPLE_CTRL.EOS_DSI_OUT_EN condition</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BUFFER_TRIGGER_LEVEL</name>
                  <description>sar output trigger is set by FIFO.CTRL.FIFO_LEVEL condition</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR3_TR_OUT_SEL</name>
              <description>SAR3 Trigger Out Source Select</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <description>sar output trigger is set by SAR.SAMPLE_CTRL.EOS_DSI_OUT_EN condition</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BUFFER_TRIGGER_LEVEL</name>
                  <description>sar output trigger is set by FIFO.CTRL.FIFO_LEVEL condition</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <name>TIMER</name>
          <description>Programmable Analog Subsystem</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Timer trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>0=disabled, 1=enabled

Upon enable, the timer will immediately generate a trigger pulse (lasting for one clock cycle of the selected CONFIF.CLOCK_SEL) and will generate subsequent trigger pulses (again lasting one clock cycle) whenever the timer reaches terminal count.  If PERIOD.PER_VAL is set to 0, the timer trigger output will remain high as long as the timer is enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>Timer trigger configuration register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>CLOCK_SEL</name>
                <description>Select Clock source of the Timer</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CLK_PERI</name>
                    <description>Timer clocked from CLK_PERI</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_DPSLP</name>
                    <description>Timer clocked from CLK_DPSLP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_LF</name>
                    <description>Timer clocked from CLK_LF</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TBD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Timer trigger period register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PER_VAL</name>
                <description>Actual timer period is PER_VAL+1 (1 to 65536).

Only non-zero PER_VAL are supported.  (i.e. PER_VAL=0 is considered invalid).</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>LPOSC</name>
          <description>LPOSC configuration</description>
          <addressOffset>0x00000200</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Low Power Oscillator control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Master enable for LPOSC oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the LPOSC during DEEPSLEEP (unless DEEPSLEEP_MODE is set)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>Low Power Oscillator configuration register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>DEEPSLEEP_MODE</name>
                <description>LPOSC functionality while in DEEPSLEEP.  

If the ANA_PWR_CFG.DUTY_CYCLE_SAR_ACT_EN bit of a Deepsleep configured SAR is set, the DEEPSLEEP_MODE field for the LPOSC also applies to chip active mode (i.e. the LPOSC will get duty cycled in chip active mode if DEEPSLEEP_MODE=0 and DUTY_CYLE_SAR_ACT_EN=1 for all Deepsleep enabled SAR(s))</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DUTYCYCLED</name>
                    <description>LPOSC enabled by TIMER trigger</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ALWAYS_ON</name>
                    <description>LPOSC always on in deepsleep</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ADFT</name>
            <description>Retention, Hidden</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>ADFT_SEL</name>
                <description>ADFT selection for LPOSC.
0: DFT disabled
1: Measure Vdo; expect ~0.8V
2: Measure Ibias_ptat; expect ~250nA
3: Measure Ibias_ctat; expect ~550nA</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>FIFO[%s]</name>
          <description>FIFO configuration</description>
          <addressOffset>0x00000300</addressOffset>
          <register>
            <name>CTRL</name>
            <description>FIFO control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Enable for SAR FIFO functionality.  If CONFIG.CHAIN_TO_NXT is set, the ENABLED bit of the NEXT FIFO is set when FIFO[0] is enabled.
- 0: FIFO disabled
- 1: FIFO enabled</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>FIFO configuration register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>CHAN_ID_EN</name>
                <description>channel number (ID) enable bit

-0: CHAN_ID field in RD_DATA is disabled.  A read from RD_DATA will result in (4'b0,16'b RESULT)

-1: CHAN_ID field in RD_DATA is enabled. A read from RD_DATA will result in (4'b CHAN_ID, 16'b RESULT)


If CHAIN_EN is enabled, only FIFO[0].config.chan_id_en should be configured and the other FIFOs in the chain will inherit the FIFO[0] config.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHAIN_TO_NXT</name>
                <description>Chain FIFO to next FIFO (i.e. chain FIFO0 and FIFO1).
- 0: FIFO not chained . FIFO operates independently (FIFO depth of 64) and only operates on result data from  its associated SAR.
- 1: FIFO chained to next FIFO.  FIFO is part of a chain of FIFOs (effectively extending the FIFO depth beyond 64) and only operates on result data from SAR0.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INTR_CLR_RD_EN</name>
                <description>Enable for FIFO read clearing the FIFO level trigger and level interrupt.
- 0: Disabled, FIFO level trigger and level interrupt generation follows LEVEL.LEVEL.
- 1: Enabled, after initial FIFO level trigger and level interrupt generation, subsequent FIFO level triggers and level interrupts are blocked until at least FIFO.LEVEL+1 reads have occurred.

If CHAIN_TO_NXT is enabled, only FIFO[0].CONFIG. TR_CLR_RD_EN should be configured.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLEAR</name>
            <description>FIFO clear register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CLEAR</name>
                <description>When firmware writes a 1 here it will trigger and clearing of the FIFO status registers (excluding interrupts), hardware clears this bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LEVEL</name>
            <description>FIFO level register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>LEVEL</name>
                <description>FIFO level set.  A trigger (and optional interrupt) event occurs when USED.USED = LEVEL+1.  (Trigger generation is also affect by CONFIG.TR_CLR_RD_EN). 

If CHAIN_TO_NXT is disabled, the Max LEVEL is limited to 63.  

If CHAIN_TO_NXT is enabled, only FIFO[0].config.level should be configured and the Max LEVEL is set by the number of FIFOs in the chain.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USED</name>
            <description>FIFO used register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>USED</name>
                <description>Number of used/occupied entries in the FIFO. 

If CONFIG.CHAIN_EN is disabled, the field value is in the range [0, 64]. When '0', the FIFO is empty. When '64', the FIFO is full.  

If CONFIG.CHAIN_EN is enabled, only FIFO[0].USED.USED should be read to detemine the used status.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>FIFO status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>RD_PTR</name>
                <description>FIFO read pointer: FIFO location from which a data is read.

Note: This functionality is intended for debugging purposes.

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].STATUS.RD_PTR should be read to detemine the read pointer location of the chained FIFO.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_PTR</name>
                <description>FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].STATUS.WR_PTR should be read to detemine the write pointer location of the chained FIFO.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DATA</name>
            <description>FIFO read data register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>RESULT</name>
                <description>SAR result.  Results from all enabled channels are stored in the buffer. 

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].RD_DATA.RESULT should be read.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CHAN_ID</name>
                <description>Channel number for a given SAR result. Requires CTRL.CHAN_ID_EN to be set. 

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].RD_DATA.CHAN_ID should be read.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL</name>
                <description>HW sets this field to '1', when STATUS.USED &gt;= CTRL.LEVEL+1

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].INTR.FIFO_LEVEL is updated by hardware. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>HW sets this field to '1', when writing to a full FIFO (FIFO_STATUS.USED is '64').

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].INTR.FIFO_OVERFLOW is updated by hardware. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>HW sets this field to '1', when reading from an empty FIFO. HW tracks underflow after FIFO is being written to and FIFO_CTL.ENABLE==1.

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].INTR.FIFO_UNDERFLOW is updated by hardware. Write with '1' to clear bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL</name>
                <description>Write this field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Write this field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL</name>
                <description>Mask for corresponding field in INTR register.

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].INTR_MASK.FIFO_LEVEL should be set.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Mask for corresponding field in INTR register.

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].INTR_MASK.FIFO_OVERFLOW should be set.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Mask for corresponding field in INTR register.

If CONFIG.CHAIN_TO_NXT is enabled, only FIFO[0].INTR_MASK.FIFO_UNDERFLOW should be set.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked register</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FIFO_LEVEL</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_OVERFLOW</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FIFO_UNDERFLOW</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>AREFV2</name>
          <description>AREF configuration</description>
          <addressOffset>0x00000E00</addressOffset>
          <register>
            <name>AREF_CTRL</name>
            <description>global AREF control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF039FFFD</resetMask>
            <fields>
              <field>
                <name>AREF_MODE</name>
                <description>Control bit to trade off AREF settling and noise performance</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NORMAL</name>
                    <description>Nominal noise normal startup mode (meets normal mode settling and noise specifications)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FAST_START</name>
                    <description>High noise fast startup mode (meets fast mode settling and noise specifications)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AREF_BIAS_SCALE</name>
                <description>BIAS Current Control for all AREF Amplifiers.  (These are risk mitigation bits that should not be touched by the customer:  the impact on IDDA/noise/startup still needs to be characterized)
0: 125nA (reduced bias: reduction in total AREF IDDA, higher noise and longer startup times)
1: 250nA ('default' setting to meet bandgap performance (noise/startup) and IDDA specifications)
2: 375nA (increased bias: increase in total AREF IDDA, lower noise and shorter startup times)
3: 500nA (further increased bias: increase in total AREF IDDA, lower noise and shorter startup times)</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AREF_RMB</name>
                <description>AREF control signals (RMB).

Bit 0: Manual VBG startup circuit enable
         0: normal VBG startup circuit operation
         1: VBG startup circuit is forced 'always on'

Bit 1: Manual disable of IPTAT2 DAC
         0: normal IPTAT2 DAC operation
         1: PTAT2 DAC is disabled while VBG startup is active

Bit 2: Manual enable of VBG offset correction DAC
         0: normal VBG offset correction DAC operation
         1: VBG offset correction DAC is enabled while VBG startup is active</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTB_IPTAT_SCALE</name>
                <description>CTB IPTAT current scaler.  This bit must be set in order to operate the CTB amplifiers in the lowest power mode.  This bit is chip-wide (controls all CTB amplifiers).
0: 1uA
1: 100nA</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTB_IPTAT_REDIRECT</name>
                <description>Re-direct the CTB IPTAT output current. This can be used to reduce amplifier bias glitches during power mode transitions (for PSoC4A/B DSAB backwards compatibility).
0: Opamp&lt;n&gt;.IPTAT = AREF.IPTAT and Opamp&lt;n&gt;.IZTAT= AREF.IZTAT
1: Opamp&lt;n&gt;.IPTAT = HiZ and Opamp&lt;n&gt;.IZTAT= AREF.IPTAT

*Note that in Deep Sleep, the AREF IZTAT and/or IPTAT currents can be disabled and therefore the corresponding Opamp&lt;n&gt;.IZTAT/IPTAT will be HiZ.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IZTAT_SEL</name>
                <description>iztat current select control</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SRSS</name>
                    <description>Use 250nA IZTAT from SRSS</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCAL</name>
                    <description>Use locally generated 250nA</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CLOCK_PUMP_PERI_SEL</name>
                <description>CTBm charge pump clock source select. This field has nothing to do with the AREF.
0: Use the dedicated pump clock from SRSS (default)
1: Use one of the CLK_PERI dividers</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL</name>
                <description>bandgap voltage select control</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SRSS</name>
                    <description>Use 0.8V Vref from SRSS</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCAL</name>
                    <description>Use locally generated Vref</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EXTERNAL</name>
                    <description>Use externally supplied Vref (aref_ext_vref)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEEPSLEEP_MODE</name>
                <description>AREF DeepSleep Operation Modes (only applies if DEEPSLEEP_ON = 1)</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>All blocks 'OFF' in DeepSleep</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IPTAT</name>
                    <description>IPTAT bias generator 'ON' in DeepSleep (used for fast AREF wakeup only: IPTAT outputs not available)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IPTAT_IZTAT</name>
                    <description>IPTAT bias generator and outputs 'ON' in DeepSleep (used for biasing the CTBm with a PTAT current only in deep sleep)

*Note that this mode also requires that the CTB_IPTAT_REDIRECT be set if the CTBm opamp is to operate in DeepSleep</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IPTAT_IZTAT_VREF</name>
                    <description>IPTAT, VREF, and IZTAT generators 'ON' in DeepSleep. This mode provides identical AREF functionality in DeepSleep as in the Active mode.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEEPSLEEP_ON</name>
                <description>- 0: AREF IP disabled/off during DeepSleep power mode
- 1: AREF IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Disable AREF</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>VREF_TRIM0</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VREF_ABS_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VREF_TRIM1</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VREF_TEMPCO_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VREF_TRIM2</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VREF_CURV_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VREF_TRIM3</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VREF_ATTEN_TRIM</name>
              <description>Obsolete</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IZTAT_TRIM0</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IZTAT_ABS_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IZTAT_TRIM1</name>
          <description>IZTAT Trim bits</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IZTAT_TC_TRIM</name>
              <description>IZTAT temperature correction trim (RMB)
0x00 : No IZTAT temperature correction
0xFF : Maximum IZTAT temperature correction

As this is a Risk Mitigation Register, it should be loaded with 0x08.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IPTAT_TRIM0</name>
          <description>IPTAT Trim bits</description>
          <addressOffset>0xF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IPTAT_CORE_TRIM</name>
              <description>IPTAT trim
0x0 : Minimum IPTAT current (~150nA at room)
0xF : Maximum IPTAT current (~350nA at room)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPTAT_CTBM_TRIM</name>
              <description>CTMB PTAT Current Trim
0x0 : Minimum CTMB IPTAT Current (~875nA)
0xF : Maximum CTMB IPTAT Current (~1.1uA)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ICTAT_TRIM0</name>
          <description>ICTAT Trim bits</description>
          <addressOffset>0xF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>ICTAT_TRIM</name>
              <description>ICTAT trim
0x00 : Minimum ICTAT current (~150nA at room)
0x0F : Maximum ICTAT current (~350nA at room)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>